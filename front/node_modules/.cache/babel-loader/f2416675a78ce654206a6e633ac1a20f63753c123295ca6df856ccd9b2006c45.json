{"ast":null,"code":"// Copyright (c) 2016, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst QueryStream = require('./queryStream.js');\nconst BaseDbObject = require('./dbObject.js');\nconst nodbUtil = require('./util.js');\nconst constants = require('./constants.js');\nconst Lob = require('./lob.js');\nconst errors = require('./errors.js');\nclass ResultSet {\n  constructor() {\n    this._rowCache = [];\n    this._processingStarted = false;\n    this._convertedToStream = false;\n    this._allowGetRowCall = false;\n    this._isActive = false;\n  }\n\n  //---------------------------------------------------------------------------\n  // _getAllRows()\n  //\n  // Return all of the rows in the result set.\n  //---------------------------------------------------------------------------\n  async _getAllRows() {\n    try {\n      // retain initial values of the maximum number of rows to fetch and the\n      // number of rows to fetch from the database at a single time\n      let maxRows = this._impl.maxRows;\n      let fetchArraySize = this._impl.fetchArraySize;\n\n      // fetch all rows\n      let rowsFetched = [];\n      while (true) {\n        // eslint-disable-line\n        if (maxRows > 0 && fetchArraySize >= maxRows) {\n          fetchArraySize = maxRows;\n        }\n        const rows = await this._getRows(fetchArraySize);\n        if (rows) {\n          await this._processRows(rows, true);\n          rowsFetched = rowsFetched.concat(rows);\n        }\n        if (rows.length == maxRows || rows.length < fetchArraySize) {\n          break;\n        }\n        if (maxRows > 0) {\n          maxRows -= rows.length;\n        }\n      }\n      return rowsFetched;\n    } finally {\n      await this._impl.close();\n      delete this._impl;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _getRows()\n  //\n  // Return up to the specified number of rows from the result set. If nested\n  // cursors are possible, setup the execute options so that they can be\n  // examined within the implementation's setup routine.\n  //---------------------------------------------------------------------------\n  async _getRows(numRows) {\n    let options = {};\n    if (this._impl.nestedCursorIndices.length > 0) {\n      options = {\n        connection: this._connection,\n        outFormat: this._impl.outFormat,\n        fetchArraySize: this._impl.fetchArraySize,\n        dbObjectAsPojo: this._impl.dbObjectAsPojo,\n        maxRows: this._impl.maxRows,\n        fetchTypeMap: this._impl.fetchTypeMap\n      };\n    }\n    return await this._impl.getRows(numRows, options);\n  }\n\n  //---------------------------------------------------------------------------\n  // _processRows()\n  //\n  // Process rows returned by the implementation. This will transform result\n  // set and LOB implementations into user facing objects. It will also perform\n  // any fetched that are needed (if a result set is undesirable)\n  //---------------------------------------------------------------------------\n  async _processRows(rows, expandNestedCursors) {\n    // transform any nested cursors into user facing objects\n    for (const i of this._impl.nestedCursorIndices) {\n      for (let j = 0; j < rows.length; j++) {\n        const val = rows[j][i];\n        if (val) {\n          const resultSet = new ResultSet();\n          resultSet._setup(this._connection, val);\n          this._impl.metaData[i].metaData = val.metaData;\n          if (expandNestedCursors) {\n            rows[j][i] = await resultSet._getAllRows();\n          } else {\n            rows[j][i] = resultSet;\n          }\n        }\n      }\n    }\n\n    // transform any LOBs into user facing objects\n    for (const i of this._impl.lobIndices) {\n      for (let j = 0; j < rows.length; j++) {\n        const val = rows[j][i];\n        if (val) {\n          const lob = rows[j][i] = new Lob();\n          lob._setup(val, true);\n        }\n      }\n    }\n\n    // transform any database objects into user facing objects\n    for (const i of this._impl.dbObjectIndices) {\n      const dbObjectClass = this._impl.metaData[i].dbTypeClass;\n      for (let j = 0; j < rows.length; j++) {\n        const val = rows[j][i];\n        if (val) {\n          const obj = rows[j][i] = Object.create(dbObjectClass.prototype);\n          obj._impl = val;\n          if (this._impl.dbObjectAsPojo) {\n            rows[j][i] = obj._toPojo();\n          } else if (obj.isCollection) {\n            rows[j][i] = new Proxy(obj, BaseDbObject._collectionProxyHandler);\n          }\n        }\n      }\n    }\n\n    // run any conversion functions, if applicable\n    // NOTE: we mark the connection as no longer in progress before making\n    // calls to the converter function; this is needed to allow calls against\n    // the database (like getting LOB data) to succeed, as this code is running\n    // in the middle of a call to connection.execute() or resultSet.getRows()\n    for (const i of this._impl.converterIndices) {\n      const fn = this._impl.metaData[i].converter;\n      this._connection._impl._inProgress = false;\n      try {\n        for (let j = 0; j < rows.length; j++) {\n          let result = fn(rows[j][i]);\n          if (result instanceof Promise) {\n            result = await result;\n          }\n          rows[j][i] = result;\n        }\n      } finally {\n        this._connection._impl._inProgress = true;\n      }\n    }\n\n    // create objects, if desired\n    if (this._impl.outFormat === constants.OUT_FORMAT_OBJECT) {\n      for (let i = 0; i < rows.length; i++) {\n        const origRow = rows[i];\n        const newRow = rows[i] = {};\n        const metaData = this._impl.metaData;\n        for (let j = 0; j < metaData.length; j++) {\n          newRow[metaData[j].name] = origRow[j];\n        }\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _setup()\n  //\n  // Setup a result set.\n  // ---------------------------------------------------------------------------\n  _setup(connection, resultSetImpl) {\n    this._connection = connection;\n    this._impl = resultSetImpl;\n  }\n\n  //---------------------------------------------------------------------------\n  // close()\n  //\n  // Close the result set and make it unusable for further operations.\n  //---------------------------------------------------------------------------\n  async close() {\n    errors.assertArgCount(arguments, 0, 0);\n    errors.assert(this._impl && this._connection._impl, errors.ERR_INVALID_RS);\n    if (this._convertedToStream) {\n      errors.throwErr(errors.ERR_CANNOT_INVOKE_RS_METHODS);\n    }\n    this._processingStarted = true;\n    const resultSetImpl = this._impl;\n    delete this._impl;\n    await resultSetImpl.close();\n  }\n\n  //---------------------------------------------------------------------------\n  // getRow()\n  //\n  // Returns a single row to the caller from the result set, if one is\n  // available. Rows are buffered in a JavaScript array in order to avoid trips\n  // through the thread pool that would be required if implemented in C.\n  //---------------------------------------------------------------------------\n  async getRow() {\n    errors.assertArgCount(arguments, 0, 0);\n    errors.assert(this._impl && this._connection._impl, errors.ERR_INVALID_RS);\n    if (this._convertedToStream && !this._allowGetRowCall) {\n      errors.throwErr(errors.ERR_CANNOT_INVOKE_RS_METHODS);\n    }\n    this._allowGetRowCall = false;\n    this._processingStarted = true;\n    if (this._rowCache.length == 0) {\n      const rows = await this._getRows(this._impl.fetchArraySize);\n      await this._processRows(rows, false);\n      this._rowCache = rows;\n    }\n    return this._rowCache.shift();\n  }\n\n  //---------------------------------------------------------------------------\n  // getRows()\n  //\n  // Check to see if any rows are in the JS buffer (which could result from\n  // interspersed calls to getRow() and getRows()). If no rows are in the\n  // buffer, the call is just proxied to the implementation layer. Otherwise,\n  // rows are pulled from the buffer and potentially concatenated with rows\n  // from calls to the implementation's getRows().\n  //---------------------------------------------------------------------------\n  async getRows(numRows) {\n    let rowsNeeded;\n    errors.assertArgCount(arguments, 0, 1);\n    errors.assert(this._impl && this._connection._impl, errors.ERR_INVALID_RS);\n    if (arguments.length == 0) {\n      numRows = 0;\n    } else {\n      errors.assertParamValue(Number.isInteger(numRows) && numRows >= 0, 1);\n    }\n    if (this._convertedToStream) {\n      errors.throwErr(errors.ERR_CANNOT_INVOKE_RS_METHODS);\n    }\n    this._processingStarted = true;\n    let requestedRows;\n    if (numRows == 0) {\n      requestedRows = this._rowCache;\n      const fetchArraySize = this._impl.fetchArraySize;\n      while (true) {\n        // eslint-disable-line\n        const rows = await this._getRows(fetchArraySize);\n        if (rows) {\n          await this._processRows(rows, false);\n          requestedRows = requestedRows.concat(rows);\n        }\n        if (rows.length < fetchArraySize) break;\n      }\n      return requestedRows;\n    }\n    if (this._rowCache.length === 0) {\n      requestedRows = await this._getRows(numRows);\n      await this._processRows(requestedRows, false);\n    } else {\n      rowsNeeded = numRows - this._rowCache.length;\n      if (rowsNeeded <= 0) {\n        requestedRows = this._rowCache.splice(0, numRows);\n      } else {\n        const rows = await this._getRows(rowsNeeded);\n        await this._processRows(rows, false);\n        requestedRows = this._rowCache.concat(rows);\n        this._rowCache = [];\n      }\n    }\n    return requestedRows;\n  }\n\n  //---------------------------------------------------------------------------\n  // metaData()\n  //\n  // Property returning the metadata associated with the result set.\n  //---------------------------------------------------------------------------\n  get metaData() {\n    if (this._impl) {\n      return this._impl.metaData;\n    }\n    return undefined;\n  }\n\n  //---------------------------------------------------------------------------\n  // toQueryStream()\n  //\n  // Converts a result set to a QueryStream object.\n  //---------------------------------------------------------------------------\n  toQueryStream() {\n    errors.assertArgCount(arguments, 0, 0);\n    if (this._processingStarted) {\n      errors.throwErr(errors.ERR_CANNOT_CONVERT_RS_TO_STREAM);\n    }\n    if (this._convertedToStream) {\n      errors.throwErr(errors.ERR_RS_ALREADY_CONVERTED);\n    }\n    this._convertedToStream = true;\n    return new QueryStream(this);\n  }\n  [Symbol.asyncIterator]() {\n    const resultSet = this;\n    return {\n      async next() {\n        const row = await resultSet.getRow();\n        return {\n          value: row,\n          done: row === undefined\n        };\n      },\n      return() {\n        return {\n          done: true\n        };\n      }\n    };\n  }\n}\nnodbUtil.wrapFns(ResultSet.prototype, errors.ERR_BUSY_RS, \"close\", \"getRow\", \"getRows\");\nmodule.exports = ResultSet;","map":{"version":3,"names":["QueryStream","require","BaseDbObject","nodbUtil","constants","Lob","errors","ResultSet","constructor","_rowCache","_processingStarted","_convertedToStream","_allowGetRowCall","_isActive","_getAllRows","maxRows","_impl","fetchArraySize","rowsFetched","rows","_getRows","_processRows","concat","length","close","numRows","options","nestedCursorIndices","connection","_connection","outFormat","dbObjectAsPojo","fetchTypeMap","getRows","expandNestedCursors","i","j","val","resultSet","_setup","metaData","lobIndices","lob","dbObjectIndices","dbObjectClass","dbTypeClass","obj","Object","create","prototype","_toPojo","isCollection","Proxy","_collectionProxyHandler","converterIndices","fn","converter","_inProgress","result","Promise","OUT_FORMAT_OBJECT","origRow","newRow","name","resultSetImpl","assertArgCount","arguments","assert","ERR_INVALID_RS","throwErr","ERR_CANNOT_INVOKE_RS_METHODS","getRow","shift","rowsNeeded","assertParamValue","Number","isInteger","requestedRows","splice","undefined","toQueryStream","ERR_CANNOT_CONVERT_RS_TO_STREAM","ERR_RS_ALREADY_CONVERTED","Symbol","asyncIterator","next","row","value","done","return","wrapFns","ERR_BUSY_RS","module","exports"],"sources":["C:/Users/user1/Desktop/finalproject_penpick/node_modules/oracledb/lib/resultset.js"],"sourcesContent":["// Copyright (c) 2016, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst QueryStream = require('./queryStream.js');\nconst BaseDbObject = require('./dbObject.js');\nconst nodbUtil = require('./util.js');\nconst constants = require('./constants.js');\nconst Lob = require('./lob.js');\nconst errors = require('./errors.js');\n\nclass ResultSet {\n\n  constructor() {\n    this._rowCache = [];\n    this._processingStarted = false;\n    this._convertedToStream = false;\n    this._allowGetRowCall = false;\n    this._isActive = false;\n  }\n\n  //---------------------------------------------------------------------------\n  // _getAllRows()\n  //\n  // Return all of the rows in the result set.\n  //---------------------------------------------------------------------------\n  async _getAllRows() {\n\n    try {\n\n      // retain initial values of the maximum number of rows to fetch and the\n      // number of rows to fetch from the database at a single time\n      let maxRows = this._impl.maxRows;\n      let fetchArraySize = this._impl.fetchArraySize;\n\n      // fetch all rows\n      let rowsFetched = [];\n      while (true) {    // eslint-disable-line\n        if (maxRows > 0 && fetchArraySize >= maxRows) {\n          fetchArraySize = maxRows;\n        }\n        const rows = await this._getRows(fetchArraySize);\n        if (rows) {\n          await this._processRows(rows, true);\n          rowsFetched = rowsFetched.concat(rows);\n        }\n        if (rows.length == maxRows || rows.length < fetchArraySize) {\n          break;\n        }\n        if (maxRows > 0) {\n          maxRows -= rows.length;\n        }\n      }\n\n      return rowsFetched;\n\n    } finally {\n      await this._impl.close();\n      delete this._impl;\n    }\n\n  }\n\n  //---------------------------------------------------------------------------\n  // _getRows()\n  //\n  // Return up to the specified number of rows from the result set. If nested\n  // cursors are possible, setup the execute options so that they can be\n  // examined within the implementation's setup routine.\n  //---------------------------------------------------------------------------\n  async _getRows(numRows) {\n    let options = {};\n    if (this._impl.nestedCursorIndices.length > 0) {\n      options = {\n        connection: this._connection,\n        outFormat: this._impl.outFormat,\n        fetchArraySize: this._impl.fetchArraySize,\n        dbObjectAsPojo: this._impl.dbObjectAsPojo,\n        maxRows: this._impl.maxRows,\n        fetchTypeMap: this._impl.fetchTypeMap\n      };\n    }\n    return await this._impl.getRows(numRows, options);\n  }\n\n  //---------------------------------------------------------------------------\n  // _processRows()\n  //\n  // Process rows returned by the implementation. This will transform result\n  // set and LOB implementations into user facing objects. It will also perform\n  // any fetched that are needed (if a result set is undesirable)\n  //---------------------------------------------------------------------------\n  async _processRows(rows, expandNestedCursors) {\n\n    // transform any nested cursors into user facing objects\n    for (const i of this._impl.nestedCursorIndices) {\n      for (let j = 0; j < rows.length; j++) {\n        const val = rows[j][i];\n        if (val) {\n          const resultSet = new ResultSet();\n          resultSet._setup(this._connection, val);\n          this._impl.metaData[i].metaData = val.metaData;\n          if (expandNestedCursors) {\n            rows[j][i] = await resultSet._getAllRows();\n          } else {\n            rows[j][i] = resultSet;\n          }\n        }\n      }\n    }\n\n    // transform any LOBs into user facing objects\n    for (const i of this._impl.lobIndices) {\n      for (let j = 0; j < rows.length; j++) {\n        const val = rows[j][i];\n        if (val) {\n          const lob = rows[j][i] = new Lob();\n          lob._setup(val, true);\n        }\n      }\n    }\n\n    // transform any database objects into user facing objects\n    for (const i of this._impl.dbObjectIndices) {\n      const dbObjectClass = this._impl.metaData[i].dbTypeClass;\n      for (let j = 0; j < rows.length; j++) {\n        const val = rows[j][i];\n        if (val) {\n          const obj = rows[j][i] = Object.create(dbObjectClass.prototype);\n          obj._impl = val;\n          if (this._impl.dbObjectAsPojo) {\n            rows[j][i] = obj._toPojo();\n          } else if (obj.isCollection) {\n            rows[j][i] = new Proxy(obj, BaseDbObject._collectionProxyHandler);\n          }\n        }\n      }\n    }\n\n    // run any conversion functions, if applicable\n    // NOTE: we mark the connection as no longer in progress before making\n    // calls to the converter function; this is needed to allow calls against\n    // the database (like getting LOB data) to succeed, as this code is running\n    // in the middle of a call to connection.execute() or resultSet.getRows()\n    for (const i of this._impl.converterIndices) {\n      const fn = this._impl.metaData[i].converter;\n      this._connection._impl._inProgress = false;\n      try {\n        for (let j = 0; j < rows.length; j++) {\n          let result = fn(rows[j][i]);\n          if (result instanceof Promise) {\n            result = await result;\n          }\n          rows[j][i] = result;\n        }\n      } finally {\n        this._connection._impl._inProgress = true;\n      }\n    }\n\n    // create objects, if desired\n    if (this._impl.outFormat === constants.OUT_FORMAT_OBJECT) {\n      for (let i = 0; i < rows.length; i++) {\n        const origRow = rows[i];\n        const newRow = rows[i] = {};\n        const metaData = this._impl.metaData;\n        for (let j = 0; j < metaData.length; j++) {\n          newRow[metaData[j].name] = origRow[j];\n        }\n      }\n    }\n\n  }\n\n  //---------------------------------------------------------------------------\n  // _setup()\n  //\n  // Setup a result set.\n  // ---------------------------------------------------------------------------\n  _setup(connection, resultSetImpl) {\n    this._connection = connection;\n    this._impl = resultSetImpl;\n  }\n\n  //---------------------------------------------------------------------------\n  // close()\n  //\n  // Close the result set and make it unusable for further operations.\n  //---------------------------------------------------------------------------\n  async close() {\n    errors.assertArgCount(arguments, 0, 0);\n    errors.assert(this._impl && this._connection._impl, errors.ERR_INVALID_RS);\n\n    if (this._convertedToStream) {\n      errors.throwErr(errors.ERR_CANNOT_INVOKE_RS_METHODS);\n    }\n\n    this._processingStarted = true;\n    const resultSetImpl = this._impl;\n    delete this._impl;\n    await resultSetImpl.close();\n  }\n\n  //---------------------------------------------------------------------------\n  // getRow()\n  //\n  // Returns a single row to the caller from the result set, if one is\n  // available. Rows are buffered in a JavaScript array in order to avoid trips\n  // through the thread pool that would be required if implemented in C.\n  //---------------------------------------------------------------------------\n  async getRow() {\n    errors.assertArgCount(arguments, 0, 0);\n    errors.assert(this._impl && this._connection._impl, errors.ERR_INVALID_RS);\n\n    if (this._convertedToStream && !this._allowGetRowCall) {\n      errors.throwErr(errors.ERR_CANNOT_INVOKE_RS_METHODS);\n    }\n\n    this._allowGetRowCall = false;\n    this._processingStarted = true;\n\n    if (this._rowCache.length == 0) {\n      const rows = await this._getRows(this._impl.fetchArraySize);\n      await this._processRows(rows, false);\n      this._rowCache = rows;\n    }\n    return this._rowCache.shift();\n  }\n\n  //---------------------------------------------------------------------------\n  // getRows()\n  //\n  // Check to see if any rows are in the JS buffer (which could result from\n  // interspersed calls to getRow() and getRows()). If no rows are in the\n  // buffer, the call is just proxied to the implementation layer. Otherwise,\n  // rows are pulled from the buffer and potentially concatenated with rows\n  // from calls to the implementation's getRows().\n  //---------------------------------------------------------------------------\n  async getRows(numRows) {\n    let rowsNeeded;\n\n    errors.assertArgCount(arguments, 0, 1);\n    errors.assert(this._impl && this._connection._impl, errors.ERR_INVALID_RS);\n\n    if (arguments.length == 0) {\n      numRows = 0;\n    } else {\n      errors.assertParamValue(Number.isInteger(numRows) && numRows >= 0, 1);\n    }\n\n    if (this._convertedToStream) {\n      errors.throwErr(errors.ERR_CANNOT_INVOKE_RS_METHODS);\n    }\n\n    this._processingStarted = true;\n\n    let requestedRows;\n    if (numRows == 0) {\n      requestedRows = this._rowCache;\n      const fetchArraySize = this._impl.fetchArraySize;\n      while (true) {  // eslint-disable-line\n        const rows = await this._getRows(fetchArraySize);\n        if (rows) {\n          await this._processRows(rows, false);\n          requestedRows = requestedRows.concat(rows);\n        }\n        if (rows.length < fetchArraySize)\n          break;\n      }\n      return requestedRows;\n    }\n\n    if (this._rowCache.length === 0) {\n      requestedRows = await this._getRows(numRows);\n      await this._processRows(requestedRows, false);\n    } else {\n      rowsNeeded = numRows - this._rowCache.length;\n      if (rowsNeeded <= 0) {\n        requestedRows = this._rowCache.splice(0, numRows);\n      } else {\n        const rows = await this._getRows(rowsNeeded);\n        await this._processRows(rows, false);\n        requestedRows = this._rowCache.concat(rows);\n        this._rowCache = [];\n      }\n    }\n\n    return requestedRows;\n  }\n\n  //---------------------------------------------------------------------------\n  // metaData()\n  //\n  // Property returning the metadata associated with the result set.\n  //---------------------------------------------------------------------------\n  get metaData() {\n    if (this._impl) {\n      return this._impl.metaData;\n    }\n    return undefined;\n  }\n\n  //---------------------------------------------------------------------------\n  // toQueryStream()\n  //\n  // Converts a result set to a QueryStream object.\n  //---------------------------------------------------------------------------\n  toQueryStream() {\n    errors.assertArgCount(arguments, 0, 0);\n\n    if (this._processingStarted) {\n      errors.throwErr(errors.ERR_CANNOT_CONVERT_RS_TO_STREAM);\n    }\n\n    if (this._convertedToStream) {\n      errors.throwErr(errors.ERR_RS_ALREADY_CONVERTED);\n    }\n\n    this._convertedToStream = true;\n\n    return new QueryStream(this);\n  }\n\n  [Symbol.asyncIterator]() {\n    const resultSet = this;\n    return {\n      async next() {\n        const row = await resultSet.getRow();\n        return {value: row, done: row === undefined};\n      },\n      return() {\n        return {done: true};\n      }\n    };\n  }\n\n}\n\nnodbUtil.wrapFns(ResultSet.prototype, errors.ERR_BUSY_RS,\n  \"close\",\n  \"getRow\",\n  \"getRows\");\n\nmodule.exports = ResultSet;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}