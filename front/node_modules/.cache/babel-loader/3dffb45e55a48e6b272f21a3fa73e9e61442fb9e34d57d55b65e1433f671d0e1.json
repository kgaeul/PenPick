{"ast":null,"code":"// Copyright (c) 2016, 2022, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst Connection = require('./connection.js');\nconst EventEmitter = require('events');\nconst constants = require('./constants.js');\nconst errors = require('./errors.js');\nconst settings = require('./settings.js');\nconst nodbUtil = require('./util.js');\nconst impl = require('./impl');\nconst PoolStatistics = require('./poolStatistics.js');\nclass Pool extends EventEmitter {\n  constructor() {\n    super();\n    this._impl = new impl.PoolImpl();\n    this._queueMax = 0;\n    this._queueTimeout = 0;\n    this._enableStatistics = false;\n    this._timeOfReset = this._createdDate = Date.now();\n    this._sessionCallback = undefined;\n    this._connRequestQueue = [];\n    this._connectionClass = settings.connectionClass;\n  }\n\n  //---------------------------------------------------------------------------\n  // _checkPoolOpen()\n  //\n  // Check if the pool is open (not draining/reconfiguring/closed) and throw an\n  // appropriate exception if not.\n  //---------------------------------------------------------------------------\n  _checkPoolOpen(ignoreReconfiguring) {\n    if (this.status === constants.POOL_STATUS_DRAINING) {\n      errors.throwErr(errors.ERR_POOL_CLOSING);\n    } else if (this.status === constants.POOL_STATUS_CLOSED) {\n      errors.throwErr(errors.ERR_POOL_CLOSED);\n    } else if (!ignoreReconfiguring) {\n      if (this.status === constants.POOL_STATUS_RECONFIGURING) {\n        errors.throwErr(errors.ERR_POOL_RECONFIGURING);\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _checkRequestQueue()\n  //\n  // When a connection is returned to the pool, this method is called (via an\n  // event handler) to determine when requests for connections should be\n  // resumed and cancels any timeout that may have been associated with the\n  // request. This method is also called from reconfigure() so that waiting\n  // connection requests can be processed. Note the use of a local variable for\n  // the number of connections out. This is because the connection requests will\n  // not resume until after the loop is finished, and therefore the number of\n  // connections the pool thinks is out will not be incremented.\n  //---------------------------------------------------------------------------\n  _checkRequestQueue() {\n    let connectionsOut = this._connectionsOut;\n    while (this._connRequestQueue.length > 0 && connectionsOut < this.poolMax) {\n      connectionsOut += 1;\n      const payload = this._connRequestQueue.shift();\n      if (this._enableStatistics) {\n        this._totalRequestsDequeued += 1;\n        this._updateWaitStatistics(payload);\n      }\n      if (payload.timeoutHandle) {\n        clearTimeout(payload.timeoutHandle);\n      }\n      // inform the waiter that processing can continue\n      payload.resolve();\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _enableStats (DEPRECATED)\n  //\n  // Property for whether statistics are enabled on the pool.\n  //---------------------------------------------------------------------------\n  get _enableStats() {\n    return this._enableStatistics;\n  }\n\n  //---------------------------------------------------------------------------\n  // _resetStatistics()\n  //  To initialize the counters/timers\n  //---------------------------------------------------------------------------\n  _resetStatistics() {\n    this._timeOfReset = Date.now();\n    this._totalConnectionRequests = 0;\n    this._totalRequestsEnqueued = 0;\n    this._totalRequestsDequeued = 0;\n    this._totalFailedRequests = 0;\n    this._totalRequestsRejected = 0;\n    this._totalRequestTimeouts = 0;\n    this._maximumQueueLength = this._connRequestQueue.length;\n    this._totalTimeInQueue = 0;\n    this._minTimeInQueue = 0;\n    this._maxTimeInQueue = 0;\n  }\n\n  //---------------------------------------------------------------------------\n  // _setup()\n  //\n  // Sets up the pool instance with additional attributes used for logging\n  // statistics and managing the connection queue.\n  //---------------------------------------------------------------------------\n  _setup(options, poolAlias) {\n    this._queueTimeout = options.queueTimeout;\n    this._queueMax = options.queueMax;\n    this._enableStatistics = options.enableStatistics;\n    this._edition = options.edition;\n    this._eventsFlag = options.events;\n    this._externalAuth = options.externalAuth;\n    this._homogeneous = options.homogeneous;\n    this._user = options.user;\n    this._connectString = options.connectString;\n    this._status = constants.POOL_STATUS_OPEN;\n    this._connectionsOut = 0;\n    this._poolAlias = poolAlias;\n\n    // register event handler for when request queue should be checked\n    this.on('_checkRequestQueue', this._checkRequestQueue);\n    this._resetStatistics();\n  }\n\n  //---------------------------------------------------------------------------\n  // _updateWaitStatistics()\n  //\n  // Update pool wait statistics after a connect request has spent some time in\n  // the queue.\n  //---------------------------------------------------------------------------\n  _updateWaitStatistics(payload) {\n    const waitTime = Date.now() - payload.enqueuedTime;\n    this._totalTimeInQueue += waitTime;\n    if (this._minTimeInQueue === 0) {\n      this._minTimeInQueue = waitTime;\n    } else {\n      this._minTimeInQueue = Math.min(this._minTimeInQueue, waitTime);\n    }\n    this._maxTimeInQueue = Math.max(this._maxTimeInQueue, waitTime);\n  }\n\n  //---------------------------------------------------------------------------\n  // _verifyGetConnectionOptions()\n  //\n  // Verify the getConnection() options are acceptable. Performs any\n  // transformations that are needed before returning the options to the\n  // caller.\n  //---------------------------------------------------------------------------\n  _verifyGetConnectionOptions(options) {\n    // define normalized options (value returned to caller)\n    const outOptions = {};\n\n    // only one of \"user\" and \"username\" may be specified (and must be strings)\n    if (options.user !== undefined) {\n      errors.assertParamPropValue(typeof options.user === 'string', 1, \"user\");\n      outOptions.user = options.user;\n    }\n    if (options.username !== undefined) {\n      errors.assert(outOptions.user === undefined, errors.ERR_DBL_USER);\n      errors.assertParamPropValue(typeof options.username === 'string', 1, \"username\");\n      outOptions.user = options.username;\n    }\n    if (this.externalAuth && outOptions.user && (outOptions.user[0] !== '[' || outOptions.user.slice(-1) !== ']')) {\n      // username is not enclosed in [].\n      errors.throwErr(errors.ERR_WRONG_USER_FORMAT_EXTAUTH_PROXY);\n    }\n\n    // password must be a string\n    if (options.password !== undefined) {\n      errors.assertParamPropValue(typeof options.password === 'string', 1, \"password\");\n      if (this.externalAuth) {\n        errors.throwErr(errors.ERR_WRONG_CRED_FOR_EXTAUTH);\n      }\n      outOptions.password = options.password;\n    }\n\n    // tag must be a string\n    if (options.tag !== undefined) {\n      errors.assertParamPropValue(typeof options.tag === 'string', 1, \"tag\");\n      outOptions.tag = options.tag;\n    }\n\n    // matchAnyTag must be a boolean\n    if (options.matchAnyTag !== undefined) {\n      errors.assertParamPropValue(typeof options.matchAnyTag === 'boolean', 1, \"matchAnyTag\");\n      outOptions.matchAnyTag = options.matchAnyTag;\n    }\n\n    // shardingKey must be an array of values\n    if (options.shardingKey !== undefined) {\n      const value = options.shardingKey;\n      errors.assertParamPropValue(nodbUtil.isShardingKey(value), 1, \"shardingKey\");\n      outOptions.shardingKey = options.shardingKey;\n    }\n\n    // superShardingKey must be an array of values\n    if (options.superShardingKey !== undefined) {\n      const value = options.superShardingKey;\n      errors.assertParamPropValue(nodbUtil.isShardingKey(value), 1, \"superShardingKey\");\n      outOptions.superShardingKey = options.superShardingKey;\n    }\n    return outOptions;\n  }\n\n  //---------------------------------------------------------------------------\n  // close()\n  //\n  // Close the pool, optionally allowing for a period of time to pass for\n  // connections to \"drain\" from the pool.\n  //---------------------------------------------------------------------------\n  async close(a1) {\n    let drainTime = 0;\n    let forceClose = false;\n\n    // check arguments\n    errors.assertArgCount(arguments, 0, 1);\n    if (arguments.length == 1) {\n      // drain time must be a valid number; timeouts larger than a 32-bit signed\n      // integer are not supported\n      errors.assertParamValue(typeof a1 === 'number', 1);\n      if (a1 < 0 || isNaN(a1) || a1 > 2 ** 31) {\n        errors.throwErr(errors.ERR_INVALID_PARAMETER_VALUE, 1);\n      }\n\n      // no need to worry about drain time if no connections are out!\n      forceClose = true;\n      if (this._connectionsOut > 0) {\n        drainTime = a1 * 1000;\n      }\n    }\n\n    // if the pool is draining/reconfiguring/closed, throw an appropriate error\n    this._checkPoolOpen(false);\n\n    // wait for the pool to become empty or for the drain timeout to expire\n    // (whichever comes first)\n    if (drainTime > 0) {\n      this._status = constants.POOL_STATUS_DRAINING;\n      await new Promise(resolve => {\n        const timeout = setTimeout(() => {\n          this.removeAllListeners('_allCheckedIn');\n          resolve();\n        }, drainTime);\n        this.once('_allCheckedIn', () => {\n          clearTimeout(timeout);\n          resolve();\n        });\n      });\n    }\n\n    // if any connections are still out and the pool is not being force closed,\n    // throw an exception\n    if (!forceClose && this._connectionsOut > 0) {\n      errors.throwErr(errors.ERR_POOL_HAS_BUSY_CONNECTIONS);\n    }\n\n    // close the pool\n    await this._impl.close();\n    this._status = constants.POOL_STATUS_CLOSED;\n    this.emit('_afterPoolClose');\n  }\n\n  //---------------------------------------------------------------------------\n  // connectionsInUse\n  //\n  // Property for the number of connections in use by the pool.\n  //---------------------------------------------------------------------------\n  get connectionsInUse() {\n    return this._impl.getConnectionsInUse();\n  }\n\n  //---------------------------------------------------------------------------\n  // connectionsOpen\n  //\n  // Property for the number of connections opened by the pool.\n  //---------------------------------------------------------------------------\n  get connectionsOpen() {\n    return this._impl.getConnectionsOpen();\n  }\n\n  //---------------------------------------------------------------------------\n  // connectString\n  //\n  // Property for the connect string used to create the pool.\n  //---------------------------------------------------------------------------\n  get connectString() {\n    return this._connectString;\n  }\n\n  //---------------------------------------------------------------------------\n  // thin()\n  //\n  // return true, if driver mode is thin while creating pool\n  // return false, if driver mode is thick while creating pool\n  //---------------------------------------------------------------------------\n  get thin() {\n    return settings.thin;\n  }\n\n  //---------------------------------------------------------------------------\n  // edition\n  //\n  // Property for the edition used to create the pool.\n  //---------------------------------------------------------------------------\n  get edition() {\n    return this._edition;\n  }\n\n  //---------------------------------------------------------------------------\n  // enableStatistics\n  //\n  // Property for whether statistics are enabled on the pool.\n  //---------------------------------------------------------------------------\n  get enableStatistics() {\n    return this._enableStatistics;\n  }\n\n  //---------------------------------------------------------------------------\n  // events\n  //\n  // Property for the events flag value used to create the pool.\n  //---------------------------------------------------------------------------\n  get events() {\n    return this._eventsFlag;\n  }\n\n  //---------------------------------------------------------------------------\n  // externalAuth\n  //\n  // Property for the externalAuth flag value used to create the pool.\n  //---------------------------------------------------------------------------\n  get externalAuth() {\n    return this._externalAuth;\n  }\n\n  //---------------------------------------------------------------------------\n  // getConnection()\n  //\n  // Gets a connection from the pool and returns it to the caller. If there are\n  // fewer connections out than the poolMax setting, then the request will\n  // return immediately; otherwise, the request will be queued for up to\n  // queueTimeout milliseconds.\n  //---------------------------------------------------------------------------\n  async getConnection(a1) {\n    let poolMax;\n    let options = {};\n\n    // check arguments\n    errors.assertArgCount(arguments, 0, 1);\n    if (arguments.length == 1) {\n      errors.assertParamValue(nodbUtil.isObject(a1), 1);\n      options = this._verifyGetConnectionOptions(a1);\n    }\n\n    // get connection class value from pool\n    options.connectionClass = this._connectionClass;\n\n    // if pool is draining/closed, throw an appropriate error\n    this._checkPoolOpen(true);\n\n    // manage stats, if applicable\n    if (this._enableStatistics) {\n      this._totalConnectionRequests += 1;\n    }\n\n    // getting the poolMax setting on the pool may fail if the pool is no\n    // longer valid\n    try {\n      poolMax = this.poolMax;\n    } catch (err) {\n      if (this._enableStatistics) {\n        this._totalFailedRequests += 1;\n      }\n      throw err;\n    }\n    if (this._connectionsOut >= poolMax || this.status === constants.POOL_STATUS_RECONFIGURING) {\n      // when the queue is huge, throw error early without waiting for queue\n      // timeout\n      if (this._connRequestQueue.length >= this._queueMax && this._queueMax >= 0) {\n        if (this._enableStatistics) {\n          this._totalRequestsRejected += 1;\n        }\n        errors.throwErr(errors.ERR_QUEUE_MAX_EXCEEDED, this._queueMax);\n      }\n\n      // if too many connections are out, wait until room is made available or\n      // the queue timeout expires\n      await new Promise((resolve, reject) => {\n        // set up a payload which will be added to the queue for processing\n        const payload = {\n          resolve: resolve,\n          reject: reject\n        };\n\n        // if using a queue timeout, establish the timeout so that when it\n        // expires the payload will be removed from the queue and an exception\n        // thrown\n        if (this._queueTimeout !== 0) {\n          payload.timeoutHandle = setTimeout(() => {\n            const ix = this._connRequestQueue.indexOf(payload);\n            if (ix >= 0) {\n              this._connRequestQueue.splice(ix, 1);\n            }\n            if (this._enableStatistics) {\n              this._totalRequestTimeouts += 1;\n              this._updateWaitStatistics(payload);\n            }\n            try {\n              errors.throwErr(errors.ERR_CONN_REQUEST_TIMEOUT, this._queueTimeout);\n            } catch (err) {\n              reject(err);\n            }\n          }, this._queueTimeout);\n        }\n\n        // add payload to the queue\n        this._connRequestQueue.push(payload);\n        if (this._enableStatistics) {\n          payload.enqueuedTime = Date.now();\n          this._totalRequestsEnqueued += 1;\n          this._maximumQueueLength = Math.max(this._maximumQueueLength, this._connRequestQueue.length);\n        }\n      });\n\n      // check if pool is draining/closed after delay has\n      // completed and throw an appropriate error\n      this._checkPoolOpen(true);\n    }\n\n    // room is available in the queue, so proceed to acquire a connection from\n    // the pool; adjust the connections out immediately in order to ensure that\n    // another attempt doesn't proceed while this one is underway\n    this._connectionsOut += 1;\n    try {\n      // acquire connection from the pool\n      const conn = new Connection();\n      conn._impl = await this._impl.getConnection(options);\n      conn._pool = this;\n\n      // invoke tag fixup callback method if one has been specified and the\n      // actual tag on the connection doesn't match the one requested, or the\n      // connection is freshly created; if the callback fails, close the\n      // connection and remove it from the pool\n      const requestedTag = options.tag || \"\";\n      if (typeof this.sessionCallback === 'function' && (conn._impl._newSession || conn.tag != requestedTag)) {\n        try {\n          await new Promise((resolve, reject) => {\n            this.sessionCallback(conn, requestedTag, function (err) {\n              if (err) {\n                reject(err);\n              } else {\n                resolve();\n              }\n            });\n          });\n        } catch (err) {\n          await conn.close({\n            drop: true\n          });\n          throw err;\n        }\n      }\n\n      // when connection is closed, check to see if another request should be\n      // processed and update any stats, as needed\n      conn.on('_afterConnClose', () => {\n        this._connectionsOut -= 1;\n        this.emit('_checkRequestQueue');\n        if (this._connectionsOut == 0) {\n          this.emit('_allCheckedIn');\n        }\n      });\n      return conn;\n    } catch (err) {\n      this._connectionsOut -= 1;\n      if (this._enableStatistics) {\n        this._totalFailedRequests += 1;\n      }\n      this.emit('_checkRequestQueue');\n      throw err;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // getStatistics()\n  //\n  // Method to obtain a JSON object with all statistical metrics and pool\n  // properties\n  //---------------------------------------------------------------------------\n  getStatistics() {\n    this._checkPoolOpen(false);\n    if (this._enableStatistics !== true) {\n      return null;\n    }\n    return new PoolStatistics(this);\n  }\n\n  //---------------------------------------------------------------------------\n  // homogeneous\n  //\n  // Property for the homogeneous flag value used to create the pool.\n  //---------------------------------------------------------------------------\n  get homogeneous() {\n    return this._homogeneous;\n  }\n\n  //---------------------------------------------------------------------------\n  // logStatistics()\n  //\n  // Method to print statistical related information and pool related\n  // information when enableStatistics is set to true.\n  //\n  // NOTE: This function replaces the DEPRECATED _logStats() function.\n  //---------------------------------------------------------------------------\n  logStatistics() {\n    const stats = this.getStatistics();\n    if (stats === null) {\n      errors.throwErr(errors.ERR_POOL_STATISTICS_DISABLED);\n    }\n    stats.logStatistics();\n  }\n\n  //---------------------------------------------------------------------------\n  // poolAlias\n  //\n  // Property for the alias assigned to the pool.\n  // ---------------------------------------------------------------------------\n  get poolAlias() {\n    return this._poolAlias;\n  }\n\n  //---------------------------------------------------------------------------\n  // poolIncrement\n  //\n  // Property for the number of connections to create each time the pool needs\n  // to grow.\n  // ---------------------------------------------------------------------------\n  get poolIncrement() {\n    return this._impl.getPoolIncrement();\n  }\n\n  //---------------------------------------------------------------------------\n  // poolMax\n  //\n  // Property for the maximum number of connections allowed in the pool.\n  //---------------------------------------------------------------------------\n  get poolMax() {\n    return this._impl.getPoolMax();\n  }\n\n  //---------------------------------------------------------------------------\n  // poolMaxPerShard\n  //\n  // Property for the maximum number of connections allowed in the pool for\n  // each shard.\n  //---------------------------------------------------------------------------\n  get poolMaxPerShard() {\n    return this._impl.getPoolMaxPerShard();\n  }\n\n  //---------------------------------------------------------------------------\n  // poolMin\n  //\n  // Property for the minimum number of connections allowed in the pool.\n  //---------------------------------------------------------------------------\n  get poolMin() {\n    return this._impl.getPoolMin();\n  }\n\n  //---------------------------------------------------------------------------\n  // poolPingInterval\n  //\n  // Property for the ping interval to use for the pool.\n  //---------------------------------------------------------------------------\n  get poolPingInterval() {\n    return this._impl.getPoolPingInterval();\n  }\n\n  //---------------------------------------------------------------------------\n  // poolTimeout\n  //\n  // Property for the timeout associated with the pool.\n  //---------------------------------------------------------------------------\n  get poolTimeout() {\n    return this._impl.getPoolTimeout();\n  }\n\n  //---------------------------------------------------------------------------\n  // queueMax\n  //\n  // Property for the maximum number of pending pool connections that can be\n  // queued.\n  //---------------------------------------------------------------------------\n  get queueMax() {\n    return this._queueMax;\n  }\n\n  //---------------------------------------------------------------------------\n  // queueTimeout\n  //\n  // Property for the milliseconds a connection request can spend in the queue\n  // before an exception is thrown.\n  //---------------------------------------------------------------------------\n  get queueTimeout() {\n    return this._queueTimeout;\n  }\n\n  //---------------------------------------------------------------------------\n  // reconfigure()\n  //\n  // Reconfigure the pool, change the value for given pool-properties.\n  //---------------------------------------------------------------------------\n  async reconfigure(options) {\n    // check arguments\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(nodbUtil.isObject(options));\n    errors.assertParamPropUnsignedInt(options, 1, \"queueMax\");\n    errors.assertParamPropUnsignedInt(options, 1, \"queueTimeout\");\n    errors.assertParamPropBool(options, 1, \"enableStatistics\");\n    errors.assertParamPropBool(options, 1, \"resetStatistics\");\n    errors.assertParamPropUnsignedInt(options, 1, \"poolMin\");\n    errors.assertParamPropUnsignedInt(options, 1, \"poolMax\");\n    errors.assertParamPropUnsignedInt(options, 1, \"poolMaxPerShard\");\n    errors.assertParamPropUnsignedInt(options, 1, \"poolIncrement\");\n    errors.assertParamPropInt(options, 1, \"poolPingInterval\");\n    errors.assertParamPropUnsignedInt(options, 1, \"poolTimeout\");\n    errors.assertParamPropUnsignedInt(options, 1, \"stmtCacheSize\");\n    errors.assertParamPropBool(options, 1, \"sodaMetaDataCache\");\n\n    // reconfiguration can happen only when status is OPEN\n    this._checkPoolOpen(false);\n    this._status = constants.POOL_STATUS_RECONFIGURING;\n    try {\n      // poolMin/poolMax/poolIncrement/poolPingInterval/poolTimeout/\n      // poolMaxPerShard/stmtCacheSize/sodaMetaDataCache parameters\n      await this._impl.reconfigure(options);\n\n      // pool JS parameters: queueMax, queueTimeout, enableStatistics,\n      // resetStatistics\n\n      // reset the statistics-metrics only if 'resetStatistics' is true or\n      // 'enableStatistics' is being set to true\n      if (options.resetStatistics == true || options.enableStatistics == true && this._enableStatistics == false) {\n        this._resetStatistics();\n      }\n      if (options.queueMax !== undefined) {\n        this._queueMax = options.queueMax;\n      }\n      if (options.queueTimeout !== undefined) {\n        this._queueTimeout = options.queueTimeout;\n      }\n      if (options.enableStatistics !== undefined) {\n        this._enableStatistics = options.enableStatistics;\n      }\n    } finally {\n      this._status = constants.POOL_STATUS_OPEN;\n    }\n    this.emit('_checkRequestQueue');\n  }\n\n  //---------------------------------------------------------------------------\n  // sessionCallback\n  //\n  // Property for the session callback associated with the pool.\n  //---------------------------------------------------------------------------\n  get sessionCallback() {\n    return this._sessionCallback;\n  }\n\n  //---------------------------------------------------------------------------\n  // setAccessToken()\n  //\n  // Set parameters for token based authentication.\n  //---------------------------------------------------------------------------\n  async setAccessToken(options) {\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(nodbUtil.isObject(options), 1);\n    errors.assertParamPropString(options, 1, \"token\");\n    errors.assertParamPropString(options, 1, \"privateKey\");\n    await this._impl.setAccessToken(options);\n  }\n\n  //---------------------------------------------------------------------------\n  // sodaMetaDataCache\n  //\n  // Property for whether the SODA metadata cache is enabled or not.\n  //---------------------------------------------------------------------------\n  get sodaMetaDataCache() {\n    return this._impl.getSodaMetaDataCache();\n  }\n\n  //---------------------------------------------------------------------------\n  // status\n  //\n  // Property for the pool's status.\n  //---------------------------------------------------------------------------\n  get status() {\n    return this._status;\n  }\n\n  //---------------------------------------------------------------------------\n  // stmtCacheSize\n  //\n  // Property for the size of the statement cache to use when creating\n  // connections in the pool.\n  //---------------------------------------------------------------------------\n  get stmtCacheSize() {\n    return this._impl.getStmtCacheSize();\n  }\n\n  //---------------------------------------------------------------------------\n  // user\n  //\n  // Property for the user used to create the pool.\n  //---------------------------------------------------------------------------\n  get user() {\n    return this._user;\n  }\n}\nPool.prototype.close = nodbUtil.callbackify(Pool.prototype.close);\nPool.prototype.getConnection = nodbUtil.callbackify(Pool.prototype.getConnection);\nPool.prototype.reconfigure = nodbUtil.callbackify(Pool.prototype.reconfigure);\nPool.prototype.setAccessToken = nodbUtil.callbackify(Pool.prototype.setAccessToken);\n\n// DEPRECATED aliases\nPool.prototype.terminate = Pool.prototype.close;\nPool.prototype._logStats = Pool.prototype.logStatistics;\nmodule.exports = Pool;","map":{"version":3,"names":["Connection","require","EventEmitter","constants","errors","settings","nodbUtil","impl","PoolStatistics","Pool","constructor","_impl","PoolImpl","_queueMax","_queueTimeout","_enableStatistics","_timeOfReset","_createdDate","Date","now","_sessionCallback","undefined","_connRequestQueue","_connectionClass","connectionClass","_checkPoolOpen","ignoreReconfiguring","status","POOL_STATUS_DRAINING","throwErr","ERR_POOL_CLOSING","POOL_STATUS_CLOSED","ERR_POOL_CLOSED","POOL_STATUS_RECONFIGURING","ERR_POOL_RECONFIGURING","_checkRequestQueue","connectionsOut","_connectionsOut","length","poolMax","payload","shift","_totalRequestsDequeued","_updateWaitStatistics","timeoutHandle","clearTimeout","resolve","_enableStats","_resetStatistics","_totalConnectionRequests","_totalRequestsEnqueued","_totalFailedRequests","_totalRequestsRejected","_totalRequestTimeouts","_maximumQueueLength","_totalTimeInQueue","_minTimeInQueue","_maxTimeInQueue","_setup","options","poolAlias","queueTimeout","queueMax","enableStatistics","_edition","edition","_eventsFlag","events","_externalAuth","externalAuth","_homogeneous","homogeneous","_user","user","_connectString","connectString","_status","POOL_STATUS_OPEN","_poolAlias","on","waitTime","enqueuedTime","Math","min","max","_verifyGetConnectionOptions","outOptions","assertParamPropValue","username","assert","ERR_DBL_USER","slice","ERR_WRONG_USER_FORMAT_EXTAUTH_PROXY","password","ERR_WRONG_CRED_FOR_EXTAUTH","tag","matchAnyTag","shardingKey","value","isShardingKey","superShardingKey","close","a1","drainTime","forceClose","assertArgCount","arguments","assertParamValue","isNaN","ERR_INVALID_PARAMETER_VALUE","Promise","timeout","setTimeout","removeAllListeners","once","ERR_POOL_HAS_BUSY_CONNECTIONS","emit","connectionsInUse","getConnectionsInUse","connectionsOpen","getConnectionsOpen","thin","getConnection","isObject","err","ERR_QUEUE_MAX_EXCEEDED","reject","ix","indexOf","splice","ERR_CONN_REQUEST_TIMEOUT","push","conn","_pool","requestedTag","sessionCallback","_newSession","drop","getStatistics","logStatistics","stats","ERR_POOL_STATISTICS_DISABLED","poolIncrement","getPoolIncrement","getPoolMax","poolMaxPerShard","getPoolMaxPerShard","poolMin","getPoolMin","poolPingInterval","getPoolPingInterval","poolTimeout","getPoolTimeout","reconfigure","assertParamPropUnsignedInt","assertParamPropBool","assertParamPropInt","resetStatistics","setAccessToken","assertParamPropString","sodaMetaDataCache","getSodaMetaDataCache","stmtCacheSize","getStmtCacheSize","prototype","callbackify","terminate","_logStats","module","exports"],"sources":["C:/Users/user1/Desktop/finalproject_penpick/node_modules/oracledb/lib/pool.js"],"sourcesContent":["// Copyright (c) 2016, 2022, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst Connection = require('./connection.js');\nconst EventEmitter = require('events');\nconst constants = require('./constants.js');\nconst errors = require('./errors.js');\nconst settings = require('./settings.js');\nconst nodbUtil = require('./util.js');\nconst impl = require('./impl');\nconst PoolStatistics = require('./poolStatistics.js');\n\n\nclass Pool extends EventEmitter {\n\n  constructor() {\n    super();\n    this._impl = new impl.PoolImpl();\n    this._queueMax = 0;\n    this._queueTimeout = 0;\n    this._enableStatistics = false;\n    this._timeOfReset = this._createdDate = Date.now();\n    this._sessionCallback = undefined;\n    this._connRequestQueue = [];\n    this._connectionClass = settings.connectionClass;\n  }\n\n  //---------------------------------------------------------------------------\n  // _checkPoolOpen()\n  //\n  // Check if the pool is open (not draining/reconfiguring/closed) and throw an\n  // appropriate exception if not.\n  //---------------------------------------------------------------------------\n  _checkPoolOpen(ignoreReconfiguring) {\n    if (this.status === constants.POOL_STATUS_DRAINING) {\n      errors.throwErr(errors.ERR_POOL_CLOSING);\n    } else if (this.status === constants.POOL_STATUS_CLOSED) {\n      errors.throwErr(errors.ERR_POOL_CLOSED);\n    } else if (!ignoreReconfiguring) {\n      if (this.status === constants.POOL_STATUS_RECONFIGURING) {\n        errors.throwErr(errors.ERR_POOL_RECONFIGURING);\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _checkRequestQueue()\n  //\n  // When a connection is returned to the pool, this method is called (via an\n  // event handler) to determine when requests for connections should be\n  // resumed and cancels any timeout that may have been associated with the\n  // request. This method is also called from reconfigure() so that waiting\n  // connection requests can be processed. Note the use of a local variable for\n  // the number of connections out. This is because the connection requests will\n  // not resume until after the loop is finished, and therefore the number of\n  // connections the pool thinks is out will not be incremented.\n  //---------------------------------------------------------------------------\n  _checkRequestQueue() {\n    let connectionsOut = this._connectionsOut;\n    while (this._connRequestQueue.length > 0 && connectionsOut < this.poolMax) {\n      connectionsOut += 1;\n      const payload = this._connRequestQueue.shift();\n      if (this._enableStatistics) {\n        this._totalRequestsDequeued += 1;\n        this._updateWaitStatistics(payload);\n      }\n      if (payload.timeoutHandle) {\n        clearTimeout(payload.timeoutHandle);\n      }\n      // inform the waiter that processing can continue\n      payload.resolve();\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _enableStats (DEPRECATED)\n  //\n  // Property for whether statistics are enabled on the pool.\n  //---------------------------------------------------------------------------\n  get _enableStats() {\n    return this._enableStatistics;\n  }\n\n  //---------------------------------------------------------------------------\n  // _resetStatistics()\n  //  To initialize the counters/timers\n  //---------------------------------------------------------------------------\n  _resetStatistics() {\n    this._timeOfReset = Date.now();\n    this._totalConnectionRequests = 0;\n    this._totalRequestsEnqueued = 0;\n    this._totalRequestsDequeued = 0;\n    this._totalFailedRequests = 0;\n    this._totalRequestsRejected = 0;\n    this._totalRequestTimeouts = 0;\n    this._maximumQueueLength = this._connRequestQueue.length;\n    this._totalTimeInQueue = 0;\n    this._minTimeInQueue = 0;\n    this._maxTimeInQueue = 0;\n  }\n\n  //---------------------------------------------------------------------------\n  // _setup()\n  //\n  // Sets up the pool instance with additional attributes used for logging\n  // statistics and managing the connection queue.\n  //---------------------------------------------------------------------------\n  _setup(options, poolAlias) {\n    this._queueTimeout = options.queueTimeout;\n    this._queueMax = options.queueMax;\n    this._enableStatistics = options.enableStatistics;\n    this._edition = options.edition;\n    this._eventsFlag = options.events;\n    this._externalAuth = options.externalAuth;\n    this._homogeneous = options.homogeneous;\n    this._user = options.user;\n    this._connectString = options.connectString;\n    this._status = constants.POOL_STATUS_OPEN;\n    this._connectionsOut = 0;\n    this._poolAlias = poolAlias;\n\n    // register event handler for when request queue should be checked\n    this.on('_checkRequestQueue', this._checkRequestQueue);\n\n    this._resetStatistics();\n\n  }\n\n  //---------------------------------------------------------------------------\n  // _updateWaitStatistics()\n  //\n  // Update pool wait statistics after a connect request has spent some time in\n  // the queue.\n  //---------------------------------------------------------------------------\n  _updateWaitStatistics(payload) {\n    const waitTime = Date.now() - payload.enqueuedTime;\n    this._totalTimeInQueue += waitTime;\n    if (this._minTimeInQueue === 0) {\n      this._minTimeInQueue = waitTime;\n    } else {\n      this._minTimeInQueue = Math.min(this._minTimeInQueue, waitTime);\n    }\n    this._maxTimeInQueue = Math.max(this._maxTimeInQueue, waitTime);\n  }\n\n  //---------------------------------------------------------------------------\n  // _verifyGetConnectionOptions()\n  //\n  // Verify the getConnection() options are acceptable. Performs any\n  // transformations that are needed before returning the options to the\n  // caller.\n  //---------------------------------------------------------------------------\n  _verifyGetConnectionOptions(options) {\n\n    // define normalized options (value returned to caller)\n    const outOptions = {};\n\n    // only one of \"user\" and \"username\" may be specified (and must be strings)\n    if (options.user !== undefined) {\n      errors.assertParamPropValue(typeof options.user === 'string', 1, \"user\");\n      outOptions.user = options.user;\n    }\n    if (options.username !== undefined) {\n      errors.assert(outOptions.user === undefined, errors.ERR_DBL_USER);\n      errors.assertParamPropValue(typeof options.username === 'string', 1,\n        \"username\");\n      outOptions.user = options.username;\n    }\n\n    if (this.externalAuth &&\n      outOptions.user && (outOptions.user[0] !== '['\n        || outOptions.user.slice(-1) !== ']')) {\n      // username is not enclosed in [].\n      errors.throwErr(errors.ERR_WRONG_USER_FORMAT_EXTAUTH_PROXY);\n    }\n\n    // password must be a string\n    if (options.password !== undefined) {\n      errors.assertParamPropValue(typeof options.password === 'string', 1,\n        \"password\");\n      if (this.externalAuth) {\n        errors.throwErr(errors.ERR_WRONG_CRED_FOR_EXTAUTH);\n      }\n      outOptions.password = options.password;\n    }\n\n    // tag must be a string\n    if (options.tag !== undefined) {\n      errors.assertParamPropValue(typeof options.tag === 'string', 1, \"tag\");\n      outOptions.tag = options.tag;\n    }\n\n    // matchAnyTag must be a boolean\n    if (options.matchAnyTag !== undefined) {\n      errors.assertParamPropValue(typeof options.matchAnyTag === 'boolean', 1,\n        \"matchAnyTag\");\n      outOptions.matchAnyTag = options.matchAnyTag;\n    }\n\n    // shardingKey must be an array of values\n    if (options.shardingKey !== undefined) {\n      const value = options.shardingKey;\n      errors.assertParamPropValue(nodbUtil.isShardingKey(value), 1,\n        \"shardingKey\");\n      outOptions.shardingKey = options.shardingKey;\n    }\n\n    // superShardingKey must be an array of values\n    if (options.superShardingKey !== undefined) {\n      const value = options.superShardingKey;\n      errors.assertParamPropValue(nodbUtil.isShardingKey(value), 1,\n        \"superShardingKey\");\n      outOptions.superShardingKey = options.superShardingKey;\n    }\n\n    return outOptions;\n  }\n\n  //---------------------------------------------------------------------------\n  // close()\n  //\n  // Close the pool, optionally allowing for a period of time to pass for\n  // connections to \"drain\" from the pool.\n  //---------------------------------------------------------------------------\n  async close(a1) {\n    let drainTime = 0;\n    let forceClose = false;\n\n    // check arguments\n    errors.assertArgCount(arguments, 0, 1);\n    if (arguments.length == 1) {\n\n      // drain time must be a valid number; timeouts larger than a 32-bit signed\n      // integer are not supported\n      errors.assertParamValue(typeof a1 === 'number', 1);\n      if (a1 < 0 || isNaN(a1) || a1 > 2 ** 31) {\n        errors.throwErr(errors.ERR_INVALID_PARAMETER_VALUE, 1);\n      }\n\n      // no need to worry about drain time if no connections are out!\n      forceClose = true;\n      if (this._connectionsOut > 0) {\n        drainTime = a1 * 1000;\n      }\n\n    }\n\n    // if the pool is draining/reconfiguring/closed, throw an appropriate error\n    this._checkPoolOpen(false);\n\n    // wait for the pool to become empty or for the drain timeout to expire\n    // (whichever comes first)\n    if (drainTime > 0) {\n      this._status = constants.POOL_STATUS_DRAINING;\n      await new Promise(resolve => {\n        const timeout = setTimeout(() => {\n          this.removeAllListeners('_allCheckedIn');\n          resolve();\n        }, drainTime);\n        this.once('_allCheckedIn', () => {\n          clearTimeout(timeout);\n          resolve();\n        });\n      });\n    }\n\n    // if any connections are still out and the pool is not being force closed,\n    // throw an exception\n    if (!forceClose && this._connectionsOut > 0) {\n      errors.throwErr(errors.ERR_POOL_HAS_BUSY_CONNECTIONS);\n    }\n\n    // close the pool\n    await this._impl.close();\n    this._status = constants.POOL_STATUS_CLOSED;\n    this.emit('_afterPoolClose');\n\n  }\n\n  //---------------------------------------------------------------------------\n  // connectionsInUse\n  //\n  // Property for the number of connections in use by the pool.\n  //---------------------------------------------------------------------------\n  get connectionsInUse() {\n    return this._impl.getConnectionsInUse();\n  }\n\n  //---------------------------------------------------------------------------\n  // connectionsOpen\n  //\n  // Property for the number of connections opened by the pool.\n  //---------------------------------------------------------------------------\n  get connectionsOpen() {\n    return this._impl.getConnectionsOpen();\n  }\n\n  //---------------------------------------------------------------------------\n  // connectString\n  //\n  // Property for the connect string used to create the pool.\n  //---------------------------------------------------------------------------\n  get connectString() {\n    return this._connectString;\n  }\n\n  //---------------------------------------------------------------------------\n  // thin()\n  //\n  // return true, if driver mode is thin while creating pool\n  // return false, if driver mode is thick while creating pool\n  //---------------------------------------------------------------------------\n  get thin() {\n    return settings.thin;\n  }\n\n  //---------------------------------------------------------------------------\n  // edition\n  //\n  // Property for the edition used to create the pool.\n  //---------------------------------------------------------------------------\n  get edition() {\n    return this._edition;\n  }\n\n  //---------------------------------------------------------------------------\n  // enableStatistics\n  //\n  // Property for whether statistics are enabled on the pool.\n  //---------------------------------------------------------------------------\n  get enableStatistics() {\n    return this._enableStatistics;\n  }\n\n  //---------------------------------------------------------------------------\n  // events\n  //\n  // Property for the events flag value used to create the pool.\n  //---------------------------------------------------------------------------\n  get events() {\n    return this._eventsFlag;\n  }\n\n  //---------------------------------------------------------------------------\n  // externalAuth\n  //\n  // Property for the externalAuth flag value used to create the pool.\n  //---------------------------------------------------------------------------\n  get externalAuth() {\n    return this._externalAuth;\n  }\n\n  //---------------------------------------------------------------------------\n  // getConnection()\n  //\n  // Gets a connection from the pool and returns it to the caller. If there are\n  // fewer connections out than the poolMax setting, then the request will\n  // return immediately; otherwise, the request will be queued for up to\n  // queueTimeout milliseconds.\n  //---------------------------------------------------------------------------\n  async getConnection(a1) {\n    let poolMax;\n    let options = {};\n\n    // check arguments\n    errors.assertArgCount(arguments, 0, 1);\n    if (arguments.length == 1) {\n      errors.assertParamValue(nodbUtil.isObject(a1), 1);\n      options = this._verifyGetConnectionOptions(a1);\n    }\n\n    // get connection class value from pool\n    options.connectionClass = this._connectionClass;\n\n    // if pool is draining/closed, throw an appropriate error\n    this._checkPoolOpen(true);\n\n    // manage stats, if applicable\n    if (this._enableStatistics) {\n      this._totalConnectionRequests += 1;\n    }\n\n    // getting the poolMax setting on the pool may fail if the pool is no\n    // longer valid\n    try {\n      poolMax = this.poolMax;\n    } catch (err) {\n      if (this._enableStatistics) {\n        this._totalFailedRequests += 1;\n      }\n      throw err;\n    }\n\n    if (this._connectionsOut >= poolMax ||\n        this.status === constants.POOL_STATUS_RECONFIGURING) {\n\n      // when the queue is huge, throw error early without waiting for queue\n      // timeout\n      if (this._connRequestQueue.length >= this._queueMax &&\n          this._queueMax >= 0) {\n        if (this._enableStatistics) {\n          this._totalRequestsRejected += 1;\n        }\n        errors.throwErr(errors.ERR_QUEUE_MAX_EXCEEDED, this._queueMax);\n      }\n\n      // if too many connections are out, wait until room is made available or\n      // the queue timeout expires\n      await new Promise((resolve, reject) => {\n\n        // set up a payload which will be added to the queue for processing\n        const payload = { resolve: resolve, reject: reject };\n\n        // if using a queue timeout, establish the timeout so that when it\n        // expires the payload will be removed from the queue and an exception\n        // thrown\n        if (this._queueTimeout !== 0) {\n          payload.timeoutHandle = setTimeout(() => {\n            const ix = this._connRequestQueue.indexOf(payload);\n            if (ix >= 0) {\n              this._connRequestQueue.splice(ix, 1);\n            }\n            if (this._enableStatistics) {\n              this._totalRequestTimeouts += 1;\n              this._updateWaitStatistics(payload);\n            }\n            try {\n              errors.throwErr(errors.ERR_CONN_REQUEST_TIMEOUT,\n                this._queueTimeout);\n            } catch (err) {\n              reject(err);\n            }\n          }, this._queueTimeout);\n        }\n\n        // add payload to the queue\n        this._connRequestQueue.push(payload);\n        if (this._enableStatistics) {\n          payload.enqueuedTime = Date.now();\n          this._totalRequestsEnqueued += 1;\n          this._maximumQueueLength = Math.max(this._maximumQueueLength,\n            this._connRequestQueue.length);\n        }\n\n      });\n\n      // check if pool is draining/closed after delay has\n      // completed and throw an appropriate error\n      this._checkPoolOpen(true);\n\n    }\n\n    // room is available in the queue, so proceed to acquire a connection from\n    // the pool; adjust the connections out immediately in order to ensure that\n    // another attempt doesn't proceed while this one is underway\n    this._connectionsOut += 1;\n    try {\n\n      // acquire connection from the pool\n      const conn = new Connection();\n      conn._impl = await this._impl.getConnection(options);\n      conn._pool = this;\n\n      // invoke tag fixup callback method if one has been specified and the\n      // actual tag on the connection doesn't match the one requested, or the\n      // connection is freshly created; if the callback fails, close the\n      // connection and remove it from the pool\n      const requestedTag = options.tag || \"\";\n      if (typeof this.sessionCallback === 'function' &&\n          (conn._impl._newSession || conn.tag != requestedTag)) {\n        try {\n          await new Promise((resolve, reject) => {\n            this.sessionCallback(conn, requestedTag, function(err) {\n              if (err) {\n                reject(err);\n              } else {\n                resolve();\n              }\n            });\n          });\n        } catch (err) {\n          await conn.close({ drop: true });\n          throw err;\n        }\n      }\n\n      // when connection is closed, check to see if another request should be\n      // processed and update any stats, as needed\n      conn.on('_afterConnClose', () => {\n        this._connectionsOut -= 1;\n        this.emit('_checkRequestQueue');\n        if (this._connectionsOut == 0) {\n          this.emit('_allCheckedIn');\n        }\n      });\n\n      return (conn);\n\n    } catch (err) {\n      this._connectionsOut -= 1;\n      if (this._enableStatistics) {\n        this._totalFailedRequests += 1;\n      }\n      this.emit('_checkRequestQueue');\n      throw err;\n    }\n\n  }\n\n  //---------------------------------------------------------------------------\n  // getStatistics()\n  //\n  // Method to obtain a JSON object with all statistical metrics and pool\n  // properties\n  //---------------------------------------------------------------------------\n  getStatistics() {\n    this._checkPoolOpen(false);\n\n    if (this._enableStatistics !== true) {\n      return null;\n    }\n    return new PoolStatistics(this);\n  }\n\n  //---------------------------------------------------------------------------\n  // homogeneous\n  //\n  // Property for the homogeneous flag value used to create the pool.\n  //---------------------------------------------------------------------------\n  get homogeneous() {\n    return this._homogeneous;\n  }\n\n  //---------------------------------------------------------------------------\n  // logStatistics()\n  //\n  // Method to print statistical related information and pool related\n  // information when enableStatistics is set to true.\n  //\n  // NOTE: This function replaces the DEPRECATED _logStats() function.\n  //---------------------------------------------------------------------------\n  logStatistics() {\n    const stats = this.getStatistics();\n    if (stats === null) {\n      errors.throwErr(errors.ERR_POOL_STATISTICS_DISABLED);\n    }\n    stats.logStatistics();\n  }\n\n  //---------------------------------------------------------------------------\n  // poolAlias\n  //\n  // Property for the alias assigned to the pool.\n  // ---------------------------------------------------------------------------\n  get poolAlias() {\n    return this._poolAlias;\n  }\n\n  //---------------------------------------------------------------------------\n  // poolIncrement\n  //\n  // Property for the number of connections to create each time the pool needs\n  // to grow.\n  // ---------------------------------------------------------------------------\n  get poolIncrement() {\n    return this._impl.getPoolIncrement();\n  }\n\n  //---------------------------------------------------------------------------\n  // poolMax\n  //\n  // Property for the maximum number of connections allowed in the pool.\n  //---------------------------------------------------------------------------\n  get poolMax() {\n    return this._impl.getPoolMax();\n  }\n\n  //---------------------------------------------------------------------------\n  // poolMaxPerShard\n  //\n  // Property for the maximum number of connections allowed in the pool for\n  // each shard.\n  //---------------------------------------------------------------------------\n  get poolMaxPerShard() {\n    return this._impl.getPoolMaxPerShard();\n  }\n\n  //---------------------------------------------------------------------------\n  // poolMin\n  //\n  // Property for the minimum number of connections allowed in the pool.\n  //---------------------------------------------------------------------------\n  get poolMin() {\n    return this._impl.getPoolMin();\n  }\n\n  //---------------------------------------------------------------------------\n  // poolPingInterval\n  //\n  // Property for the ping interval to use for the pool.\n  //---------------------------------------------------------------------------\n  get poolPingInterval() {\n    return this._impl.getPoolPingInterval();\n  }\n\n  //---------------------------------------------------------------------------\n  // poolTimeout\n  //\n  // Property for the timeout associated with the pool.\n  //---------------------------------------------------------------------------\n  get poolTimeout() {\n    return this._impl.getPoolTimeout();\n  }\n\n  //---------------------------------------------------------------------------\n  // queueMax\n  //\n  // Property for the maximum number of pending pool connections that can be\n  // queued.\n  //---------------------------------------------------------------------------\n  get queueMax() {\n    return this._queueMax;\n  }\n\n  //---------------------------------------------------------------------------\n  // queueTimeout\n  //\n  // Property for the milliseconds a connection request can spend in the queue\n  // before an exception is thrown.\n  //---------------------------------------------------------------------------\n  get queueTimeout() {\n    return this._queueTimeout;\n  }\n\n  //---------------------------------------------------------------------------\n  // reconfigure()\n  //\n  // Reconfigure the pool, change the value for given pool-properties.\n  //---------------------------------------------------------------------------\n  async reconfigure(options) {\n\n    // check arguments\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(nodbUtil.isObject(options));\n    errors.assertParamPropUnsignedInt(options, 1, \"queueMax\");\n    errors.assertParamPropUnsignedInt(options, 1, \"queueTimeout\");\n    errors.assertParamPropBool(options, 1, \"enableStatistics\");\n    errors.assertParamPropBool(options, 1, \"resetStatistics\");\n    errors.assertParamPropUnsignedInt(options, 1, \"poolMin\");\n    errors.assertParamPropUnsignedInt(options, 1, \"poolMax\");\n    errors.assertParamPropUnsignedInt(options, 1, \"poolMaxPerShard\");\n    errors.assertParamPropUnsignedInt(options, 1, \"poolIncrement\");\n    errors.assertParamPropInt(options, 1, \"poolPingInterval\");\n    errors.assertParamPropUnsignedInt(options, 1, \"poolTimeout\");\n    errors.assertParamPropUnsignedInt(options, 1, \"stmtCacheSize\");\n    errors.assertParamPropBool(options, 1, \"sodaMetaDataCache\");\n\n    // reconfiguration can happen only when status is OPEN\n    this._checkPoolOpen(false);\n\n    this._status = constants.POOL_STATUS_RECONFIGURING;\n    try {\n      // poolMin/poolMax/poolIncrement/poolPingInterval/poolTimeout/\n      // poolMaxPerShard/stmtCacheSize/sodaMetaDataCache parameters\n      await this._impl.reconfigure(options);\n\n      // pool JS parameters: queueMax, queueTimeout, enableStatistics,\n      // resetStatistics\n\n      // reset the statistics-metrics only if 'resetStatistics' is true or\n      // 'enableStatistics' is being set to true\n      if (options.resetStatistics == true ||\n          (options.enableStatistics == true &&\n          this._enableStatistics == false)) {\n        this._resetStatistics();\n      }\n\n      if (options.queueMax !== undefined) {\n        this._queueMax = options.queueMax;\n      }\n\n      if (options.queueTimeout !== undefined) {\n        this._queueTimeout = options.queueTimeout;\n      }\n\n      if (options.enableStatistics !== undefined) {\n        this._enableStatistics = options.enableStatistics;\n      }\n    } finally {\n      this._status = constants.POOL_STATUS_OPEN;\n    }\n    this.emit('_checkRequestQueue');\n  }\n\n  //---------------------------------------------------------------------------\n  // sessionCallback\n  //\n  // Property for the session callback associated with the pool.\n  //---------------------------------------------------------------------------\n  get sessionCallback() {\n    return this._sessionCallback;\n  }\n\n  //---------------------------------------------------------------------------\n  // setAccessToken()\n  //\n  // Set parameters for token based authentication.\n  //---------------------------------------------------------------------------\n  async setAccessToken(options) {\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(nodbUtil.isObject(options), 1);\n    errors.assertParamPropString(options, 1, \"token\");\n    errors.assertParamPropString(options, 1, \"privateKey\");\n    await this._impl.setAccessToken(options);\n  }\n\n  //---------------------------------------------------------------------------\n  // sodaMetaDataCache\n  //\n  // Property for whether the SODA metadata cache is enabled or not.\n  //---------------------------------------------------------------------------\n  get sodaMetaDataCache() {\n    return this._impl.getSodaMetaDataCache();\n  }\n\n  //---------------------------------------------------------------------------\n  // status\n  //\n  // Property for the pool's status.\n  //---------------------------------------------------------------------------\n  get status() {\n    return this._status;\n  }\n\n  //---------------------------------------------------------------------------\n  // stmtCacheSize\n  //\n  // Property for the size of the statement cache to use when creating\n  // connections in the pool.\n  //---------------------------------------------------------------------------\n  get stmtCacheSize() {\n    return this._impl.getStmtCacheSize();\n  }\n\n  //---------------------------------------------------------------------------\n  // user\n  //\n  // Property for the user used to create the pool.\n  //---------------------------------------------------------------------------\n  get user() {\n    return this._user;\n  }\n\n}\n\nPool.prototype.close = nodbUtil.callbackify(Pool.prototype.close);\nPool.prototype.getConnection = nodbUtil.callbackify(Pool.prototype.getConnection);\nPool.prototype.reconfigure = nodbUtil.callbackify(Pool.prototype.reconfigure);\nPool.prototype.setAccessToken = nodbUtil.callbackify(Pool.prototype.setAccessToken);\n\n// DEPRECATED aliases\nPool.prototype.terminate = Pool.prototype.close;\nPool.prototype._logStats = Pool.prototype.logStatistics;\n\nmodule.exports = Pool;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}