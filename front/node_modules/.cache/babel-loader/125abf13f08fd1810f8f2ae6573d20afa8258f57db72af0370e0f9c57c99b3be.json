{"ast":null,"code":"// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\nconst crypto = require('crypto');\nlet algorithm = 'aes-256-cbc';\nconst _appendBuffer = Buffer.from([0x00, 0x01]);\n\n/**\n * A single Instance which handles all Encrypt, Decrypt,\n * hash related to password verifiers.\n */\nclass EncryptDecrypt {\n  // Key length is dependent on the algorithm. In this case for aes192, it is\n  // 24 bytes (192 bits).\n  _decrypt(key, val) {\n    const iv = Buffer.alloc(16, 0); // Initialization vector, same is used in server\n    const decipher = crypto.createDecipheriv(algorithm, key, iv);\n    decipher.setAutoPadding(false);\n    let decrypted = decipher.update(val);\n    decrypted = Buffer.concat([decrypted, decipher.final()]);\n    return decrypted;\n  }\n  _encrypt(key, val, padding) {\n    const block_size = 16;\n    const iv = Buffer.alloc(block_size, 0);\n    const n = block_size - val.length % block_size;\n    const nv = Buffer.alloc(n, n);\n    if (n > 0) {\n      if (padding) {\n        val += Buffer.alloc(n);\n      } else {\n        val = Buffer.concat([val, nv]);\n      }\n    }\n    const cipher = crypto.createCipheriv(algorithm, key, iv);\n    let encrypted = cipher.update(val);\n    encrypted = Buffer.concat([encrypted, cipher.final()]);\n    if (!padding) {\n      encrypted = encrypted.slice(0, val.length);\n    }\n    val.fill(0);\n    return encrypted;\n  }\n\n  // Encrypt password and newPassword using comboKey\n  _setEncryptedPasswordBuffers(passwordBytes, newPasswordBytes, comboKey, authObj) {\n    const salt = Buffer.alloc(16);\n    crypto.randomFillSync(salt, 0, 16);\n    const temp = Buffer.concat([salt, passwordBytes]);\n    authObj.encodedPassword = this._encrypt(comboKey, temp);\n    temp.fill(0);\n    authObj.encodedPassword = authObj.encodedPassword.slice().toString('hex').toUpperCase();\n    if (newPasswordBytes) {\n      const newPasswordWithSalt = Buffer.concat([salt, newPasswordBytes]);\n      authObj.encodedNewPassword = this._encrypt(comboKey, newPasswordWithSalt);\n      newPasswordWithSalt.fill(0);\n      authObj.encodedNewPassword = authObj.encodedNewPassword.slice().toString('hex').toUpperCase();\n    }\n\n    // reset Buffers\n    passwordBytes.fill(0);\n    if (newPasswordBytes) {\n      newPasswordBytes.fill(0);\n    }\n  }\n\n  /**\n   * updates authObject with required data.\n   *\n   * @param {object} sessionData The key/value pairs returned from OSESS key rpc\n   * @param {string} password    Current Password of user\n   * @param {string} newPassword New password to be updated\n   * @param {boolean} verifier11G Verifier type 11g or not(12c)\n   */\n  updateVerifierData(sessionData, password, newPassword, verifier11G, authObj) {\n    let keyLen = 32;\n    let hashAlg = 'sha512';\n    const verifierData = Buffer.from(sessionData['AUTH_VFR_DATA'], 'hex');\n    const encodedServerKey = Buffer.from(sessionData['AUTH_SESSKEY'], 'hex');\n    let iterations = Number(sessionData['AUTH_PBKDF2_VGEN_COUNT']);\n    const passwordBytes = Buffer.from(password, 'utf8');\n    let passwordHash;\n    let passwordKey;\n    if (verifier11G) {\n      algorithm = 'aes-192-cbc';\n      keyLen = 24;\n      hashAlg = 'sha1';\n      const h = crypto.createHash(hashAlg);\n      h.update(passwordBytes);\n      h.update(verifierData);\n      const ph = h.digest();\n      passwordHash = Buffer.alloc(ph.length + 4);\n      ph.copy(passwordHash, 0, 0, ph.length);\n    } else {\n      algorithm = 'aes-256-cbc';\n      const temp = Buffer.from('AUTH_PBKDF2_SPEEDY_KEY', 'utf8');\n      const salt = Buffer.concat([verifierData, temp]);\n      passwordKey = crypto.pbkdf2Sync(passwordBytes, salt, iterations, 64, 'sha512');\n      const h = crypto.createHash(hashAlg);\n      h.update(passwordKey);\n      h.update(verifierData);\n      passwordHash = h.digest().slice(0, keyLen);\n    }\n    let newPasswordBytes;\n    if (newPassword) {\n      newPasswordBytes = Buffer.from(newPassword, 'utf8');\n    }\n    const sessionKeyParta = this._decrypt(passwordHash, encodedServerKey);\n    const sessionKeyPartb = Buffer.alloc(sessionKeyParta.length);\n    crypto.randomFillSync(sessionKeyPartb);\n    const encodedClientKey = this._encrypt(passwordHash, sessionKeyPartb);\n    if (sessionKeyParta.length === 48) {\n      authObj.sessionKey = encodedClientKey.slice().toString('hex').toUpperCase().slice(0, 96);\n      const buf = Buffer.alloc(24);\n      for (let i = 16; i <= 40; i++) {\n        buf[i - 16] = sessionKeyParta[i] ^ sessionKeyPartb[i];\n      }\n      const part1 = crypto.createHash(\"md5\").update(buf.subarray(0, 16)).digest();\n      const part2 = crypto.createHash(\"md5\").update(buf.subarray(16)).digest();\n      authObj.comboKey = Buffer.concat([part1, part2]).slice(0, keyLen);\n    } else {\n      authObj.sessionKey = encodedClientKey.slice().toString('hex').toUpperCase().slice(0, 64);\n      const mixingSalt = Buffer.from(sessionData['AUTH_PBKDF2_CSK_SALT'], 'hex');\n      iterations = Number(sessionData['AUTH_PBKDF2_SDER_COUNT']);\n      const partABKey = Buffer.concat([sessionKeyPartb.slice(0, keyLen), sessionKeyParta.slice(0, keyLen)]);\n      const partABKeyStr = partABKey.toString('hex').toUpperCase();\n      const partABKeyBuffer = Buffer.from(partABKeyStr, 'utf8');\n      authObj.comboKey = crypto.pbkdf2Sync(partABKeyBuffer, mixingSalt, iterations, keyLen, 'sha512');\n    }\n    const salt = Buffer.alloc(16);\n    if (!verifier11G) {\n      crypto.randomFillSync(salt, 0, 16);\n      const temp = Buffer.concat([salt, passwordKey]);\n      authObj.speedyKey = this._encrypt(authObj.comboKey, temp);\n      authObj.speedyKey = authObj.speedyKey.slice(0, 80).toString('hex').toUpperCase();\n    }\n    this._setEncryptedPasswordBuffers(passwordBytes, newPasswordBytes, authObj.comboKey, authObj);\n  }\n  getEncryptedJSWPData(sessionKey, jdwpData) {\n    let buf = this._encrypt(sessionKey, jdwpData, true);\n\n    // Add a \"01\" at the end of the hex encrypted data to indicate the\n    // use of AES encryption\n    buf = buf.slice().toString('hex').toUpperCase();\n    buf = Buffer.concat([buf, _appendBuffer]);\n    return buf;\n  }\n  updatePasswordsWithComboKey(password, newPassword, comboKey, authObj) {\n    const passwordBytes = Buffer.from(password, 'utf8');\n    let newPasswordBytes;\n    if (newPassword) {\n      newPasswordBytes = Buffer.from(newPassword, 'utf8');\n    }\n    this._setEncryptedPasswordBuffers(passwordBytes, newPasswordBytes, comboKey, authObj);\n  }\n}\nconst encryptDecryptInst = new EncryptDecrypt();\nmodule.exports = encryptDecryptInst;","map":{"version":3,"names":["Buffer","require","crypto","algorithm","_appendBuffer","from","EncryptDecrypt","_decrypt","key","val","iv","alloc","decipher","createDecipheriv","setAutoPadding","decrypted","update","concat","final","_encrypt","padding","block_size","n","length","nv","cipher","createCipheriv","encrypted","slice","fill","_setEncryptedPasswordBuffers","passwordBytes","newPasswordBytes","comboKey","authObj","salt","randomFillSync","temp","encodedPassword","toString","toUpperCase","newPasswordWithSalt","encodedNewPassword","updateVerifierData","sessionData","password","newPassword","verifier11G","keyLen","hashAlg","verifierData","encodedServerKey","iterations","Number","passwordHash","passwordKey","h","createHash","ph","digest","copy","pbkdf2Sync","sessionKeyParta","sessionKeyPartb","encodedClientKey","sessionKey","buf","i","part1","subarray","part2","mixingSalt","partABKey","partABKeyStr","partABKeyBuffer","speedyKey","getEncryptedJSWPData","jdwpData","updatePasswordsWithComboKey","encryptDecryptInst","module","exports"],"sources":["C:/Users/user1/Desktop/finalproject_penpick/node_modules/oracledb/lib/thin/protocol/encryptDecrypt.js"],"sourcesContent":["// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst { Buffer } = require('buffer');\nconst crypto = require('crypto');\n\nlet algorithm = 'aes-256-cbc';\nconst _appendBuffer = Buffer.from([0x00, 0x01]);\n\n/**\n * A single Instance which handles all Encrypt, Decrypt,\n * hash related to password verifiers.\n */\nclass EncryptDecrypt {\n\n  // Key length is dependent on the algorithm. In this case for aes192, it is\n  // 24 bytes (192 bits).\n  _decrypt(key, val) {\n    const iv = Buffer.alloc(16, 0); // Initialization vector, same is used in server\n    const decipher = crypto.createDecipheriv(algorithm, key, iv);\n    decipher.setAutoPadding(false);\n    let decrypted = decipher.update(val);\n    decrypted = Buffer.concat([decrypted, decipher.final()]);\n    return decrypted;\n  }\n\n  _encrypt(key, val, padding) {\n    const block_size = 16;\n    const iv = Buffer.alloc(block_size, 0);\n    const n = block_size - (val.length % block_size);\n    const nv = Buffer.alloc(n, n);\n    if (n > 0) {\n      if (padding) {\n        val += Buffer.alloc(n);\n      } else {\n        val = Buffer.concat([val, nv]);\n      }\n    }\n    const cipher = crypto.createCipheriv(algorithm, key, iv);\n    let encrypted = cipher.update(val);\n    encrypted = Buffer.concat([encrypted, cipher.final()]);\n    if (!padding) {\n      encrypted = encrypted.slice(0, val.length);\n    }\n    val.fill(0);\n    return encrypted;\n  }\n\n  // Encrypt password and newPassword using comboKey\n  _setEncryptedPasswordBuffers(passwordBytes, newPasswordBytes, comboKey, authObj) {\n    const salt = Buffer.alloc(16);\n    crypto.randomFillSync(salt, 0, 16);\n    const temp = Buffer.concat([salt, passwordBytes]);\n    authObj.encodedPassword = this._encrypt(comboKey, temp);\n    temp.fill(0);\n    authObj.encodedPassword = authObj.encodedPassword.slice().toString('hex').toUpperCase();\n\n    if (newPasswordBytes) {\n      const newPasswordWithSalt = Buffer.concat([salt, newPasswordBytes]);\n      authObj.encodedNewPassword = this._encrypt(comboKey, newPasswordWithSalt);\n      newPasswordWithSalt.fill(0);\n      authObj.encodedNewPassword = authObj.encodedNewPassword.slice().toString('hex').toUpperCase();\n    }\n\n    // reset Buffers\n    passwordBytes.fill(0);\n    if (newPasswordBytes) {\n      newPasswordBytes.fill(0);\n    }\n  }\n\n  /**\n   * updates authObject with required data.\n   *\n   * @param {object} sessionData The key/value pairs returned from OSESS key rpc\n   * @param {string} password    Current Password of user\n   * @param {string} newPassword New password to be updated\n   * @param {boolean} verifier11G Verifier type 11g or not(12c)\n   */\n  updateVerifierData(sessionData, password, newPassword, verifier11G, authObj) {\n    let keyLen = 32;\n    let hashAlg = 'sha512';\n\n    const verifierData = Buffer.from(sessionData['AUTH_VFR_DATA'], 'hex');\n    const encodedServerKey = Buffer.from(sessionData['AUTH_SESSKEY'], 'hex');\n    let iterations = Number(sessionData['AUTH_PBKDF2_VGEN_COUNT']);\n    const passwordBytes = Buffer.from(password, 'utf8');\n    let passwordHash;\n    let passwordKey;\n\n    if (verifier11G) {\n      algorithm = 'aes-192-cbc';\n      keyLen = 24;\n      hashAlg = 'sha1';\n      const h = crypto.createHash(hashAlg);\n      h.update(passwordBytes);\n      h.update(verifierData);\n      const ph = h.digest();\n      passwordHash = Buffer.alloc(ph.length + 4);\n      ph.copy(passwordHash, 0, 0, ph.length);\n    } else {\n      algorithm = 'aes-256-cbc';\n      const temp = Buffer.from('AUTH_PBKDF2_SPEEDY_KEY', 'utf8');\n      const salt = Buffer.concat([verifierData, temp]);\n      passwordKey = crypto.pbkdf2Sync(passwordBytes, salt, iterations, 64, 'sha512');\n      const h = crypto.createHash(hashAlg);\n      h.update(passwordKey);\n      h.update(verifierData);\n      passwordHash = h.digest().slice(0, keyLen);\n    }\n\n    let newPasswordBytes;\n    if (newPassword) {\n      newPasswordBytes = Buffer.from(newPassword, 'utf8');\n    }\n    const sessionKeyParta = this._decrypt(passwordHash, encodedServerKey);\n    const sessionKeyPartb = Buffer.alloc(sessionKeyParta.length);\n    crypto.randomFillSync(sessionKeyPartb);\n    const encodedClientKey = this._encrypt(passwordHash, sessionKeyPartb);\n\n    if (sessionKeyParta.length === 48) {\n      authObj.sessionKey = encodedClientKey.slice().toString('hex').toUpperCase().slice(0, 96);\n      const buf = Buffer.alloc(24);\n      for (let i = 16; i <= 40; i++) {\n        buf[i - 16] = sessionKeyParta[i] ^ sessionKeyPartb[i];\n      }\n      const part1 = crypto.createHash(\"md5\").update(buf.subarray(0, 16)).digest();\n      const part2 = crypto.createHash(\"md5\").update(buf.subarray(16)).digest();\n      authObj.comboKey = Buffer.concat([part1, part2]).slice(0, keyLen);\n    } else {\n      authObj.sessionKey = encodedClientKey.slice().toString('hex').toUpperCase().slice(0, 64);\n      const mixingSalt = Buffer.from(sessionData['AUTH_PBKDF2_CSK_SALT'], 'hex');\n      iterations = Number(sessionData['AUTH_PBKDF2_SDER_COUNT']);\n      const partABKey = Buffer.concat([sessionKeyPartb.slice(0, keyLen), sessionKeyParta.slice(0, keyLen)]);\n      const partABKeyStr = partABKey.toString('hex').toUpperCase();\n      const partABKeyBuffer = Buffer.from(partABKeyStr, 'utf8');\n      authObj.comboKey = crypto.pbkdf2Sync(partABKeyBuffer, mixingSalt,\n        iterations, keyLen, 'sha512');\n    }\n\n    const salt = Buffer.alloc(16);\n    if (!verifier11G) {\n      crypto.randomFillSync(salt, 0, 16);\n      const temp = Buffer.concat([salt, passwordKey]);\n      authObj.speedyKey = this._encrypt(authObj.comboKey, temp);\n      authObj.speedyKey = authObj.speedyKey.slice(0, 80).toString('hex').toUpperCase();\n    }\n    this._setEncryptedPasswordBuffers(passwordBytes, newPasswordBytes, authObj.comboKey, authObj);\n  }\n\n  getEncryptedJSWPData(sessionKey, jdwpData) {\n    let buf = this._encrypt(sessionKey, jdwpData, true);\n\n    // Add a \"01\" at the end of the hex encrypted data to indicate the\n    // use of AES encryption\n    buf = buf.slice().toString('hex').toUpperCase();\n    buf = Buffer.concat([buf, _appendBuffer]);\n    return buf;\n  }\n\n  updatePasswordsWithComboKey(password, newPassword, comboKey, authObj) {\n    const passwordBytes = Buffer.from(password, 'utf8');\n    let newPasswordBytes;\n    if (newPassword) {\n      newPasswordBytes = Buffer.from(newPassword, 'utf8');\n    }\n    this._setEncryptedPasswordBuffers(passwordBytes, newPasswordBytes, comboKey, authObj);\n  }\n}\n\nconst encryptDecryptInst = new EncryptDecrypt();\nmodule.exports = encryptDecryptInst;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}