{"ast":null,"code":"// Copyright (c) 2016, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst AqQueue = require('./aqQueue.js');\nconst BaseDbObject = require('./dbObject.js');\nconst {\n  Buffer\n} = require('buffer');\nconst Lob = require('./lob.js');\nconst ResultSet = require('./resultset.js');\nconst SodaDatabase = require('./sodaDatabase.js');\nconst EventEmitter = require('events');\nconst QueryStream = require('./queryStream.js');\nconst errors = require('./errors.js');\nconst nodbUtil = require('./util.js');\nconst impl = require('./impl');\nconst process = require('process');\nconst util = require('util');\nconst constants = require('./constants.js');\nconst settings = require('./settings.js');\nconst transformer = require('./transformer.js');\nconst types = require('./types.js');\n\n// global mapping of subscriptions; these cannot be tied to a particular\n// connection or pool since subscriptions can be created with one connection\n// and destroyed with another!\nconst _subscriptions = new Map();\n\n// define class\nclass Connection extends EventEmitter {\n  constructor() {\n    super();\n    this._dbObjectClasses = new Map();\n    this._closing = false;\n  }\n\n  //---------------------------------------------------------------------------\n  // _addDefaultsToExecOpts()\n  //\n  // Add values to the execute options from the global settings, if needed.\n  //---------------------------------------------------------------------------\n  _addDefaultsToExecOpts(options) {\n    options.connection = this;\n    if (options.keepInStmtCache === undefined) options.keepInStmtCache = true;\n    settings.addToOptions(options, \"autoCommit\", \"dbObjectAsPojo\", \"fetchArraySize\", \"fetchTypeHandler\", \"maxRows\", \"outFormat\", \"prefetchRows\");\n  }\n\n  //---------------------------------------------------------------------------\n  // _buildDbObjectClass()\n  //\n  // Builds and returns a database object class given the object type\n  // information supplied by the implementation.\n  //---------------------------------------------------------------------------\n  _buildDbObjectClass(objType) {\n    const DbObject = function (initialValue) {\n      this._impl = new impl.DbObjectImpl(objType);\n      if (this.isCollection) {\n        const proxy = new Proxy(this, BaseDbObject._collectionProxyHandler);\n        if (initialValue !== undefined) {\n          for (let i = 0; i < initialValue.length; i++) {\n            this.append(initialValue[i]);\n          }\n        }\n        return proxy;\n      } else if (initialValue !== undefined) {\n        Object.assign(this, initialValue);\n      }\n    };\n    DbObject.prototype = Object.create(BaseDbObject.prototype);\n    DbObject.prototype.constructor = DbObject;\n    DbObject.prototype._objType = objType;\n    if (objType.elementTypeClass) {\n      const cls = this._getDbObjectClass(objType.elementTypeClass);\n      objType.elementTypeClass = cls;\n    }\n    nodbUtil.addTypeProperties(objType, \"elementType\");\n    if (objType.attributes) {\n      const props = {};\n      for (const attr of objType.attributes) {\n        if (attr.typeClass) {\n          attr.typeClass = this._getDbObjectClass(attr.typeClass);\n        }\n        nodbUtil.addTypeProperties(attr, \"type\");\n        const prop = {\n          get() {\n            return this._getAttrValue(attr);\n          },\n          set(value) {\n            this._setAttrValue(attr, value);\n          }\n        };\n        props[attr.name] = prop;\n      }\n      Object.defineProperties(DbObject.prototype, props);\n    }\n    DbObject.toString = function () {\n      return 'DbObjectClass [' + objType.fqn + ']';\n    };\n    return DbObject;\n  }\n\n  //---------------------------------------------------------------------------\n  // _getDbObjectClass()\n  //\n  // Returns the database object class given the object type information\n  // supplied by the implementation. The cache is searched first to see if an\n  // object class has already been built.\n  //---------------------------------------------------------------------------\n  _getDbObjectClass(objType) {\n    if (objType.prototype instanceof BaseDbObject) return objType;\n    let cls = this._dbObjectClasses.get(objType);\n    if (!cls) {\n      cls = this._buildDbObjectClass(objType);\n      cls._connection = this;\n      cls._objType = objType;\n      objType._connection = this._impl;\n      this._dbObjectClasses.set(objType, cls);\n    }\n    return cls;\n  }\n\n  //---------------------------------------------------------------------------\n  // _getDbObjectClassForName()\n  //\n  // Returns the database object class given the name of the database object\n  // type. The cache is searched first to see if an object class has already\n  // been built.\n  //---------------------------------------------------------------------------\n  async _getDbObjectClassForName(name) {\n    let cls = this._dbObjectClasses.get(name);\n    if (!cls) {\n      const objType = await this._impl.getDbObjectClass(name);\n      cls = this._getDbObjectClass(objType);\n      this._dbObjectClasses.set(name, cls);\n    }\n    return cls;\n  }\n\n  //---------------------------------------------------------------------------\n  // _isBindDir()\n  //\n  // Returns a boolean indicating if the supplied value is a valid bind\n  // direction.\n  //---------------------------------------------------------------------------\n  _isBindDir(value) {\n    return value === constants.BIND_IN || value === constants.BIND_OUT || value === constants.BIND_INOUT;\n  }\n\n  //---------------------------------------------------------------------------\n  // _isBindValue()\n  //\n  // Returns a boolean indicating if the supplied value is one that can be\n  // bound.\n  //---------------------------------------------------------------------------\n  _isBindValue(value) {\n    return value === null || value === undefined || typeof value === 'number' || typeof value === 'string' || typeof value === 'boolean' || Array.isArray(value) || Buffer.isBuffer(value) || util.isDate(value) || value instanceof Lob || value instanceof ResultSet || value instanceof BaseDbObject;\n  }\n\n  //---------------------------------------------------------------------------\n  // _processBindUnit()\n  //\n  // Processes a bind unit (object) supplied by the user and returns the value\n  // stored in it (if one is).\n  //---------------------------------------------------------------------------\n  async _processBindUnit(bindInfo, bindUnit, inExecuteMany) {\n    let okBindUnit = false;\n\n    // get and validate bind direction; if not specified, IN is assumed\n    if (bindUnit.dir === undefined) {\n      bindInfo.dir = constants.BIND_IN;\n    } else {\n      errors.assert(this._isBindDir(bindUnit.dir), errors.ERR_INVALID_BIND_DIRECTION);\n      bindInfo.dir = bindUnit.dir;\n      okBindUnit = true;\n    }\n\n    // get and validate bind type; it must be one of the integer constants\n    // identifying types, a string identifying an object type or a constructor\n    // function identifying an object type\n    if (bindUnit.type !== undefined) {\n      if (typeof bindUnit.type === 'string') {\n        bindInfo.type = types.DB_TYPE_OBJECT;\n        bindInfo.typeClass = await this._getDbObjectClassForName(bindUnit.type);\n        bindInfo.objType = bindInfo.typeClass._objType;\n      } else if (bindUnit.type.prototype instanceof BaseDbObject) {\n        bindInfo.type = types.DB_TYPE_OBJECT;\n        bindInfo.typeClass = bindUnit.type;\n        bindInfo.objType = bindInfo.typeClass._objType;\n      } else {\n        errors.assert(bindUnit.type instanceof types.DbType, errors.ERR_INVALID_BIND_DATA_TYPE, 2);\n        bindInfo.type = bindUnit.type;\n      }\n      okBindUnit = true;\n\n      // when calling executeMany(), bind type is mandatory\n    } else if (inExecuteMany) {\n      if (bindInfo.name) errors.throwErr(errors.ERR_MISSING_TYPE_BY_NAME, bindInfo.name);\n      errors.throwErr(errors.ERR_MISSING_TYPE_BY_POS, bindInfo.pos);\n    }\n\n    // get and validate the maximum size for strings/buffers; this value is\n    // used for IN/OUT and OUT binds in execute() and at all times for\n    // executeMany()\n    if (bindInfo.dir !== constants.BIND_IN || inExecuteMany) {\n      if (bindUnit.maxSize !== undefined) {\n        errors.assertParamPropValue(Number.isInteger(bindUnit.maxSize) && bindUnit.maxSize > 0, 2, \"maxSize\");\n        bindInfo.maxSize = bindUnit.maxSize;\n        bindInfo.checkSize = true;\n        okBindUnit = true;\n      } else if (inExecuteMany) {\n        if (bindInfo.type === types.DB_TYPE_VARCHAR || bindInfo.type === types.DB_TYPE_RAW) {\n          if (bindInfo.name) errors.throwErr(errors.ERR_MISSING_MAX_SIZE_BY_NAME, bindInfo.name);\n          errors.throwErr(errors.ERR_MISSING_MAX_SIZE_BY_POS, bindInfo.pos);\n        }\n      } else {\n        bindInfo.maxSize = constants.DEFAULT_MAX_SIZE_FOR_OUT_BINDS;\n      }\n    }\n\n    // get max array size (for array binds, not possible in executeMany())\n    bindInfo.isArray = false;\n    if (!inExecuteMany) {\n      if (bindUnit.maxArraySize !== undefined) {\n        errors.assertParamPropValue(Number.isInteger(bindUnit.maxArraySize) && bindUnit.maxArraySize > 0, 2, \"maxArraySize\");\n        bindInfo.maxArraySize = bindUnit.maxArraySize;\n        bindInfo.isArray = true;\n      }\n    }\n\n    // get the value, if specified (not used in executeMany())\n    if (!inExecuteMany && bindUnit.val !== undefined) {\n      return bindUnit.val;\n    }\n    if (!okBindUnit) errors.throwErr(errors.ERR_INVALID_BIND_UNIT);\n  }\n\n  //---------------------------------------------------------------------------\n  // _processBindValue()\n  //\n  // Processes the bind value supplied by the caller. This performs all checks\n  // on the value and normalizes it for use by the implementation class. If no\n  // bind info has been defined yet, the value defines that.\n  //---------------------------------------------------------------------------\n  async _processBindValue(bindInfo, value, options) {\n    const transformed = transformer.transformValueIn(bindInfo, value, options);\n    if (bindInfo.isArray) {\n      bindInfo.values = transformed.concat(bindInfo.values.slice(transformed.length));\n    } else {\n      bindInfo.values[options.pos] = transformed;\n    }\n    if (bindInfo.type === types.DB_TYPE_OBJECT && bindInfo.typeClass === undefined) {\n      bindInfo.typeClass = await this._getDbObjectClass(value._objType);\n      bindInfo.objType = bindInfo.typeClass._objType;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _processExecuteBind()\n  //\n  // Processes a single execute bind supplied by the caller. This performs all\n  // checks on the bind and normalizes it for use by the implementation class.\n  //---------------------------------------------------------------------------\n  async _processExecuteBind(bindInfo, bindData) {\n    // setup defaults\n    bindInfo.isArray = false;\n\n    // if bind data is a value that can be bound directly, use it; otherwise,\n    // scan the bind unit for bind information and its value\n    let bindValue;\n    if (this._isBindValue(bindData)) {\n      bindInfo.dir = constants.BIND_IN;\n      bindValue = bindData;\n    } else {\n      bindValue = await this._processBindUnit(bindInfo, bindData, false);\n    }\n\n    // for IN and IN/OUT binds, process the value\n    if (bindInfo.dir !== constants.BIND_OUT) {\n      const options = {\n        pos: 0,\n        allowArray: true\n      };\n      await this._processBindValue(bindInfo, bindValue, options);\n    }\n\n    // if only null values were found (or an OUT bind was specified), type\n    // information may not be set, so complete bind information as a string\n    // and set the maxSize to 1 if it has not already been set\n    if (bindInfo.type === undefined) {\n      bindInfo.type = types.DB_TYPE_VARCHAR;\n      if (bindInfo.maxSize === undefined) bindInfo.maxSize = 1;\n    }\n\n    // check valid bind type for array binds\n    if (bindInfo.isArray && bindInfo.type !== types.DB_TYPE_VARCHAR && bindInfo.type !== types.DB_TYPE_NVARCHAR && bindInfo.type !== types.DB_TYPE_CHAR && bindInfo.type !== types.DB_TYPE_NCHAR && bindInfo.type !== types.DB_TYPE_NUMBER && bindInfo.type !== types.DB_TYPE_BINARY_FLOAT && bindInfo.type !== types.DB_TYPE_BINARY_DOUBLE && bindInfo.type !== types.DB_TYPE_DATE && bindInfo.type !== types.DB_TYPE_TIMESTAMP && bindInfo.type !== types.DB_TYPE_TIMESTAMP_LTZ && bindInfo.type !== types.DB_TYPE_TIMESTAMP_TZ && bindInfo.type !== types.DB_TYPE_RAW) {\n      errors.throwErr(errors.ERR_INVALID_TYPE_FOR_ARRAY_BIND);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _processExecuteBinds()\n  //\n  // Processes the binds supplied by the caller. This performs all checks on\n  // the binds and normalizes them for use by the implementation class.\n  //---------------------------------------------------------------------------\n  async _processExecuteBinds(binds) {\n    const normBinds = [];\n    if (Array.isArray(binds)) {\n      for (let i = 0; i < binds.length; i++) {\n        const bindInfo = normBinds[i] = {\n          pos: i + 1,\n          values: []\n        };\n        await this._processExecuteBind(bindInfo, binds[i]);\n      }\n    } else {\n      errors.assertParamValue(nodbUtil.isObject(binds), 2);\n      const bindNames = Object.getOwnPropertyNames(binds);\n      for (let i = 0; i < bindNames.length; i++) {\n        const bindInfo = normBinds[i] = {\n          name: bindNames[i],\n          values: []\n        };\n        await this._processExecuteBind(bindInfo, binds[bindNames[i]]);\n      }\n    }\n    return normBinds;\n  }\n\n  //---------------------------------------------------------------------------\n  // _processExecuteManyBinds()\n  //\n  // Processes the binds supplied by the caller. This performs all checks on\n  // the binds and normalizes them for use by the implementation class.\n  //---------------------------------------------------------------------------\n  async _processExecuteManyBinds(binds, bindDefs) {\n    const normBinds = [];\n    let byPosition;\n\n    // transform bindDefs into normalized binds, if available\n    if (bindDefs !== undefined) {\n      if (Array.isArray(bindDefs)) {\n        byPosition = true;\n        for (let i = 0; i < bindDefs.length; i++) {\n          const bindInfo = normBinds[i] = {\n            pos: i + 1,\n            values: []\n          };\n          await this._processBindUnit(bindInfo, bindDefs[i], true);\n        }\n      } else {\n        byPosition = false;\n        const bindNames = Object.getOwnPropertyNames(bindDefs);\n        for (let i = 0; i < bindNames.length; i++) {\n          const bindInfo = normBinds[i] = {\n            name: bindNames[i],\n            values: []\n          };\n          await this._processBindUnit(bindInfo, bindDefs[bindNames[i]], true);\n        }\n      }\n\n      // otherwise, use the first row to determine the binds to use\n    } else {\n      const row = binds[0];\n      errors.assertParamValue(nodbUtil.isObjectOrArray(row), 2);\n      if (Array.isArray(row)) {\n        byPosition = true;\n        for (let i = 0; i < row.length; i++) {\n          normBinds[i] = {\n            pos: i + 1\n          };\n        }\n      } else {\n        byPosition = false;\n        const bindNames = Object.getOwnPropertyNames(row);\n        for (let i = 0; i < bindNames.length; i++) {\n          normBinds[i] = {\n            name: bindNames[i]\n          };\n        }\n      }\n      for (let i = 0; i < normBinds.length; i++) {\n        normBinds[i].dir = constants.BIND_IN;\n        normBinds[i].isArray = false;\n        normBinds[i].values = [];\n      }\n    }\n\n    // process each of the rows\n    for (let i = 0; i < binds.length; i++) {\n      const row = binds[i];\n      const options = {\n        pos: i,\n        allowArray: false\n      };\n      errors.assert(byPosition && Array.isArray(row) || !byPosition && nodbUtil.isObject(row), errors.ERR_MIXED_BIND);\n      for (let j = 0; j < normBinds.length; j++) {\n        const bindInfo = normBinds[j];\n        const value = byPosition ? row[j] : row[bindInfo.name];\n        await this._processBindValue(bindInfo, value, options);\n      }\n    }\n\n    // set bind type and size to a string of size 1 if no bind type was\n    // specified (and all values are null)\n    for (let i = 0; i < normBinds.length; i++) {\n      const bindInfo = normBinds[i];\n      if (bindInfo.type === undefined) {\n        bindInfo.type = types.DB_TYPE_VARCHAR;\n        bindInfo.maxSize = 1;\n      }\n    }\n    return normBinds;\n  }\n\n  //---------------------------------------------------------------------------\n  // _transformOutBind()\n  //\n  // Transform an output bind value from an implementation value to a user\n  // facing value (for result sets and LOBs). DML returning output variables\n  // are always an array of values.\n  //---------------------------------------------------------------------------\n  _transformOutBind(val, options) {\n    let outVal = val;\n    if (Array.isArray(val)) {\n      outVal = [];\n      for (let i = 0; i < val.length; i++) outVal.push(this._transformOutBind(val[i], options));\n    } else if (val instanceof impl.ResultSetImpl) {\n      outVal = new ResultSet();\n      outVal._setup(this, val);\n    } else if (val instanceof impl.LobImpl) {\n      outVal = new Lob();\n      outVal._setup(val, true);\n    } else if (val instanceof impl.DbObjectImpl) {\n      const cls = this._dbObjectClasses.get(val._objType);\n      outVal = Object.create(cls.prototype);\n      outVal._impl = val;\n      if (options.dbObjectAsPojo) {\n        outVal = outVal._toPojo();\n      } else if (outVal.isCollection) {\n        outVal = new Proxy(outVal, BaseDbObject._collectionProxyHandler);\n      }\n    }\n    return outVal;\n  }\n\n  //---------------------------------------------------------------------------\n  // _verifyExecOpts\n  //\n  // Verify that the value passed by the user for binds is acceptable. Perform\n  // any transformations necessary.\n  //---------------------------------------------------------------------------\n  _verifyExecOpts(options, inExecuteMany) {\n    // define normalized options (value returned to caller)\n    const outOptions = {};\n\n    // handle common options\n    errors.assertParamValue(nodbUtil.isObject(options), 3);\n\n    // autoCommit must be a boolean value\n    if (options.autoCommit !== undefined) {\n      errors.assertParamPropValue(typeof options.autoCommit === 'boolean', 3, \"autoCommit\");\n      outOptions.autoCommit = options.autoCommit;\n    }\n\n    // dbObjectAsPojo must be a boolean value\n    if (options.dbObjectAsPojo !== undefined) {\n      errors.assertParamPropValue(typeof options.dbObjectAsPojo === 'boolean', 3, \"dbObjectAsPojo\");\n      outOptions.dbObjectAsPojo = options.dbObjectAsPojo;\n    }\n\n    // keepInStmtCache must be a boolean value\n    if (options.keepInStmtCache !== undefined) {\n      errors.assertParamPropValue(typeof options.keepInStmtCache === 'boolean', 3, \"keepInStmtCache\");\n      outOptions.keepInStmtCache = options.keepInStmtCache;\n    }\n\n    // handle options specific to executeMany()\n    if (inExecuteMany) {\n      // bindDefs must be an object or array\n      if (options.bindDefs !== undefined) {\n        errors.assertParamPropValue(nodbUtil.isObjectOrArray(options.bindDefs), 3, \"bindDefs\");\n        outOptions.bindDefs = options.bindDefs;\n      }\n\n      // batchErrors must be a boolean value\n      if (options.batchErrors !== undefined) {\n        errors.assertParamPropValue(typeof options.batchErrors === 'boolean', 3, \"batchErrors\");\n        outOptions.batchErrors = options.batchErrors;\n      }\n\n      // dmlRowCounts must be a boolean value\n      if (options.dmlRowCounts !== undefined) {\n        errors.assertParamPropValue(typeof options.dmlRowCounts === 'boolean', 3, \"dmlRowCounts\");\n        outOptions.dmlRowCounts = options.dmlRowCounts;\n      }\n\n      // handle options specific to execute()\n    } else {\n      // fetchArraySize must be a positive integer\n      if (options.fetchArraySize !== undefined) {\n        errors.assertParamPropValue(Number.isInteger(options.fetchArraySize) && options.fetchArraySize > 0, 3, \"fetchArraySize\");\n        outOptions.fetchArraySize = options.fetchArraySize;\n      }\n\n      // fetchInfo must be an object with keys containing an object with a\n      // \"type\" property; these are converted to an array of objects for ease\n      // of processing by the implementation\n      if (options.fetchInfo !== undefined) {\n        errors.assertParamPropValue(nodbUtil.isObject(options.fetchInfo), 3, \"fetchInfo\");\n        const names = Object.getOwnPropertyNames(options.fetchInfo);\n        const map = new Map(settings.fetchTypeMap);\n        for (const name of names) {\n          const info = options.fetchInfo[name];\n          if (info.type === undefined) errors.throwErr(errors.ERR_NO_TYPE_FOR_CONVERSION);\n          if (info.type !== constants.DEFAULT && info.type !== types.DB_TYPE_VARCHAR && info.type !== types.DB_TYPE_RAW) {\n            errors.throwErr(errors.ERR_INVALID_TYPE_FOR_CONVERSION);\n          }\n          map.set(name, info.type);\n        }\n        outOptions.fetchTypeMap = map;\n      }\n\n      // fetchTypeHandler must be a function which is called for each column to\n      // be fetched and accepts the metadata for a column\n      if (options.fetchTypeHandler !== undefined) {\n        const type = typeof options.fetchTypeHandler;\n        errors.assertParamPropValue(type === 'function', 3, \"fetchTypeHandler\");\n        outOptions.fetchTypeHandler = options.fetchTypeHandler;\n      }\n\n      // maxRows must be a positive integer (or 0)\n      if (options.maxRows !== undefined) {\n        errors.assertParamPropValue(Number.isInteger(options.maxRows) && options.maxRows >= 0, 3, \"maxRows\");\n        outOptions.maxRows = options.maxRows;\n      }\n\n      // outFormat must be one of the two possible constants\n      if (options.outFormat !== undefined) {\n        errors.assertParamPropValue(options.outFormat === constants.OUT_FORMAT_ARRAY || options.outFormat === constants.OUT_FORMAT_OBJECT, 3, \"outFormat\");\n        outOptions.outFormat = options.outFormat;\n      }\n\n      // prefetchRows must be a positive integer (or 0)\n      if (options.prefetchRows !== undefined) {\n        errors.assertParamPropValue(Number.isInteger(options.prefetchRows) && options.prefetchRows >= 0, 3, \"prefetchRows\");\n        outOptions.prefetchRows = options.prefetchRows;\n      }\n\n      // resultSet must be a boolean value\n      if (options.resultSet !== undefined) {\n        errors.assertParamPropValue(typeof options.resultSet === 'boolean', 3, \"resultSet\");\n        outOptions.resultSet = options.resultSet;\n      }\n    }\n    return outOptions;\n  }\n\n  //---------------------------------------------------------------------------\n  // action\n  //\n  // Property for end-to-end tracing attribute.\n  //---------------------------------------------------------------------------\n  get action() {\n    return null;\n  }\n  set action(value) {\n    errors.assertPropValue(typeof value === 'string', \"action\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setAction(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // breakExecution()\n  //\n  // Breaks execution of a running statement.\n  //---------------------------------------------------------------------------\n  async breakExecution() {\n    errors.assertArgCount(arguments, 0, 0);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.breakExecution();\n  }\n\n  //---------------------------------------------------------------------------\n  // callTimeout\n  //\n  // Property for round-trip timeouts.\n  //---------------------------------------------------------------------------\n  get callTimeout() {\n    if (this._impl) return this._impl.getCallTimeout();\n    return undefined;\n  }\n  set callTimeout(value) {\n    errors.assertPropValue(Number.isInteger(value) && value >= 0, \"callTimeout\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setCallTimeout(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // changePassword()\n  //\n  // Changes the password of the specified user.\n  //---------------------------------------------------------------------------\n  async changePassword(user, password, newPassword) {\n    errors.assertArgCount(arguments, 3, 3);\n    errors.assertParamValue(typeof user === 'string', 1);\n    errors.assertParamValue(typeof password === 'string', 2);\n    errors.assertParamValue(typeof newPassword === 'string', 3);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.changePassword(user, password, newPassword);\n  }\n\n  //---------------------------------------------------------------------------\n  // clientId\n  //\n  // Property for end-to-end tracing attribute.\n  //---------------------------------------------------------------------------\n  get clientId() {\n    return null;\n  }\n  set clientId(value) {\n    errors.assertPropValue(typeof value === 'string', \"clientId\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setClientId(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // clientInfo\n  //\n  // Property for end-to-end tracing attribute.\n  //---------------------------------------------------------------------------\n  get clientInfo() {\n    return null;\n  }\n  set clientInfo(value) {\n    errors.assertPropValue(typeof value === 'string', \"clientInfo\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setClientInfo(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // close()\n  //\n  // Closes the connection and makes it unusable for further work.\n  //---------------------------------------------------------------------------\n  async close(a1) {\n    let options = {};\n    errors.assertArgCount(arguments, 0, 1);\n    if (arguments.length == 1) {\n      errors.assertParamValue(nodbUtil.isObject(a1), 1);\n      options = a1;\n      errors.assertParamPropBool(options, 1, \"drop\");\n    }\n    errors.assert(this._impl && !this._closing, errors.ERR_INVALID_CONNECTION);\n    this._closing = true;\n    try {\n      await this._impl.close(options);\n    } finally {\n      this._closing = false;\n    }\n    delete this._impl;\n    this._dbObjectClasses.clear();\n    this.emit('_afterConnClose');\n  }\n\n  //---------------------------------------------------------------------------\n  // commit()\n  //\n  // Commits the current transaction.\n  //---------------------------------------------------------------------------\n  async commit() {\n    errors.assertArgCount(arguments, 0, 0);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.commit();\n  }\n\n  //---------------------------------------------------------------------------\n  // createLob()\n  //\n  // Creates a temporary LOB and returns it to the caller.\n  //---------------------------------------------------------------------------\n  async createLob(type) {\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(type === types.DB_TYPE_CLOB || type === types.DB_TYPE_BLOB || type === types.DB_TYPE_NCLOB, 1);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    const lob = new Lob();\n    lob._setup(await this._impl.createLob(type), false);\n    return lob;\n  }\n\n  //---------------------------------------------------------------------------\n  // currentSchema\n  //\n  // Property for identifying the current schema to use in the database.\n  //---------------------------------------------------------------------------\n  get currentSchema() {\n    if (this._impl) return this._impl.getCurrentSchema();\n    return undefined;\n  }\n  set currentSchema(value) {\n    errors.assertPropValue(typeof value === 'string', \"currentSchema\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setCurrentSchema(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // dbOp\n  //\n  // Property for end-to-end tracing attribute.\n  //---------------------------------------------------------------------------\n  get dbOp() {\n    return null;\n  }\n  set dbOp(value) {\n    errors.assertPropValue(typeof value === 'string', \"dbOp\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setDbOp(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // thin()\n  //\n  // return true, if driver mode is thin while acquiring connection\n  // return false, if driver mode is thick while acquiring connection\n  //---------------------------------------------------------------------------\n  get thin() {\n    return settings.thin;\n  }\n\n  //---------------------------------------------------------------------------\n  // ecid\n  //\n  // Property for end-to-end tracing attribute.\n  //---------------------------------------------------------------------------\n  get ecid() {\n    return null;\n  }\n  set ecid(value) {\n    errors.assertPropValue(typeof value === 'string', \"ecid\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setECID(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // execute()\n  //\n  // Executes a SQL statement and returns the results.\n  //---------------------------------------------------------------------------\n  async execute(sql, a2, a3) {\n    const numIters = 1;\n    let binds = [];\n    let options = {};\n\n    // process arguments\n    errors.assertArgCount(arguments, 1, 3);\n    errors.assertParamValue(typeof sql === 'string', 1);\n    if (arguments.length >= 2) {\n      binds = await this._processExecuteBinds(a2);\n    }\n    if (arguments.length == 3) {\n      options = this._verifyExecOpts(a3, false);\n    }\n    this._addDefaultsToExecOpts(options);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n\n    // perform actual execute\n    let result;\n    try {\n      result = await this._impl.execute(sql, numIters, binds, options, false);\n    } catch (err) {\n      if (err.errorNum === 1406) errors.throwErr(errors.ERR_INSUFFICIENT_BUFFER_FOR_BINDS);\n      throw err;\n    }\n\n    // convert ORA errors to NJS\n    if (result.warning) {\n      result.warning = errors.transformErr(result.warning);\n    }\n\n    // process queries; if a result set is not desired, fetch all of the rows\n    // from the result set and then destroy the result set\n    if (result.resultSet !== undefined) {\n      const resultSet = new ResultSet();\n      resultSet._setup(this, result.resultSet);\n      result.metaData = resultSet._impl.metaData;\n      if (options.resultSet) {\n        result.resultSet = resultSet;\n      } else {\n        result.rows = await resultSet._getAllRows();\n        delete result.resultSet;\n      }\n    }\n\n    // process output binds\n    if (result.outBinds !== undefined) {\n      for (const key in result.outBinds) {\n        const val = this._transformOutBind(result.outBinds[key], options);\n        result.outBinds[key] = val;\n      }\n    }\n\n    // process implicit results; ensure all implicit results have their fetch\n    // array size fixed, or, if a result set is not requested, that all rows\n    // are fetched\n    if (result.implicitResults) {\n      for (const key in result.implicitResults) {\n        const resultSetImpl = result.implicitResults[key];\n        const resultSet = new ResultSet();\n        resultSet._setup(this, resultSetImpl);\n        if (options.resultSet) {\n          result.implicitResults[key] = resultSet;\n        } else {\n          result.implicitResults[key] = await resultSet._getAllRows();\n        }\n      }\n    }\n    return result;\n  }\n\n  //---------------------------------------------------------------------------\n  // executeMany()\n  //\n  // Executes a SQL statement multiple times and returns the results.\n  //---------------------------------------------------------------------------\n  async executeMany(sql, bindsOrNumIters, a3) {\n    let options = {};\n    let binds = [];\n    let numIters;\n    errors.assertArgCount(arguments, 2, 3);\n    errors.assertParamValue(typeof sql === 'string', 1);\n    if (arguments.length == 3) {\n      options = this._verifyExecOpts(a3, true);\n    }\n    this._addDefaultsToExecOpts(options);\n    if (typeof bindsOrNumIters === 'number') {\n      errors.assertParamValue(Number.isInteger(bindsOrNumIters) && bindsOrNumIters > 0, 2);\n      numIters = bindsOrNumIters;\n      if (options.bindDefs !== undefined) {\n        binds = await this._processExecuteManyBinds([], options.bindDefs);\n      }\n    } else {\n      errors.assertParamValue(Array.isArray(bindsOrNumIters) && bindsOrNumIters.length > 0, 2);\n      numIters = bindsOrNumIters.length;\n      binds = await this._processExecuteManyBinds(bindsOrNumIters, options.bindDefs);\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    const result = await this._impl.execute(sql, numIters, binds, options, true);\n\n    // process output binds\n    if (result.outBinds !== undefined) {\n      for (let i = 0; i < result.outBinds.length; i++) {\n        const outBind = result.outBinds[i];\n        for (const key in outBind) {\n          outBind[key] = this._transformOutBind(outBind[key], options);\n        }\n      }\n    }\n    return result;\n  }\n\n  //---------------------------------------------------------------------------\n  // externalName\n  //\n  // Property for identifying the external name to use in TPC logging.\n  //---------------------------------------------------------------------------\n  get externalName() {\n    if (this._impl) return this._impl.getExternalName();\n    return undefined;\n  }\n  set externalName(value) {\n    errors.assertPropValue(typeof value === 'string', \"externalName\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setExternalName(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // dbDomain (READONLY)\n  //\n  // Property for identifying the dbDomain of the Oracle Database.\n  //---------------------------------------------------------------------------\n  get dbDomain() {\n    return this._impl && this._impl.getDbDomain();\n  }\n\n  //---------------------------------------------------------------------------\n  // dbName (READONLY)\n  //\n  // Property for identifying the dbName of the Oracle Database.\n  //---------------------------------------------------------------------------\n  get dbName() {\n    return this._impl && this._impl.getDbName();\n  }\n\n  //---------------------------------------------------------------------------\n  // getDbObjectClass()\n  //\n  // Returns a database object class given its name. The cache is searched\n  // first, but if not found, the database is queried and the result is cached\n  // using the type information (as well as the name for easier lookup later).\n  //---------------------------------------------------------------------------\n  async getDbObjectClass(name) {\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(typeof name === 'string', 1);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    return await this._getDbObjectClassForName(name);\n  }\n\n  //---------------------------------------------------------------------------\n  // getQueue()\n  //\n  // Returns a queue with the specified name.\n  //---------------------------------------------------------------------------\n  async getQueue(name, a2) {\n    let options = {};\n    errors.assertArgCount(arguments, 1, 2);\n    errors.assertParamValue(typeof name === 'string', 1);\n    if (arguments.length == 2) {\n      errors.assertParamValue(nodbUtil.isObject(a2), 2);\n      options = {\n        ...a2\n      };\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    const queue = new AqQueue();\n    await queue.create(this, name, options);\n    return queue;\n  }\n\n  //---------------------------------------------------------------------------\n  // getSodaDatabase()\n  //\n  // Returns a SodaDatabase object (high-level SODA object associated with\n  // the current connection).\n  //---------------------------------------------------------------------------\n  getSodaDatabase() {\n    errors.assertArgCount(arguments, 0, 0);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    const sodaDb = new SodaDatabase();\n    sodaDb._impl = this._impl.getSodaDatabase();\n    return sodaDb;\n  }\n\n  //---------------------------------------------------------------------------\n  // getStatementInfo()\n  //\n  // Returns information about the statement.\n  //---------------------------------------------------------------------------\n  async getStatementInfo(sql) {\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(typeof sql === 'string', 1);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    const info = await this._impl.getStatementInfo(sql);\n    if (info.metaData) {\n      for (let i = 0; i < info.metaData.length; i++) {\n        const m = info.metaData[i];\n        nodbUtil.addTypeProperties(m, \"dbType\");\n        m.fetchType = types.DB_TYPE_FETCH_TYPE_MAP.get(m.dbType);\n      }\n    }\n    return info;\n  }\n\n  //---------------------------------------------------------------------------\n  // instanceName\n  //\n  // Returns the Oracle Database instance name associated with the connection.\n  // This is the equivalent of the SQL expression:\n  // sys_context('userenv', 'instance_name')\n  //---------------------------------------------------------------------------\n  get instanceName() {\n    if (this._impl) return this._impl.getInstanceName();\n    return undefined;\n  }\n\n  //---------------------------------------------------------------------------\n  // internalName\n  //\n  // Property for identifying the internal name to use in TPC logging.\n  //---------------------------------------------------------------------------\n  get internalName() {\n    if (this._impl) return this._impl.getInternalName();\n    return undefined;\n  }\n  set internalName(value) {\n    errors.assertPropValue(typeof value === 'string', \"internalName\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setInternalName(value);\n  }\n\n  //--------------------------------------------------------------------------\n  // isHealthy()\n  //\n  // Returns the health status of the connection. If this function returns\n  // false, the caller should close the connection.\n  //---------------------------------------------------------------------------\n  isHealthy() {\n    return this._impl !== undefined && !this._closing && this._impl.isHealthy();\n  }\n\n  //---------------------------------------------------------------------------\n  // maxOpenCursors\n  //\n  // Returns maximum number of cursors that can be opened in one session.\n  //---------------------------------------------------------------------------\n  get maxOpenCursors() {\n    return this._impl && this._impl.getMaxOpenCursors();\n  }\n\n  //---------------------------------------------------------------------------\n  // warning\n  //\n  // Returns warningInfo.\n  //---------------------------------------------------------------------------\n  get warning() {\n    let warning = this._impl.getWarning();\n    if (warning) {\n      // Make sure that warning code attribute is populated and ORA error\n      // is converted to NJS, if required\n      warning = errors.transformErr(warning);\n    }\n    return this._impl && warning;\n  }\n\n  //---------------------------------------------------------------------------\n  // module\n  //\n  // Property for end-to-end tracing attribute.\n  //---------------------------------------------------------------------------\n  get module() {\n    return null;\n  }\n  set module(value) {\n    errors.assertPropValue(typeof value === 'string', \"module\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setModule(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // oracleServerVersion\n  //\n  // Returns an integer identifying the Oracle Server version.\n  //---------------------------------------------------------------------------\n  get oracleServerVersion() {\n    if (this._impl) return this._impl.getOracleServerVersion();\n    return undefined;\n  }\n\n  //---------------------------------------------------------------------------\n  // oracleServerVersionString\n  //\n  // Returns a string identifying the Oracle Server version.\n  //---------------------------------------------------------------------------\n  get oracleServerVersionString() {\n    if (this._impl) return this._impl.getOracleServerVersionString();\n    return undefined;\n  }\n\n  //---------------------------------------------------------------------------\n  // serviceName\n  //\n  // Returns the Oracle Database service name associated with the connection.\n  //---------------------------------------------------------------------------\n  get serviceName() {\n    return this._impl && this._impl.getServiceName();\n  }\n\n  //---------------------------------------------------------------------------\n  // transactionInProgress\n  //\n  // Returns a boolean value based on the presence of an active transaction\n  // on the connection\n  //---------------------------------------------------------------------------\n  get transactionInProgress() {\n    return this._impl && this._impl.getTransactionInProgress();\n  }\n\n  //---------------------------------------------------------------------------\n  // ping()\n  //\n  // Sends a \"ping\" to the database to see if it is \"alive\".\n  //---------------------------------------------------------------------------\n  async ping() {\n    errors.assertArgCount(arguments, 0, 0);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.ping();\n  }\n\n  //--------------------------------------------------------------------------\n  // queryStream()\n  //\n  // Similar to execute() except that it immediately returns a QueryStream\n  // object.\n  // ---------------------------------------------------------------------------\n  queryStream(sql, binds, options) {\n    errors.assertArgCount(arguments, 1, 3);\n    errors.assertParamValue(typeof sql === 'string', 1);\n    if (arguments.length == 3) {\n      errors.assertParamValue(nodbUtil.isObject(options), 3);\n      options = {\n        ...options\n      };\n    } else {\n      options = {};\n    }\n    options.resultSet = true;\n    const stream = new QueryStream();\n\n    // calling execute() via nextTick to ensure that handlers are registered\n    // prior to the events being emitted\n    process.nextTick(async () => {\n      try {\n        const result = await this.execute(sql, binds || [], options);\n        if (!result.resultSet) errors.throwErr(errors.ERR_NOT_A_QUERY);\n        stream._open(result.resultSet);\n      } catch (err) {\n        stream.destroy(err);\n        return;\n      }\n    });\n    return stream;\n  }\n\n  //---------------------------------------------------------------------------\n  // rollback()\n  //\n  // Rolls back the current transaction.\n  //---------------------------------------------------------------------------\n  async rollback() {\n    errors.assertArgCount(arguments, 0, 0);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.rollback();\n  }\n\n  //---------------------------------------------------------------------------\n  // shutdown()\n  //   Shuts down the database instance.\n  //---------------------------------------------------------------------------\n  async shutdown(a1) {\n    let mode = constants.SHUTDOWN_MODE_DEFAULT;\n    errors.assertArgCount(arguments, 0, 1);\n    if (a1 !== undefined) {\n      errors.assertParamValue(typeof mode === 'number', 1);\n      mode = a1;\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.shutdown(mode);\n  }\n\n  //---------------------------------------------------------------------------\n  // startup()\n  //   Starts up the database instance.\n  //---------------------------------------------------------------------------\n  async startup(a1) {\n    let options = {};\n    errors.assertArgCount(arguments, 0, 1);\n    if (arguments.length == 1) {\n      errors.assertParamValue(typeof options === 'object', 1);\n      options = a1;\n      errors.assertParamPropBool(options, 1, \"force\");\n      errors.assertParamPropBool(options, 1, \"restrict\");\n      errors.assertParamPropString(options, 1, \"pfile\");\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.startup(options);\n  }\n\n  //---------------------------------------------------------------------------\n  // stmtCacheSize\n  //\n  // Property for statement cache size.\n  //---------------------------------------------------------------------------\n  get stmtCacheSize() {\n    if (this._impl) return this._impl.getStmtCacheSize();\n    return undefined;\n  }\n  set stmtCacheSize(value) {\n    errors.assertPropValue(Number.isInteger(value) && value >= 0, \"stmtCacheSize\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setStmtCacheSize(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // subscribe()\n  //\n  // Creates a subscription which can be used to get notifications of database\n  // changes or of AQ messages available to dequeue.\n  //---------------------------------------------------------------------------\n  async subscribe(name, options) {\n    errors.assertArgCount(arguments, 2, 2);\n    errors.assertParamValue(typeof name === 'string', 1);\n    errors.assertParamValue(nodbUtil.isObject(options), 2);\n    options = {\n      name: name,\n      ...options\n    };\n    errors.assertParamPropUnsignedInt(options, 2, \"namespace\");\n    if (options.namespace === undefined) options.namespace = constants.SUBSCR_NAMESPACE_DBCHANGE;\n    errors.assertParamPropString(options, 2, \"ipAddress\");\n    errors.assertParamPropUnsignedInt(options, 2, \"port\");\n    errors.assertParamPropUnsignedInt(options, 2, \"timeout\");\n    errors.assertParamPropUnsignedInt(options, 2, \"operations\");\n    errors.assertParamPropUnsignedInt(options, 2, \"qos\");\n    errors.assertParamPropUnsignedInt(options, 2, \"groupingClass\");\n    errors.assertParamPropUnsignedInt(options, 2, \"groupingValue\");\n    errors.assertParamPropUnsignedInt(options, 2, \"groupingType\");\n    errors.assertParamPropBool(options, 2, \"clientInitiated\");\n    errors.assertParamPropFunction(options, 2, \"callback\");\n    errors.assert(options.callback, errors.ERR_MISSING_SUBSCR_CALLBACK);\n    if (options.namespace === constants.SUBSCR_NAMESPACE_DBCHANGE) {\n      errors.assertParamPropString(options, 2, \"sql\");\n      errors.assert(options.sql && options.sql.length > 0, errors.ERR_MISSING_SUBSCR_SQL);\n      if (options.binds !== undefined) {\n        options.binds = await this._processExecuteBinds(options.binds);\n      }\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    const inSubscr = _subscriptions.get(name);\n    const outValue = await this._impl.subscribe(inSubscr, options);\n    let subscription;\n    if (options.namespace === constants.SUBSCR_NAMESPACE_DBCHANGE) {\n      subscription = outValue.subscription;\n      delete outValue.subscription;\n    } else {\n      subscription = outValue;\n    }\n    _subscriptions.set(name, subscription);\n    return outValue;\n  }\n\n  //---------------------------------------------------------------------------\n  // tag\n  //\n  // Property for tag to associate with the connection.\n  //---------------------------------------------------------------------------\n  get tag() {\n    if (this._impl) return this._impl.getTag();\n    return undefined;\n  }\n  set tag(value) {\n    errors.assertPropValue(typeof value === 'string', \"tag\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setTag(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcBegin()\n  //\n  // Starts a two-phase-commit transaction.\n  //--------------------------------------------------------------------------\n  async tpcBegin(xid, flag, timeout) {\n    errors.assertArgCount(arguments, 1, 3);\n    errors.assertParamValue(nodbUtil.isXid(xid), 1);\n    if (arguments.length < 3) {\n      timeout = 60; // seconds\n    } else {\n      errors.assertParamValue(typeof timeout === 'number', 3);\n    }\n    if (arguments.length < 2) {\n      flag = constants.TPC_BEGIN_NEW;\n    } else {\n      errors.assertParamValue(typeof flag === 'number', 2);\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.tpcBegin(xid, flag, timeout);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcCommit()\n  //\n  // Commits a two-phase-commit transaction.\n  //---------------------------------------------------------------------------\n  async tpcCommit(xid, onePhase) {\n    errors.assertArgCount(arguments, 0, 2);\n    if (arguments.length < 2) {\n      onePhase = false;\n    } else {\n      errors.assertParamValue(typeof onePhase === 'boolean', 2);\n    }\n    if (arguments.length >= 1) {\n      errors.assertParamValue(nodbUtil.isXid(xid), 1);\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.tpcCommit(xid, onePhase);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcEnd()\n  //\n  // Ends a two-phase-commit transaction.\n  //---------------------------------------------------------------------------\n  async tpcEnd(xid, flag) {\n    errors.assertArgCount(arguments, 0, 2);\n    if (arguments.length < 2) {\n      flag = constants.TPC_END_NORMAL;\n    } else {\n      errors.assertParamValue(typeof flag === 'number', 2);\n    }\n    if (arguments.length >= 1) {\n      errors.assertParamValue(nodbUtil.isXid(xid), 1);\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.tpcEnd(xid, flag);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcForget()\n  //\n  // Causes the server to forget a heuristically completed two-phase-commit\n  // transaction.\n  // ---------------------------------------------------------------------------\n  async tpcForget(xid) {\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(nodbUtil.isXid(xid), 1);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.tpcForget(xid);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcPrepare()\n  //\n  // Prepares a two-phase-commit transaction for commit.\n  //---------------------------------------------------------------------------\n  async tpcPrepare(xid) {\n    errors.assertArgCount(arguments, 0, 1);\n    if (arguments.length >= 1) {\n      errors.assertParamValue(nodbUtil.isXid(xid), 1);\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    return await this._impl.tpcPrepare(xid);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcRecover()\n  //\n  // Returns a list of pending two-phase-commit transactions.\n  //---------------------------------------------------------------------------\n  async tpcRecover(asString) {\n    errors.assertArgCount(arguments, 0, 1);\n    if (arguments.length == 1) {\n      errors.assertParamValue(typeof asString === 'boolean', 1);\n    } else {\n      asString = true;\n    }\n    const sqlStr = `\n      SELECT\n          formatid as \"formatId\",\n          UTL_RAW.CAST_TO_VARCHAR2(globalid) as \"globalTransactionId\",\n          UTL_RAW.CAST_TO_VARCHAR2(branchid) as \"branchQualifier\"\n      FROM DBA_PENDING_TRANSACTIONS`;\n    const sqlBuf = `\n      SELECT\n          formatid as \"formatId\",\n          globalid as \"globalTransactionId\",\n          branchid as \"branchQualifier\"\n      FROM DBA_PENDING_TRANSACTIONS`;\n    const options = {\n      outFormat: constants.OUT_FORMAT_OBJECT,\n      resultSet: false\n    };\n    const result = await this.execute(asString ? sqlStr : sqlBuf, {}, options);\n    return result.rows;\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcRollback()\n  //\n  // Rolls back the current changes in a two-phase-commit transaction.\n  //---------------------------------------------------------------------------\n  async tpcRollback(xid) {\n    errors.assertArgCount(arguments, 0, 1);\n    if (arguments.length == 1) {\n      errors.assertParamValue(nodbUtil.isXid(xid), 1);\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.tpcRollback(xid);\n  }\n\n  //---------------------------------------------------------------------------\n  // unsubscribe()\n  //\n  // Destroy a subscription which was earlier created using subscribe().\n  //---------------------------------------------------------------------------\n  async unsubscribe(name) {\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(typeof name === 'string', 1);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    errors.assert(_subscriptions.has(name), errors.ERR_INVALID_SUBSCR);\n    await this._impl.unsubscribe(_subscriptions.get(name));\n    _subscriptions.delete(name);\n  }\n}\n\n// adjust functions to support the old callback style and to serialize calls\n// that cannot take place concurrently\n// NOTE: breakExecution() should not be serialized\nConnection.prototype.break = nodbUtil.callbackify(Connection.prototype.breakExecution);\nnodbUtil.wrapFns(Connection.prototype, \"changePassword\", \"close\", \"commit\", \"createLob\", \"execute\", \"executeMany\", \"getDbObjectClass\", \"getQueue\", \"getStatementInfo\", \"ping\", \"rollback\", \"shutdown\", \"startup\", \"subscribe\", \"tpcBegin\", \"tpcCommit\", \"tpcEnd\", \"tpcForget\", \"tpcPrepare\", \"tpcRecover\", \"tpcRollback\", \"unsubscribe\");\n\n// add alias for release()\nConnection.prototype.release = Connection.prototype.close;\n\n// export just the Connection class\nmodule.exports = Connection;","map":{"version":3,"names":["AqQueue","require","BaseDbObject","Buffer","Lob","ResultSet","SodaDatabase","EventEmitter","QueryStream","errors","nodbUtil","impl","process","util","constants","settings","transformer","types","_subscriptions","Map","Connection","constructor","_dbObjectClasses","_closing","_addDefaultsToExecOpts","options","connection","keepInStmtCache","undefined","addToOptions","_buildDbObjectClass","objType","DbObject","initialValue","_impl","DbObjectImpl","isCollection","proxy","Proxy","_collectionProxyHandler","i","length","append","Object","assign","prototype","create","_objType","elementTypeClass","cls","_getDbObjectClass","addTypeProperties","attributes","props","attr","typeClass","prop","get","_getAttrValue","set","value","_setAttrValue","name","defineProperties","toString","fqn","_connection","_getDbObjectClassForName","getDbObjectClass","_isBindDir","BIND_IN","BIND_OUT","BIND_INOUT","_isBindValue","Array","isArray","isBuffer","isDate","_processBindUnit","bindInfo","bindUnit","inExecuteMany","okBindUnit","dir","assert","ERR_INVALID_BIND_DIRECTION","type","DB_TYPE_OBJECT","DbType","ERR_INVALID_BIND_DATA_TYPE","throwErr","ERR_MISSING_TYPE_BY_NAME","ERR_MISSING_TYPE_BY_POS","pos","maxSize","assertParamPropValue","Number","isInteger","checkSize","DB_TYPE_VARCHAR","DB_TYPE_RAW","ERR_MISSING_MAX_SIZE_BY_NAME","ERR_MISSING_MAX_SIZE_BY_POS","DEFAULT_MAX_SIZE_FOR_OUT_BINDS","maxArraySize","val","ERR_INVALID_BIND_UNIT","_processBindValue","transformed","transformValueIn","values","concat","slice","_processExecuteBind","bindData","bindValue","allowArray","DB_TYPE_NVARCHAR","DB_TYPE_CHAR","DB_TYPE_NCHAR","DB_TYPE_NUMBER","DB_TYPE_BINARY_FLOAT","DB_TYPE_BINARY_DOUBLE","DB_TYPE_DATE","DB_TYPE_TIMESTAMP","DB_TYPE_TIMESTAMP_LTZ","DB_TYPE_TIMESTAMP_TZ","ERR_INVALID_TYPE_FOR_ARRAY_BIND","_processExecuteBinds","binds","normBinds","assertParamValue","isObject","bindNames","getOwnPropertyNames","_processExecuteManyBinds","bindDefs","byPosition","row","isObjectOrArray","ERR_MIXED_BIND","j","_transformOutBind","outVal","push","ResultSetImpl","_setup","LobImpl","dbObjectAsPojo","_toPojo","_verifyExecOpts","outOptions","autoCommit","batchErrors","dmlRowCounts","fetchArraySize","fetchInfo","names","map","fetchTypeMap","info","ERR_NO_TYPE_FOR_CONVERSION","DEFAULT","ERR_INVALID_TYPE_FOR_CONVERSION","fetchTypeHandler","maxRows","outFormat","OUT_FORMAT_ARRAY","OUT_FORMAT_OBJECT","prefetchRows","resultSet","action","assertPropValue","ERR_INVALID_CONNECTION","setAction","breakExecution","assertArgCount","arguments","callTimeout","getCallTimeout","setCallTimeout","changePassword","user","password","newPassword","clientId","setClientId","clientInfo","setClientInfo","close","a1","assertParamPropBool","clear","emit","commit","createLob","DB_TYPE_CLOB","DB_TYPE_BLOB","DB_TYPE_NCLOB","lob","currentSchema","getCurrentSchema","setCurrentSchema","dbOp","setDbOp","thin","ecid","setECID","execute","sql","a2","a3","numIters","result","err","errorNum","ERR_INSUFFICIENT_BUFFER_FOR_BINDS","warning","transformErr","metaData","rows","_getAllRows","outBinds","key","implicitResults","resultSetImpl","executeMany","bindsOrNumIters","outBind","externalName","getExternalName","setExternalName","dbDomain","getDbDomain","dbName","getDbName","getQueue","queue","getSodaDatabase","sodaDb","getStatementInfo","m","fetchType","DB_TYPE_FETCH_TYPE_MAP","dbType","instanceName","getInstanceName","internalName","getInternalName","setInternalName","isHealthy","maxOpenCursors","getMaxOpenCursors","getWarning","module","setModule","oracleServerVersion","getOracleServerVersion","oracleServerVersionString","getOracleServerVersionString","serviceName","getServiceName","transactionInProgress","getTransactionInProgress","ping","queryStream","stream","nextTick","ERR_NOT_A_QUERY","_open","destroy","rollback","shutdown","mode","SHUTDOWN_MODE_DEFAULT","startup","assertParamPropString","stmtCacheSize","getStmtCacheSize","setStmtCacheSize","subscribe","assertParamPropUnsignedInt","namespace","SUBSCR_NAMESPACE_DBCHANGE","assertParamPropFunction","callback","ERR_MISSING_SUBSCR_CALLBACK","ERR_MISSING_SUBSCR_SQL","inSubscr","outValue","subscription","tag","getTag","setTag","tpcBegin","xid","flag","timeout","isXid","TPC_BEGIN_NEW","tpcCommit","onePhase","tpcEnd","TPC_END_NORMAL","tpcForget","tpcPrepare","tpcRecover","asString","sqlStr","sqlBuf","tpcRollback","unsubscribe","has","ERR_INVALID_SUBSCR","delete","break","callbackify","wrapFns","release","exports"],"sources":["C:/Users/user1/Desktop/finalproject_penpick/node_modules/oracledb/lib/connection.js"],"sourcesContent":["// Copyright (c) 2016, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst AqQueue = require('./aqQueue.js');\nconst BaseDbObject = require('./dbObject.js');\nconst { Buffer } = require('buffer');\nconst Lob = require('./lob.js');\nconst ResultSet = require('./resultset.js');\nconst SodaDatabase = require('./sodaDatabase.js');\nconst EventEmitter = require('events');\nconst QueryStream = require('./queryStream.js');\nconst errors = require('./errors.js');\nconst nodbUtil = require('./util.js');\nconst impl = require('./impl');\nconst process = require('process');\nconst util = require('util');\nconst constants = require('./constants.js');\nconst settings = require('./settings.js');\nconst transformer = require('./transformer.js');\nconst types = require('./types.js');\n\n// global mapping of subscriptions; these cannot be tied to a particular\n// connection or pool since subscriptions can be created with one connection\n// and destroyed with another!\nconst _subscriptions = new Map();\n\n// define class\nclass Connection extends EventEmitter {\n\n  constructor() {\n    super();\n    this._dbObjectClasses = new Map();\n    this._closing = false;\n  }\n\n  //---------------------------------------------------------------------------\n  // _addDefaultsToExecOpts()\n  //\n  // Add values to the execute options from the global settings, if needed.\n  //---------------------------------------------------------------------------\n  _addDefaultsToExecOpts(options) {\n    options.connection = this;\n    if (options.keepInStmtCache === undefined)\n      options.keepInStmtCache = true;\n    settings.addToOptions(options,\n      \"autoCommit\",\n      \"dbObjectAsPojo\",\n      \"fetchArraySize\",\n      \"fetchTypeHandler\",\n      \"maxRows\",\n      \"outFormat\",\n      \"prefetchRows\");\n  }\n\n  //---------------------------------------------------------------------------\n  // _buildDbObjectClass()\n  //\n  // Builds and returns a database object class given the object type\n  // information supplied by the implementation.\n  //---------------------------------------------------------------------------\n  _buildDbObjectClass(objType) {\n    const DbObject = function(initialValue) {\n      this._impl = new impl.DbObjectImpl(objType);\n      if (this.isCollection) {\n        const proxy = new Proxy(this, BaseDbObject._collectionProxyHandler);\n        if (initialValue !== undefined) {\n          for (let i = 0; i < initialValue.length; i++) {\n            this.append(initialValue[i]);\n          }\n        }\n        return (proxy);\n      } else if (initialValue !== undefined) {\n        Object.assign(this, initialValue);\n      }\n    };\n    DbObject.prototype = Object.create(BaseDbObject.prototype);\n    DbObject.prototype.constructor = DbObject;\n    DbObject.prototype._objType = objType;\n    if (objType.elementTypeClass) {\n      const cls = this._getDbObjectClass(objType.elementTypeClass);\n      objType.elementTypeClass = cls;\n    }\n    nodbUtil.addTypeProperties(objType, \"elementType\");\n    if (objType.attributes) {\n      const props = {};\n      for (const attr of objType.attributes) {\n        if (attr.typeClass) {\n          attr.typeClass = this._getDbObjectClass(attr.typeClass);\n        }\n        nodbUtil.addTypeProperties(attr, \"type\");\n        const prop = {\n          get() {\n            return this._getAttrValue(attr);\n          },\n          set(value) {\n            this._setAttrValue(attr, value);\n          }\n        };\n        props[attr.name] = prop;\n      }\n      Object.defineProperties(DbObject.prototype, props);\n    }\n    DbObject.toString = function() {\n      return ('DbObjectClass [' + objType.fqn + ']');\n    };\n    return (DbObject);\n  }\n\n  //---------------------------------------------------------------------------\n  // _getDbObjectClass()\n  //\n  // Returns the database object class given the object type information\n  // supplied by the implementation. The cache is searched first to see if an\n  // object class has already been built.\n  //---------------------------------------------------------------------------\n  _getDbObjectClass(objType) {\n    if (objType.prototype instanceof BaseDbObject)\n      return objType;\n    let cls = this._dbObjectClasses.get(objType);\n    if (!cls) {\n      cls = this._buildDbObjectClass(objType);\n      cls._connection = this;\n      cls._objType = objType;\n      objType._connection = this._impl;\n      this._dbObjectClasses.set(objType, cls);\n    }\n    return (cls);\n  }\n\n  //---------------------------------------------------------------------------\n  // _getDbObjectClassForName()\n  //\n  // Returns the database object class given the name of the database object\n  // type. The cache is searched first to see if an object class has already\n  // been built.\n  //---------------------------------------------------------------------------\n  async _getDbObjectClassForName(name) {\n    let cls = this._dbObjectClasses.get(name);\n    if (!cls) {\n      const objType = await this._impl.getDbObjectClass(name);\n      cls = this._getDbObjectClass(objType);\n      this._dbObjectClasses.set(name, cls);\n    }\n    return cls;\n  }\n\n  //---------------------------------------------------------------------------\n  // _isBindDir()\n  //\n  // Returns a boolean indicating if the supplied value is a valid bind\n  // direction.\n  //---------------------------------------------------------------------------\n  _isBindDir(value) {\n    return (\n      value === constants.BIND_IN ||\n      value === constants.BIND_OUT ||\n      value === constants.BIND_INOUT\n    );\n  }\n\n  //---------------------------------------------------------------------------\n  // _isBindValue()\n  //\n  // Returns a boolean indicating if the supplied value is one that can be\n  // bound.\n  //---------------------------------------------------------------------------\n  _isBindValue(value) {\n    return (\n      value === null ||\n      value === undefined ||\n      typeof value === 'number' ||\n      typeof value === 'string' ||\n      typeof value === 'boolean' ||\n      Array.isArray(value) ||\n      Buffer.isBuffer(value) ||\n      util.isDate(value) ||\n      value instanceof Lob ||\n      value instanceof ResultSet ||\n      value instanceof BaseDbObject\n    );\n  }\n\n  //---------------------------------------------------------------------------\n  // _processBindUnit()\n  //\n  // Processes a bind unit (object) supplied by the user and returns the value\n  // stored in it (if one is).\n  //---------------------------------------------------------------------------\n  async _processBindUnit(bindInfo, bindUnit, inExecuteMany) {\n    let okBindUnit = false;\n\n    // get and validate bind direction; if not specified, IN is assumed\n    if (bindUnit.dir === undefined) {\n      bindInfo.dir = constants.BIND_IN;\n    } else {\n      errors.assert(this._isBindDir(bindUnit.dir),\n        errors.ERR_INVALID_BIND_DIRECTION);\n      bindInfo.dir = bindUnit.dir;\n      okBindUnit = true;\n    }\n\n    // get and validate bind type; it must be one of the integer constants\n    // identifying types, a string identifying an object type or a constructor\n    // function identifying an object type\n    if (bindUnit.type !== undefined) {\n      if (typeof bindUnit.type === 'string') {\n        bindInfo.type = types.DB_TYPE_OBJECT;\n        bindInfo.typeClass = await this._getDbObjectClassForName(bindUnit.type);\n        bindInfo.objType = bindInfo.typeClass._objType;\n      } else if (bindUnit.type.prototype instanceof BaseDbObject) {\n        bindInfo.type = types.DB_TYPE_OBJECT;\n        bindInfo.typeClass = bindUnit.type;\n        bindInfo.objType = bindInfo.typeClass._objType;\n      } else {\n        errors.assert(bindUnit.type instanceof types.DbType,\n          errors.ERR_INVALID_BIND_DATA_TYPE, 2);\n        bindInfo.type = bindUnit.type;\n      }\n      okBindUnit = true;\n\n    // when calling executeMany(), bind type is mandatory\n    } else if (inExecuteMany) {\n      if (bindInfo.name)\n        errors.throwErr(errors.ERR_MISSING_TYPE_BY_NAME, bindInfo.name);\n      errors.throwErr(errors.ERR_MISSING_TYPE_BY_POS, bindInfo.pos);\n    }\n\n    // get and validate the maximum size for strings/buffers; this value is\n    // used for IN/OUT and OUT binds in execute() and at all times for\n    // executeMany()\n    if (bindInfo.dir !== constants.BIND_IN || inExecuteMany) {\n      if (bindUnit.maxSize !== undefined) {\n        errors.assertParamPropValue(Number.isInteger(bindUnit.maxSize) &&\n          bindUnit.maxSize > 0, 2, \"maxSize\");\n        bindInfo.maxSize = bindUnit.maxSize;\n        bindInfo.checkSize = true;\n        okBindUnit = true;\n      } else if (inExecuteMany) {\n        if (bindInfo.type === types.DB_TYPE_VARCHAR ||\n            bindInfo.type === types.DB_TYPE_RAW) {\n          if (bindInfo.name)\n            errors.throwErr(errors.ERR_MISSING_MAX_SIZE_BY_NAME, bindInfo.name);\n          errors.throwErr(errors.ERR_MISSING_MAX_SIZE_BY_POS, bindInfo.pos);\n        }\n      } else {\n        bindInfo.maxSize = constants.DEFAULT_MAX_SIZE_FOR_OUT_BINDS;\n      }\n    }\n\n    // get max array size (for array binds, not possible in executeMany())\n    bindInfo.isArray = false;\n    if (!inExecuteMany) {\n      if (bindUnit.maxArraySize !== undefined) {\n        errors.assertParamPropValue(Number.isInteger(bindUnit.maxArraySize) &&\n          bindUnit.maxArraySize > 0, 2, \"maxArraySize\");\n        bindInfo.maxArraySize = bindUnit.maxArraySize;\n        bindInfo.isArray = true;\n      }\n    }\n\n    // get the value, if specified (not used in executeMany())\n    if (!inExecuteMany && bindUnit.val !== undefined) {\n      return bindUnit.val;\n    }\n\n    if (!okBindUnit)\n      errors.throwErr(errors.ERR_INVALID_BIND_UNIT);\n  }\n\n  //---------------------------------------------------------------------------\n  // _processBindValue()\n  //\n  // Processes the bind value supplied by the caller. This performs all checks\n  // on the value and normalizes it for use by the implementation class. If no\n  // bind info has been defined yet, the value defines that.\n  //---------------------------------------------------------------------------\n  async _processBindValue(bindInfo, value, options) {\n    const transformed = transformer.transformValueIn(bindInfo, value, options);\n    if (bindInfo.isArray) {\n      bindInfo.values = transformed.concat(bindInfo.values.slice(transformed.length));\n    } else {\n      bindInfo.values[options.pos] = transformed;\n    }\n    if (bindInfo.type === types.DB_TYPE_OBJECT &&\n        bindInfo.typeClass === undefined) {\n      bindInfo.typeClass = await this._getDbObjectClass(value._objType);\n      bindInfo.objType = bindInfo.typeClass._objType;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _processExecuteBind()\n  //\n  // Processes a single execute bind supplied by the caller. This performs all\n  // checks on the bind and normalizes it for use by the implementation class.\n  //---------------------------------------------------------------------------\n  async _processExecuteBind(bindInfo, bindData) {\n\n    // setup defaults\n    bindInfo.isArray = false;\n\n    // if bind data is a value that can be bound directly, use it; otherwise,\n    // scan the bind unit for bind information and its value\n    let bindValue;\n    if (this._isBindValue(bindData)) {\n      bindInfo.dir = constants.BIND_IN;\n      bindValue = bindData;\n    } else {\n      bindValue = await this._processBindUnit(bindInfo, bindData, false);\n    }\n\n    // for IN and IN/OUT binds, process the value\n    if (bindInfo.dir !== constants.BIND_OUT) {\n      const options = {pos: 0, allowArray: true};\n      await this._processBindValue(bindInfo, bindValue, options);\n    }\n\n    // if only null values were found (or an OUT bind was specified), type\n    // information may not be set, so complete bind information as a string\n    // and set the maxSize to 1 if it has not already been set\n    if (bindInfo.type === undefined) {\n      bindInfo.type = types.DB_TYPE_VARCHAR;\n      if (bindInfo.maxSize === undefined)\n        bindInfo.maxSize = 1;\n    }\n\n    // check valid bind type for array binds\n    if (bindInfo.isArray &&\n        bindInfo.type !== types.DB_TYPE_VARCHAR &&\n        bindInfo.type !== types.DB_TYPE_NVARCHAR &&\n        bindInfo.type !== types.DB_TYPE_CHAR &&\n        bindInfo.type !== types.DB_TYPE_NCHAR &&\n        bindInfo.type !== types.DB_TYPE_NUMBER &&\n        bindInfo.type !== types.DB_TYPE_BINARY_FLOAT &&\n        bindInfo.type !== types.DB_TYPE_BINARY_DOUBLE &&\n        bindInfo.type !== types.DB_TYPE_DATE &&\n        bindInfo.type !== types.DB_TYPE_TIMESTAMP &&\n        bindInfo.type !== types.DB_TYPE_TIMESTAMP_LTZ &&\n        bindInfo.type !== types.DB_TYPE_TIMESTAMP_TZ &&\n        bindInfo.type !== types.DB_TYPE_RAW) {\n      errors.throwErr(errors.ERR_INVALID_TYPE_FOR_ARRAY_BIND);\n    }\n\n  }\n\n  //---------------------------------------------------------------------------\n  // _processExecuteBinds()\n  //\n  // Processes the binds supplied by the caller. This performs all checks on\n  // the binds and normalizes them for use by the implementation class.\n  //---------------------------------------------------------------------------\n  async _processExecuteBinds(binds) {\n    const normBinds = [];\n    if (Array.isArray(binds)) {\n      for (let i = 0; i < binds.length; i++) {\n        const bindInfo = normBinds[i] = {pos: i + 1, values: []};\n        await this._processExecuteBind(bindInfo, binds[i]);\n      }\n    } else {\n      errors.assertParamValue(nodbUtil.isObject(binds), 2);\n      const bindNames = Object.getOwnPropertyNames(binds);\n      for (let i = 0; i < bindNames.length; i++) {\n        const bindInfo = normBinds[i] = {name: bindNames[i], values: []};\n        await this._processExecuteBind(bindInfo, binds[bindNames[i]]);\n      }\n    }\n    return normBinds;\n  }\n\n  //---------------------------------------------------------------------------\n  // _processExecuteManyBinds()\n  //\n  // Processes the binds supplied by the caller. This performs all checks on\n  // the binds and normalizes them for use by the implementation class.\n  //---------------------------------------------------------------------------\n  async _processExecuteManyBinds(binds, bindDefs) {\n    const normBinds = [];\n    let byPosition;\n\n    // transform bindDefs into normalized binds, if available\n    if (bindDefs !== undefined) {\n      if (Array.isArray(bindDefs)) {\n        byPosition = true;\n        for (let i = 0; i < bindDefs.length; i++) {\n          const bindInfo = normBinds[i] = {pos: i + 1, values: []};\n          await this._processBindUnit(bindInfo, bindDefs[i], true);\n        }\n      } else {\n        byPosition = false;\n        const bindNames = Object.getOwnPropertyNames(bindDefs);\n        for (let i = 0; i < bindNames.length; i++) {\n          const bindInfo = normBinds[i] = {name: bindNames[i], values: []};\n          await this._processBindUnit(bindInfo, bindDefs[bindNames[i]], true);\n        }\n      }\n\n    // otherwise, use the first row to determine the binds to use\n    } else {\n      const row = binds[0];\n      errors.assertParamValue(nodbUtil.isObjectOrArray(row), 2);\n      if (Array.isArray(row)) {\n        byPosition = true;\n        for (let i = 0; i < row.length; i++) {\n          normBinds[i] = {pos: i + 1};\n        }\n      } else {\n        byPosition = false;\n        const bindNames = Object.getOwnPropertyNames(row);\n        for (let i = 0; i < bindNames.length; i++) {\n          normBinds[i] = {name: bindNames[i]};\n        }\n      }\n      for (let i = 0; i < normBinds.length; i++) {\n        normBinds[i].dir = constants.BIND_IN;\n        normBinds[i].isArray = false;\n        normBinds[i].values = [];\n      }\n    }\n\n    // process each of the rows\n    for (let i = 0; i < binds.length; i++) {\n      const row = binds[i];\n      const options = {pos: i, allowArray: false};\n      errors.assert((byPosition && Array.isArray(row)) ||\n        (!byPosition && nodbUtil.isObject(row)), errors.ERR_MIXED_BIND);\n      for (let j = 0; j < normBinds.length; j++) {\n        const bindInfo = normBinds[j];\n        const value = (byPosition) ? row[j] : row[bindInfo.name];\n        await this._processBindValue(bindInfo, value, options);\n      }\n    }\n\n    // set bind type and size to a string of size 1 if no bind type was\n    // specified (and all values are null)\n    for (let i = 0; i < normBinds.length; i++) {\n      const bindInfo = normBinds[i];\n      if (bindInfo.type === undefined) {\n        bindInfo.type = types.DB_TYPE_VARCHAR;\n        bindInfo.maxSize = 1;\n      }\n    }\n\n    return normBinds;\n  }\n\n  //---------------------------------------------------------------------------\n  // _transformOutBind()\n  //\n  // Transform an output bind value from an implementation value to a user\n  // facing value (for result sets and LOBs). DML returning output variables\n  // are always an array of values.\n  //---------------------------------------------------------------------------\n  _transformOutBind(val, options) {\n    let outVal = val;\n    if (Array.isArray(val)) {\n      outVal = [];\n      for (let i = 0; i < val.length; i++)\n        outVal.push(this._transformOutBind(val[i], options));\n    } else if (val instanceof impl.ResultSetImpl) {\n      outVal = new ResultSet();\n      outVal._setup(this, val);\n    } else if (val instanceof impl.LobImpl) {\n      outVal = new Lob();\n      outVal._setup(val, true);\n    } else if (val instanceof impl.DbObjectImpl) {\n      const cls = this._dbObjectClasses.get(val._objType);\n      outVal = Object.create(cls.prototype);\n      outVal._impl = val;\n      if (options.dbObjectAsPojo) {\n        outVal = outVal._toPojo();\n      } else if (outVal.isCollection) {\n        outVal = new Proxy(outVal, BaseDbObject._collectionProxyHandler);\n      }\n    }\n    return outVal;\n  }\n\n  //---------------------------------------------------------------------------\n  // _verifyExecOpts\n  //\n  // Verify that the value passed by the user for binds is acceptable. Perform\n  // any transformations necessary.\n  //---------------------------------------------------------------------------\n  _verifyExecOpts(options, inExecuteMany) {\n\n    // define normalized options (value returned to caller)\n    const outOptions = {};\n\n    // handle common options\n    errors.assertParamValue(nodbUtil.isObject(options), 3);\n\n    // autoCommit must be a boolean value\n    if (options.autoCommit !== undefined) {\n      errors.assertParamPropValue(typeof options.autoCommit === 'boolean', 3,\n        \"autoCommit\");\n      outOptions.autoCommit = options.autoCommit;\n    }\n\n    // dbObjectAsPojo must be a boolean value\n    if (options.dbObjectAsPojo !== undefined) {\n      errors.assertParamPropValue(typeof options.dbObjectAsPojo === 'boolean',\n        3, \"dbObjectAsPojo\");\n      outOptions.dbObjectAsPojo = options.dbObjectAsPojo;\n    }\n\n    // keepInStmtCache must be a boolean value\n    if (options.keepInStmtCache !== undefined) {\n      errors.assertParamPropValue(typeof options.keepInStmtCache === 'boolean',\n        3, \"keepInStmtCache\");\n      outOptions.keepInStmtCache = options.keepInStmtCache;\n    }\n\n    // handle options specific to executeMany()\n    if (inExecuteMany) {\n\n      // bindDefs must be an object or array\n      if (options.bindDefs !== undefined) {\n        errors.assertParamPropValue(nodbUtil.isObjectOrArray(options.bindDefs),\n          3, \"bindDefs\");\n        outOptions.bindDefs = options.bindDefs;\n      }\n\n      // batchErrors must be a boolean value\n      if (options.batchErrors !== undefined) {\n        errors.assertParamPropValue(typeof options.batchErrors === 'boolean',\n          3, \"batchErrors\");\n        outOptions.batchErrors = options.batchErrors;\n      }\n\n      // dmlRowCounts must be a boolean value\n      if (options.dmlRowCounts !== undefined) {\n        errors.assertParamPropValue(typeof options.dmlRowCounts === 'boolean',\n          3, \"dmlRowCounts\");\n        outOptions.dmlRowCounts = options.dmlRowCounts;\n      }\n\n    // handle options specific to execute()\n    } else {\n\n      // fetchArraySize must be a positive integer\n      if (options.fetchArraySize !== undefined) {\n        errors.assertParamPropValue(Number.isInteger(options.fetchArraySize) &&\n          options.fetchArraySize > 0, 3, \"fetchArraySize\");\n        outOptions.fetchArraySize = options.fetchArraySize;\n      }\n\n      // fetchInfo must be an object with keys containing an object with a\n      // \"type\" property; these are converted to an array of objects for ease\n      // of processing by the implementation\n      if (options.fetchInfo !== undefined) {\n        errors.assertParamPropValue(nodbUtil.isObject(options.fetchInfo), 3,\n          \"fetchInfo\");\n        const names = Object.getOwnPropertyNames(options.fetchInfo);\n        const map = new Map(settings.fetchTypeMap);\n        for (const name of names) {\n          const info = options.fetchInfo[name];\n          if (info.type === undefined)\n            errors.throwErr(errors.ERR_NO_TYPE_FOR_CONVERSION);\n          if (info.type !== constants.DEFAULT &&\n              info.type !== types.DB_TYPE_VARCHAR &&\n              info.type !== types.DB_TYPE_RAW) {\n            errors.throwErr(errors.ERR_INVALID_TYPE_FOR_CONVERSION);\n          }\n          map.set(name, info.type);\n        }\n        outOptions.fetchTypeMap = map;\n      }\n\n      // fetchTypeHandler must be a function which is called for each column to\n      // be fetched and accepts the metadata for a column\n      if (options.fetchTypeHandler !== undefined) {\n        const type = (typeof options.fetchTypeHandler);\n        errors.assertParamPropValue(type === 'function', 3, \"fetchTypeHandler\");\n        outOptions.fetchTypeHandler = options.fetchTypeHandler;\n      }\n\n      // maxRows must be a positive integer (or 0)\n      if (options.maxRows !== undefined) {\n        errors.assertParamPropValue(Number.isInteger(options.maxRows) &&\n          options.maxRows >= 0, 3, \"maxRows\");\n        outOptions.maxRows = options.maxRows;\n      }\n\n      // outFormat must be one of the two possible constants\n      if (options.outFormat !== undefined) {\n        errors.assertParamPropValue(\n          options.outFormat === constants.OUT_FORMAT_ARRAY ||\n          options.outFormat === constants.OUT_FORMAT_OBJECT, 3, \"outFormat\");\n        outOptions.outFormat = options.outFormat;\n      }\n\n      // prefetchRows must be a positive integer (or 0)\n      if (options.prefetchRows !== undefined) {\n        errors.assertParamPropValue(Number.isInteger(options.prefetchRows) &&\n          options.prefetchRows >= 0, 3, \"prefetchRows\");\n        outOptions.prefetchRows = options.prefetchRows;\n      }\n\n      // resultSet must be a boolean value\n      if (options.resultSet !== undefined) {\n        errors.assertParamPropValue(typeof options.resultSet === 'boolean', 3,\n          \"resultSet\");\n        outOptions.resultSet = options.resultSet;\n      }\n\n    }\n\n    return outOptions;\n  }\n\n  //---------------------------------------------------------------------------\n  // action\n  //\n  // Property for end-to-end tracing attribute.\n  //---------------------------------------------------------------------------\n  get action() {\n    return null;\n  }\n\n  set action(value) {\n    errors.assertPropValue(typeof value === 'string', \"action\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setAction(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // breakExecution()\n  //\n  // Breaks execution of a running statement.\n  //---------------------------------------------------------------------------\n  async breakExecution() {\n    errors.assertArgCount(arguments, 0, 0);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.breakExecution();\n  }\n\n  //---------------------------------------------------------------------------\n  // callTimeout\n  //\n  // Property for round-trip timeouts.\n  //---------------------------------------------------------------------------\n  get callTimeout() {\n    if (this._impl)\n      return this._impl.getCallTimeout();\n    return undefined;\n  }\n\n  set callTimeout(value) {\n    errors.assertPropValue(Number.isInteger(value) && value >= 0,\n      \"callTimeout\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setCallTimeout(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // changePassword()\n  //\n  // Changes the password of the specified user.\n  //---------------------------------------------------------------------------\n  async changePassword(user, password, newPassword) {\n    errors.assertArgCount(arguments, 3, 3);\n    errors.assertParamValue(typeof user === 'string', 1);\n    errors.assertParamValue(typeof password === 'string', 2);\n    errors.assertParamValue(typeof newPassword === 'string', 3);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.changePassword(user, password, newPassword);\n  }\n\n  //---------------------------------------------------------------------------\n  // clientId\n  //\n  // Property for end-to-end tracing attribute.\n  //---------------------------------------------------------------------------\n  get clientId() {\n    return null;\n  }\n\n  set clientId(value) {\n    errors.assertPropValue(typeof value === 'string', \"clientId\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setClientId(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // clientInfo\n  //\n  // Property for end-to-end tracing attribute.\n  //---------------------------------------------------------------------------\n  get clientInfo() {\n    return null;\n  }\n\n  set clientInfo(value) {\n    errors.assertPropValue(typeof value === 'string', \"clientInfo\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setClientInfo(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // close()\n  //\n  // Closes the connection and makes it unusable for further work.\n  //---------------------------------------------------------------------------\n  async close(a1) {\n    let options = {};\n\n    errors.assertArgCount(arguments, 0, 1);\n    if (arguments.length == 1) {\n      errors.assertParamValue(nodbUtil.isObject(a1), 1);\n      options = a1;\n      errors.assertParamPropBool(options, 1, \"drop\");\n    }\n    errors.assert(this._impl && !this._closing, errors.ERR_INVALID_CONNECTION);\n\n    this._closing = true;\n    try {\n      await this._impl.close(options);\n    } finally {\n      this._closing = false;\n    }\n\n    delete this._impl;\n    this._dbObjectClasses.clear();\n    this.emit('_afterConnClose');\n  }\n\n  //---------------------------------------------------------------------------\n  // commit()\n  //\n  // Commits the current transaction.\n  //---------------------------------------------------------------------------\n  async commit() {\n    errors.assertArgCount(arguments, 0, 0);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.commit();\n  }\n\n  //---------------------------------------------------------------------------\n  // createLob()\n  //\n  // Creates a temporary LOB and returns it to the caller.\n  //---------------------------------------------------------------------------\n  async createLob(type) {\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(type === types.DB_TYPE_CLOB ||\n      type === types.DB_TYPE_BLOB ||\n      type === types.DB_TYPE_NCLOB, 1);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    const lob = new Lob();\n    lob._setup(await this._impl.createLob(type), false);\n    return lob;\n  }\n\n  //---------------------------------------------------------------------------\n  // currentSchema\n  //\n  // Property for identifying the current schema to use in the database.\n  //---------------------------------------------------------------------------\n  get currentSchema() {\n    if (this._impl)\n      return this._impl.getCurrentSchema();\n    return undefined;\n  }\n\n  set currentSchema(value) {\n    errors.assertPropValue(typeof value === 'string', \"currentSchema\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setCurrentSchema(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // dbOp\n  //\n  // Property for end-to-end tracing attribute.\n  //---------------------------------------------------------------------------\n  get dbOp() {\n    return null;\n  }\n\n  set dbOp(value) {\n    errors.assertPropValue(typeof value === 'string', \"dbOp\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setDbOp(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // thin()\n  //\n  // return true, if driver mode is thin while acquiring connection\n  // return false, if driver mode is thick while acquiring connection\n  //---------------------------------------------------------------------------\n  get thin() {\n    return settings.thin;\n  }\n\n  //---------------------------------------------------------------------------\n  // ecid\n  //\n  // Property for end-to-end tracing attribute.\n  //---------------------------------------------------------------------------\n  get ecid() {\n    return null;\n  }\n\n  set ecid(value) {\n    errors.assertPropValue(typeof value === 'string', \"ecid\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setECID(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // execute()\n  //\n  // Executes a SQL statement and returns the results.\n  //---------------------------------------------------------------------------\n  async execute(sql, a2, a3) {\n    const numIters = 1;\n    let binds = [];\n    let options = {};\n\n    // process arguments\n    errors.assertArgCount(arguments, 1, 3);\n    errors.assertParamValue(typeof sql === 'string', 1);\n    if (arguments.length >= 2) {\n      binds = await this._processExecuteBinds(a2);\n    }\n    if (arguments.length == 3) {\n      options = this._verifyExecOpts(a3, false);\n    }\n    this._addDefaultsToExecOpts(options);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n\n    // perform actual execute\n    let result;\n    try {\n      result = await this._impl.execute(sql, numIters, binds, options, false);\n    } catch (err) {\n      if (err.errorNum === 1406)\n        errors.throwErr(errors.ERR_INSUFFICIENT_BUFFER_FOR_BINDS);\n      throw err;\n    }\n\n    // convert ORA errors to NJS\n    if (result.warning) {\n      result.warning = errors.transformErr(result.warning);\n    }\n\n    // process queries; if a result set is not desired, fetch all of the rows\n    // from the result set and then destroy the result set\n    if (result.resultSet !== undefined) {\n      const resultSet = new ResultSet();\n      resultSet._setup(this, result.resultSet);\n      result.metaData = resultSet._impl.metaData;\n      if (options.resultSet) {\n        result.resultSet = resultSet;\n      } else {\n        result.rows = await resultSet._getAllRows();\n        delete result.resultSet;\n      }\n    }\n\n    // process output binds\n    if (result.outBinds !== undefined) {\n      for (const key in result.outBinds) {\n        const val = this._transformOutBind(result.outBinds[key], options);\n        result.outBinds[key] = val;\n      }\n    }\n\n    // process implicit results; ensure all implicit results have their fetch\n    // array size fixed, or, if a result set is not requested, that all rows\n    // are fetched\n    if (result.implicitResults) {\n      for (const key in result.implicitResults) {\n        const resultSetImpl = result.implicitResults[key];\n        const resultSet = new ResultSet();\n        resultSet._setup(this, resultSetImpl);\n        if (options.resultSet) {\n          result.implicitResults[key] = resultSet;\n        } else {\n          result.implicitResults[key] = await resultSet._getAllRows();\n        }\n      }\n    }\n\n    return (result);\n  }\n\n  //---------------------------------------------------------------------------\n  // executeMany()\n  //\n  // Executes a SQL statement multiple times and returns the results.\n  //---------------------------------------------------------------------------\n  async executeMany(sql, bindsOrNumIters, a3) {\n    let options = {};\n    let binds = [];\n    let numIters;\n\n    errors.assertArgCount(arguments, 2, 3);\n    errors.assertParamValue(typeof sql === 'string', 1);\n    if (arguments.length == 3) {\n      options = this._verifyExecOpts(a3, true);\n    }\n    this._addDefaultsToExecOpts(options);\n    if (typeof bindsOrNumIters === 'number') {\n      errors.assertParamValue(Number.isInteger(bindsOrNumIters) &&\n        bindsOrNumIters > 0, 2);\n      numIters = bindsOrNumIters;\n      if (options.bindDefs !== undefined) {\n        binds = await this._processExecuteManyBinds([], options.bindDefs);\n      }\n    } else {\n      errors.assertParamValue(Array.isArray(bindsOrNumIters) &&\n        bindsOrNumIters.length > 0, 2);\n      numIters = bindsOrNumIters.length;\n      binds = await this._processExecuteManyBinds(bindsOrNumIters,\n        options.bindDefs);\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n\n    const result = await this._impl.execute(sql, numIters, binds, options,\n      true);\n\n    // process output binds\n    if (result.outBinds !== undefined) {\n      for (let i = 0; i < result.outBinds.length; i++) {\n        const outBind = result.outBinds[i];\n        for (const key in outBind) {\n          outBind[key] = this._transformOutBind(outBind[key], options);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  //---------------------------------------------------------------------------\n  // externalName\n  //\n  // Property for identifying the external name to use in TPC logging.\n  //---------------------------------------------------------------------------\n  get externalName() {\n    if (this._impl)\n      return this._impl.getExternalName();\n    return undefined;\n  }\n\n  set externalName(value) {\n    errors.assertPropValue(typeof value === 'string', \"externalName\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setExternalName(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // dbDomain (READONLY)\n  //\n  // Property for identifying the dbDomain of the Oracle Database.\n  //---------------------------------------------------------------------------\n  get dbDomain() {\n    return this._impl && this._impl.getDbDomain();\n  }\n\n  //---------------------------------------------------------------------------\n  // dbName (READONLY)\n  //\n  // Property for identifying the dbName of the Oracle Database.\n  //---------------------------------------------------------------------------\n  get dbName() {\n    return this._impl && this._impl.getDbName();\n  }\n\n  //---------------------------------------------------------------------------\n  // getDbObjectClass()\n  //\n  // Returns a database object class given its name. The cache is searched\n  // first, but if not found, the database is queried and the result is cached\n  // using the type information (as well as the name for easier lookup later).\n  //---------------------------------------------------------------------------\n  async getDbObjectClass(name) {\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(typeof name === 'string', 1);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    return await this._getDbObjectClassForName(name);\n  }\n\n  //---------------------------------------------------------------------------\n  // getQueue()\n  //\n  // Returns a queue with the specified name.\n  //---------------------------------------------------------------------------\n  async getQueue(name, a2) {\n    let options = {};\n\n    errors.assertArgCount(arguments, 1, 2);\n    errors.assertParamValue(typeof name === 'string', 1);\n    if (arguments.length == 2) {\n      errors.assertParamValue(nodbUtil.isObject(a2), 2);\n      options = {...a2};\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    const queue = new AqQueue();\n    await queue.create(this, name, options);\n    return queue;\n  }\n\n  //---------------------------------------------------------------------------\n  // getSodaDatabase()\n  //\n  // Returns a SodaDatabase object (high-level SODA object associated with\n  // the current connection).\n  //---------------------------------------------------------------------------\n  getSodaDatabase() {\n    errors.assertArgCount(arguments, 0, 0);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    const sodaDb = new SodaDatabase();\n    sodaDb._impl = this._impl.getSodaDatabase();\n    return sodaDb;\n  }\n\n  //---------------------------------------------------------------------------\n  // getStatementInfo()\n  //\n  // Returns information about the statement.\n  //---------------------------------------------------------------------------\n  async getStatementInfo(sql) {\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(typeof sql === 'string', 1);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    const info = await this._impl.getStatementInfo(sql);\n    if (info.metaData) {\n      for (let i = 0; i < info.metaData.length; i++) {\n        const m = info.metaData[i];\n        nodbUtil.addTypeProperties(m, \"dbType\");\n        m.fetchType = types.DB_TYPE_FETCH_TYPE_MAP.get(m.dbType);\n      }\n    }\n    return info;\n  }\n\n  //---------------------------------------------------------------------------\n  // instanceName\n  //\n  // Returns the Oracle Database instance name associated with the connection.\n  // This is the equivalent of the SQL expression:\n  // sys_context('userenv', 'instance_name')\n  //---------------------------------------------------------------------------\n  get instanceName() {\n    if (this._impl)\n      return this._impl.getInstanceName();\n    return undefined;\n  }\n\n  //---------------------------------------------------------------------------\n  // internalName\n  //\n  // Property for identifying the internal name to use in TPC logging.\n  //---------------------------------------------------------------------------\n  get internalName() {\n    if (this._impl)\n      return this._impl.getInternalName();\n    return undefined;\n  }\n\n  set internalName(value) {\n    errors.assertPropValue(typeof value === 'string', \"internalName\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setInternalName(value);\n  }\n\n  //--------------------------------------------------------------------------\n  // isHealthy()\n  //\n  // Returns the health status of the connection. If this function returns\n  // false, the caller should close the connection.\n  //---------------------------------------------------------------------------\n  isHealthy() {\n    return (this._impl !== undefined && !this._closing &&\n      this._impl.isHealthy());\n  }\n\n  //---------------------------------------------------------------------------\n  // maxOpenCursors\n  //\n  // Returns maximum number of cursors that can be opened in one session.\n  //---------------------------------------------------------------------------\n  get maxOpenCursors() {\n    return this._impl && this._impl.getMaxOpenCursors();\n  }\n\n  //---------------------------------------------------------------------------\n  // warning\n  //\n  // Returns warningInfo.\n  //---------------------------------------------------------------------------\n  get warning() {\n    let warning = this._impl.getWarning();\n    if (warning) {\n      // Make sure that warning code attribute is populated and ORA error\n      // is converted to NJS, if required\n      warning = errors.transformErr(warning);\n    }\n    return this._impl && warning;\n  }\n\n  //---------------------------------------------------------------------------\n  // module\n  //\n  // Property for end-to-end tracing attribute.\n  //---------------------------------------------------------------------------\n  get module() {\n    return null;\n  }\n\n  set module(value) {\n    errors.assertPropValue(typeof value === 'string', \"module\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setModule(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // oracleServerVersion\n  //\n  // Returns an integer identifying the Oracle Server version.\n  //---------------------------------------------------------------------------\n  get oracleServerVersion() {\n    if (this._impl)\n      return this._impl.getOracleServerVersion();\n    return undefined;\n  }\n\n  //---------------------------------------------------------------------------\n  // oracleServerVersionString\n  //\n  // Returns a string identifying the Oracle Server version.\n  //---------------------------------------------------------------------------\n  get oracleServerVersionString() {\n    if (this._impl)\n      return this._impl.getOracleServerVersionString();\n    return undefined;\n  }\n\n  //---------------------------------------------------------------------------\n  // serviceName\n  //\n  // Returns the Oracle Database service name associated with the connection.\n  //---------------------------------------------------------------------------\n  get serviceName() {\n    return this._impl && this._impl.getServiceName();\n  }\n\n  //---------------------------------------------------------------------------\n  // transactionInProgress\n  //\n  // Returns a boolean value based on the presence of an active transaction\n  // on the connection\n  //---------------------------------------------------------------------------\n  get transactionInProgress() {\n    return this._impl && this._impl.getTransactionInProgress();\n  }\n\n  //---------------------------------------------------------------------------\n  // ping()\n  //\n  // Sends a \"ping\" to the database to see if it is \"alive\".\n  //---------------------------------------------------------------------------\n  async ping() {\n    errors.assertArgCount(arguments, 0, 0);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.ping();\n  }\n\n  //--------------------------------------------------------------------------\n  // queryStream()\n  //\n  // Similar to execute() except that it immediately returns a QueryStream\n  // object.\n  // ---------------------------------------------------------------------------\n  queryStream(sql, binds, options) {\n    errors.assertArgCount(arguments, 1, 3);\n    errors.assertParamValue(typeof sql === 'string', 1);\n    if (arguments.length == 3) {\n      errors.assertParamValue(nodbUtil.isObject(options), 3);\n      options = {...options};\n    } else {\n      options = {};\n    }\n    options.resultSet = true;\n\n    const stream = new QueryStream();\n\n    // calling execute() via nextTick to ensure that handlers are registered\n    // prior to the events being emitted\n    process.nextTick(async () => {\n      try {\n        const result = await this.execute(sql, binds || [], options);\n        if (!result.resultSet)\n          errors.throwErr(errors.ERR_NOT_A_QUERY);\n        stream._open(result.resultSet);\n      } catch (err) {\n        stream.destroy(err);\n        return;\n      }\n    });\n\n    return (stream);\n  }\n\n  //---------------------------------------------------------------------------\n  // rollback()\n  //\n  // Rolls back the current transaction.\n  //---------------------------------------------------------------------------\n  async rollback() {\n    errors.assertArgCount(arguments, 0, 0);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.rollback();\n  }\n\n  //---------------------------------------------------------------------------\n  // shutdown()\n  //   Shuts down the database instance.\n  //---------------------------------------------------------------------------\n  async shutdown(a1) {\n    let mode = constants.SHUTDOWN_MODE_DEFAULT;\n\n    errors.assertArgCount(arguments, 0, 1);\n    if (a1 !== undefined) {\n      errors.assertParamValue(typeof mode === 'number', 1);\n      mode = a1;\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n\n    await this._impl.shutdown(mode);\n  }\n\n  //---------------------------------------------------------------------------\n  // startup()\n  //   Starts up the database instance.\n  //---------------------------------------------------------------------------\n  async startup(a1) {\n    let options = {};\n\n    errors.assertArgCount(arguments, 0, 1);\n    if (arguments.length == 1) {\n      errors.assertParamValue(typeof options === 'object', 1);\n      options = a1;\n      errors.assertParamPropBool(options, 1, \"force\");\n      errors.assertParamPropBool(options, 1, \"restrict\");\n      errors.assertParamPropString(options, 1, \"pfile\");\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n\n    await this._impl.startup(options);\n  }\n\n  //---------------------------------------------------------------------------\n  // stmtCacheSize\n  //\n  // Property for statement cache size.\n  //---------------------------------------------------------------------------\n  get stmtCacheSize() {\n    if (this._impl)\n      return this._impl.getStmtCacheSize();\n    return undefined;\n  }\n\n  set stmtCacheSize(value) {\n    errors.assertPropValue(Number.isInteger(value) && value >= 0,\n      \"stmtCacheSize\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setStmtCacheSize(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // subscribe()\n  //\n  // Creates a subscription which can be used to get notifications of database\n  // changes or of AQ messages available to dequeue.\n  //---------------------------------------------------------------------------\n  async subscribe(name, options) {\n    errors.assertArgCount(arguments, 2, 2);\n    errors.assertParamValue(typeof name === 'string', 1);\n    errors.assertParamValue(nodbUtil.isObject(options), 2);\n    options = {name: name, ...options};\n    errors.assertParamPropUnsignedInt(options, 2, \"namespace\");\n    if (options.namespace === undefined)\n      options.namespace = constants.SUBSCR_NAMESPACE_DBCHANGE;\n    errors.assertParamPropString(options, 2, \"ipAddress\");\n    errors.assertParamPropUnsignedInt(options, 2, \"port\");\n    errors.assertParamPropUnsignedInt(options, 2, \"timeout\");\n    errors.assertParamPropUnsignedInt(options, 2, \"operations\");\n    errors.assertParamPropUnsignedInt(options, 2, \"qos\");\n    errors.assertParamPropUnsignedInt(options, 2, \"groupingClass\");\n    errors.assertParamPropUnsignedInt(options, 2, \"groupingValue\");\n    errors.assertParamPropUnsignedInt(options, 2, \"groupingType\");\n    errors.assertParamPropBool(options, 2, \"clientInitiated\");\n    errors.assertParamPropFunction(options, 2, \"callback\");\n    errors.assert(options.callback, errors.ERR_MISSING_SUBSCR_CALLBACK);\n    if (options.namespace === constants.SUBSCR_NAMESPACE_DBCHANGE) {\n      errors.assertParamPropString(options, 2, \"sql\");\n      errors.assert(options.sql && options.sql.length > 0,\n        errors.ERR_MISSING_SUBSCR_SQL);\n      if (options.binds !== undefined) {\n        options.binds = await this._processExecuteBinds(options.binds);\n      }\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n\n    const inSubscr = _subscriptions.get(name);\n    const outValue = await this._impl.subscribe(inSubscr, options);\n    let subscription;\n    if (options.namespace === constants.SUBSCR_NAMESPACE_DBCHANGE) {\n      subscription = outValue.subscription;\n      delete outValue.subscription;\n    } else {\n      subscription = outValue;\n    }\n    _subscriptions.set(name, subscription);\n    return outValue;\n  }\n\n  //---------------------------------------------------------------------------\n  // tag\n  //\n  // Property for tag to associate with the connection.\n  //---------------------------------------------------------------------------\n  get tag() {\n    if (this._impl)\n      return this._impl.getTag();\n    return undefined;\n  }\n\n  set tag(value) {\n    errors.assertPropValue(typeof value === 'string', \"tag\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setTag(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcBegin()\n  //\n  // Starts a two-phase-commit transaction.\n  //--------------------------------------------------------------------------\n  async tpcBegin(xid, flag, timeout) {\n    errors.assertArgCount(arguments, 1, 3);\n    errors.assertParamValue(nodbUtil.isXid(xid), 1);\n\n    if (arguments.length < 3) {\n      timeout = 60;   // seconds\n    } else {\n      errors.assertParamValue(typeof timeout === 'number', 3);\n    }\n\n    if (arguments.length < 2) {\n      flag = constants.TPC_BEGIN_NEW;\n    } else {\n      errors.assertParamValue(typeof flag === 'number', 2);\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.tpcBegin(xid, flag, timeout);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcCommit()\n  //\n  // Commits a two-phase-commit transaction.\n  //---------------------------------------------------------------------------\n  async tpcCommit(xid, onePhase) {\n    errors.assertArgCount(arguments, 0, 2);\n\n    if (arguments.length < 2) {\n      onePhase = false;\n    } else {\n      errors.assertParamValue(typeof onePhase === 'boolean', 2);\n    }\n    if (arguments.length >= 1) {\n      errors.assertParamValue(nodbUtil.isXid(xid), 1);\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.tpcCommit(xid, onePhase);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcEnd()\n  //\n  // Ends a two-phase-commit transaction.\n  //---------------------------------------------------------------------------\n  async tpcEnd(xid, flag) {\n    errors.assertArgCount(arguments, 0, 2);\n\n    if (arguments.length < 2) {\n      flag = constants.TPC_END_NORMAL;\n    } else {\n      errors.assertParamValue(typeof flag === 'number', 2);\n    }\n\n    if (arguments.length >= 1) {\n      errors.assertParamValue(nodbUtil.isXid(xid), 1);\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n\n    await this._impl.tpcEnd(xid, flag);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcForget()\n  //\n  // Causes the server to forget a heuristically completed two-phase-commit\n  // transaction.\n  // ---------------------------------------------------------------------------\n  async tpcForget(xid) {\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(nodbUtil.isXid(xid), 1);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n\n    await this._impl.tpcForget(xid);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcPrepare()\n  //\n  // Prepares a two-phase-commit transaction for commit.\n  //---------------------------------------------------------------------------\n  async tpcPrepare(xid) {\n    errors.assertArgCount(arguments, 0, 1);\n    if (arguments.length >= 1) {\n      errors.assertParamValue(nodbUtil.isXid(xid), 1);\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n\n    return await this._impl.tpcPrepare(xid);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcRecover()\n  //\n  // Returns a list of pending two-phase-commit transactions.\n  //---------------------------------------------------------------------------\n  async tpcRecover(asString) {\n    errors.assertArgCount(arguments, 0, 1);\n\n    if (arguments.length == 1) {\n      errors.assertParamValue(typeof asString === 'boolean', 1);\n    } else {\n      asString = true;\n    }\n\n    const sqlStr = `\n      SELECT\n          formatid as \"formatId\",\n          UTL_RAW.CAST_TO_VARCHAR2(globalid) as \"globalTransactionId\",\n          UTL_RAW.CAST_TO_VARCHAR2(branchid) as \"branchQualifier\"\n      FROM DBA_PENDING_TRANSACTIONS`;\n    const sqlBuf = `\n      SELECT\n          formatid as \"formatId\",\n          globalid as \"globalTransactionId\",\n          branchid as \"branchQualifier\"\n      FROM DBA_PENDING_TRANSACTIONS`;\n    const options = {\n      outFormat: constants.OUT_FORMAT_OBJECT,\n      resultSet: false\n    };\n\n    const result = await this.execute(asString ? sqlStr : sqlBuf, {}, options);\n    return result.rows;\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcRollback()\n  //\n  // Rolls back the current changes in a two-phase-commit transaction.\n  //---------------------------------------------------------------------------\n  async tpcRollback(xid) {\n    errors.assertArgCount(arguments, 0, 1);\n    if (arguments.length == 1) {\n      errors.assertParamValue(nodbUtil.isXid(xid), 1);\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n\n    await this._impl.tpcRollback(xid);\n  }\n\n  //---------------------------------------------------------------------------\n  // unsubscribe()\n  //\n  // Destroy a subscription which was earlier created using subscribe().\n  //---------------------------------------------------------------------------\n  async unsubscribe(name) {\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(typeof name === 'string', 1);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    errors.assert(_subscriptions.has(name), errors.ERR_INVALID_SUBSCR);\n    await this._impl.unsubscribe(_subscriptions.get(name));\n    _subscriptions.delete(name);\n  }\n\n}\n\n// adjust functions to support the old callback style and to serialize calls\n// that cannot take place concurrently\n// NOTE: breakExecution() should not be serialized\nConnection.prototype.break =\n    nodbUtil.callbackify(Connection.prototype.breakExecution);\nnodbUtil.wrapFns(Connection.prototype,\n  \"changePassword\",\n  \"close\",\n  \"commit\",\n  \"createLob\",\n  \"execute\",\n  \"executeMany\",\n  \"getDbObjectClass\",\n  \"getQueue\",\n  \"getStatementInfo\",\n  \"ping\",\n  \"rollback\",\n  \"shutdown\",\n  \"startup\",\n  \"subscribe\",\n  \"tpcBegin\",\n  \"tpcCommit\",\n  \"tpcEnd\",\n  \"tpcForget\",\n  \"tpcPrepare\",\n  \"tpcRecover\",\n  \"tpcRollback\",\n  \"unsubscribe\");\n\n// add alias for release()\nConnection.prototype.release = Connection.prototype.close;\n\n// export just the Connection class\nmodule.exports = Connection;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}