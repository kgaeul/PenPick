{"ast":null,"code":"// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst {\n  BaseBuffer\n} = require('./buffer.js');\nconst {\n  Buffer\n} = require('buffer');\nconst constants = require(\"./constants.js\");\nconst oson = require('./oson.js');\nconst utils = require('./utils.js');\nconst errors = require(\"../../errors.js\");\nconst TNS_BASE64_ALPHABET_ARRAY = Buffer.from(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", 'utf8');\n\n/**\n * Class used for byte chunks used in the ChunkedBytesBuffer.\n */\nclass BytesChunk {\n  /**\n   * Constructor.\n   * @param {Number} number of bytes to add to the chunk (rounded to the\n   * nearest chunk size to avoid unnecessary allocations and copies)\n   */\n  constructor(numBytes) {\n    this.allocLen = numBytes;\n    const remainder = numBytes % constants.CHUNKED_BYTES_CHUNK_SIZE;\n    if (remainder > 0) {\n      this.allocLen += constants.CHUNKED_BYTES_CHUNK_SIZE - remainder;\n    }\n    this.buf = Buffer.allocUnsafe(this.allocLen);\n    this.actualLen = 0;\n  }\n}\n\n/**\n * Class used for handling chunked reads.\n */\nclass ChunkedBytesBuffer {\n  /**\n   * Constructor.\n   */\n  constructor() {\n    this.chunks = [];\n  }\n\n  /**\n   * End the chunked read and return a consolidated buffer.\n   */\n  endChunkedRead() {\n    if (this.chunks.length > 1) {\n      let totalNumBytes = 0;\n      for (const chunk of this.chunks) {\n        totalNumBytes += chunk.actualLen;\n      }\n      let pos = 0;\n      const consolidatedChunk = new BytesChunk(totalNumBytes);\n      for (const chunk of this.chunks) {\n        chunk.buf.copy(consolidatedChunk.buf, pos, 0, chunk.actualLen);\n        pos += chunk.actualLen;\n      }\n      consolidatedChunk.actualLen = totalNumBytes;\n      this.chunks = [consolidatedChunk];\n    }\n    const chunk = this.chunks[0];\n    return chunk.buf.subarray(0, chunk.actualLen);\n  }\n\n  /**\n   * Constructor.\n   */\n  getBuf(numBytes) {\n    let chunk;\n    if (this.chunks.length > 0) {\n      chunk = this.chunks[this.chunks.length - 1];\n      if (chunk.allocLen - chunk.actualLen < numBytes) {\n        chunk = undefined;\n      }\n    }\n    if (!chunk) {\n      chunk = new BytesChunk(numBytes);\n      this.chunks.push(chunk);\n    }\n    const buf = chunk.buf.subarray(chunk.actualLen, chunk.actualLen + numBytes);\n    chunk.actualLen += numBytes;\n    return buf;\n  }\n\n  /**\n   * Start a chunked read. This ensures that only one chunk is available and\n   * its actual length is set to zero.\n   */\n  startChunkedRead() {\n    if (this.chunks.length > 0) {\n      this.chunks = this.chunks.splice(0, 1);\n      this.chunks[0].actualLen = 0;\n    }\n  }\n}\n\n/**\n * Encapsulates the Network Read Buffer\n *\n * @class ReadPacket\n */\n\nclass ReadPacket extends BaseBuffer {\n  /**\n   * Constructor.\n   * @param {Object} adapter used for sending/receiving data\n   * @param {Object} capabilities\n   */\n\n  constructor(nsi, caps) {\n    super();\n    this.nsi = nsi;\n    this.caps = caps;\n    this.chunkedBytesBuf = new ChunkedBytesBuffer();\n  }\n\n  /**\n   * Helper function that processes the length. If the length is defined as\n   * TNS_LONG_LENGTH_INDICATOR, a chunked read is performed.\n   */\n  _readBytesWithLength(numBytes) {\n    if (numBytes !== constants.TNS_LONG_LENGTH_INDICATOR) {\n      return this.readBytes(numBytes);\n    }\n    this.chunkedBytesBuf.startChunkedRead();\n    while (true) {\n      // eslint-disable-line\n      const numBytesInChunk = this.readUB4();\n      if (numBytesInChunk === 0) {\n        break;\n      }\n      this.readBytes(numBytesInChunk, true);\n    }\n    return this.chunkedBytesBuf.endChunkedRead();\n  }\n  skipBytes(numBytes) {\n    // if no bytes are left in the buffer, a new packet needs to be fetched\n    // before anything else can take place\n    if (this.pos === this.size) {\n      this.receivePacket();\n    }\n\n    // if there is enough room in the buffer to satisfy the number of bytes\n    // requested, return the buffer directly\n    const numBytesLeft = this.numBytesLeft();\n    if (numBytes <= numBytesLeft) {\n      this.pos += numBytes;\n      return;\n    }\n    numBytes -= numBytesLeft;\n\n    // acquire packets until the requested number of bytes is satisfied\n    while (numBytes > 0) {\n      this.receivePacket();\n      const numSplitBytes = Math.min(numBytes, this.size - this.pos);\n      this.pos += numSplitBytes;\n      numBytes -= numSplitBytes;\n    }\n  }\n\n  /**\n   * Returns a buffer containing the specified number of bytes. If an\n   * insufficient number of bytes are available, a new packet is read.\n   * @param {Number} specifies the number of bytes to read from the buffer\n   */\n  readBytes(numBytes, inChunkedRead = false) {\n    // if no bytes are left in the buffer, a new packet needs to be fetched\n    // before anything else can take place\n    if (this.pos === this.size) {\n      this.receivePacket();\n    }\n\n    // if there is enough room in the buffer to satisfy the number of bytes\n    // requested, return the buffer directly\n    const numBytesLeft = this.numBytesLeft();\n    if (numBytes <= numBytesLeft) {\n      let buf;\n      if (inChunkedRead) {\n        buf = this.chunkedBytesBuf.getBuf(numBytes);\n        this.buf.copy(buf, 0, this.pos, this.pos + numBytes);\n      } else {\n        buf = this.buf.subarray(this.pos, this.pos + numBytes);\n      }\n      this.pos += numBytes;\n      return buf;\n    }\n\n    // the requested bytes are split across multiple packets; if a chunked read\n    // is in progress, a chunk is acquired that will accommodate the requested\n    // bytes; otherwise, a separate buffer will be allocated to accommodate the\n    // requested bytes\n    let buf;\n    if (inChunkedRead) {\n      buf = this.chunkedBytesBuf.getBuf(numBytes);\n    } else {\n      buf = Buffer.allocUnsafe(numBytes);\n    }\n\n    // copy the bytes to the buffer from the remainder of this packet\n    let offset = 0;\n    this.buf.copy(buf, offset, this.pos, this.pos + numBytesLeft);\n    offset += numBytesLeft;\n    numBytes -= numBytesLeft;\n\n    // acquire packets until the requested number of bytes is satisfied\n    while (numBytes > 0) {\n      this.receivePacket();\n      const numSplitBytes = Math.min(numBytes, this.size - this.pos);\n      this.buf.copy(buf, offset, this.pos, this.pos + numSplitBytes);\n      this.pos += numSplitBytes;\n      offset += numSplitBytes;\n      numBytes -= numSplitBytes;\n    }\n    return buf;\n  }\n\n  /**\n   * Receives a packet from the adapter.\n   */\n  receivePacket() {\n    if (this.savedPacketPos === this.savedPackets.length) {\n      const packet = this.nsi.syncRecvPacket();\n      if (!packet || this.nsi.isBreak) throw new utils.OutOfPacketsError();\n      this.savedPackets.push(packet);\n    }\n    this.startPacket(this.savedPackets[this.savedPacketPos++]);\n  }\n  restorePoint() {\n    this.savedPacketPos = 0;\n    this.startPacket(this.savedPackets[this.savedPacketPos++]);\n    this.pos = this.savedPos;\n  }\n  savePoint() {\n    if (this.savedPackets) {\n      this.savedPackets = this.savedPackets.splice(this.savedPacketPos - 1);\n    } else {\n      this.savedPackets = [this.packet];\n    }\n    this.savedPacketPos = 1;\n    this.savedPos = this.pos;\n  }\n  startPacket(packet) {\n    this.packet = packet;\n    this.buf = packet.buf;\n    this.pos = 10; // skip packet heaader and data flags\n    this.size = packet.buf.length;\n    this.packetNum = packet.num;\n  }\n  async waitForPackets() {\n    const packet = await this.nsi.recvPacket();\n    if (!this.savedPackets) {\n      this.savedPackets = [packet];\n      this.savedPacketPos = 0;\n    } else {\n      this.savedPackets.push(packet);\n    }\n    this.startPacket(this.savedPackets[this.savedPacketPos++]);\n  }\n\n  /**\n   * Reads OSON (QLocator followed by data) and decodes it into a JavaScript\n   * object.\n   */\n  readOson() {\n    const numBytes = this.readUB4();\n    if (numBytes === 0) {\n      return null;\n    }\n    this.skipUB8(); // size (unused)\n    this.skipUB4(); // chunk size (unused)\n    const decoder = new oson.OsonDecoder(this.readBytesWithLength());\n    this.skipBytesChunked(); // locator (unused)\n    return decoder.decode();\n  }\n  readURowID() {\n    let outputOffset = 0,\n      inputOffset = 1;\n    let buf = this.readBytesWithLength();\n    if (buf === null) return null;\n    buf = this.readBytesWithLength();\n    let inputLen = buf.length;\n\n    // Handle physical rowid\n    if (buf && buf[0] === 1) {\n      const rba = buf.readUInt32BE(1);\n      const partitionID = buf.readUInt16BE(5);\n      const blockNum = buf.readUInt32BE(7);\n      const slotNum = buf.readUInt16BE(11);\n      return utils.encodeRowID({\n        rba,\n        partitionID,\n        blockNum,\n        slotNum\n      });\n    }\n\n    // handle logical rowid\n    let outputLen = Math.floor(inputLen / 3) * 4;\n    const remainder = inputLen % 3;\n    if (remainder === 1) {\n      outputLen += 1;\n    } else if (remainder === 2) {\n      outputLen += 3;\n    }\n    const outputValue = Buffer.allocUnsafe(outputLen);\n    inputLen -= 1;\n    outputValue[0] = 42;\n    outputOffset += 1;\n    while (inputLen > 0) {\n      // produce first byte of quadruple\n      let pos = buf[inputOffset] >> 2;\n      outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];\n      outputOffset += 1;\n\n      // produce second byte of quadruple, but if only one byte is left,\n      // produce that one byte and exit\n      pos = (buf[inputOffset] & 0x3) << 4;\n      if (inputLen == 1) {\n        outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];\n        break;\n      }\n      inputOffset += 1;\n      pos |= (buf[inputOffset] & 0xf0) >> 4;\n      outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];\n      outputOffset += 1;\n\n      // produce third byte of quadruple, but if only two bytes are left,\n      // produce that one byte and exit\n      pos = (buf[inputOffset] & 0xf) << 2;\n      if (inputLen == 2) {\n        outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];\n        break;\n      }\n      inputOffset += 1;\n      pos |= (buf[inputOffset] & 0xc0) >> 6;\n      outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];\n      outputOffset += 1;\n\n      // produce final byte of quadruple\n      pos = buf[inputOffset] & 0x3f;\n      outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];\n      outputOffset += 1;\n      inputOffset += 1;\n      inputLen -= 3;\n    }\n    return outputValue.toString('utf-8');\n  }\n  readRowID() {\n    const rba = this.readUB4();\n    const partitionID = this.readUB2();\n    this.skipUB1();\n    const blockNum = this.readUB4();\n    const slotNum = this.readUB2();\n    return {\n      rba,\n      partitionID,\n      blockNum,\n      slotNum\n    };\n  }\n  skipBytesChunked() {\n    const numBytes = this.readUInt8();\n    if (numBytes === 0 || numBytes === constants.TNS_NULL_LENGTH_INDICATOR) {\n      return;\n    }\n    if (numBytes !== constants.TNS_LONG_LENGTH_INDICATOR) {\n      this.skipBytes(numBytes);\n    } else {\n      while (true) {\n        // eslint-disable-line\n        const tempNumBytes = this.readUB4();\n        if (tempNumBytes === 0) break;\n        this.skipBytes(tempNumBytes);\n      }\n    }\n  }\n  readNullTerminatedBytes(maxSize = 50) {\n    let offset = 0;\n    const tmp = Buffer.allocUnsafe(maxSize);\n    while (offset < maxSize) {\n      tmp[offset] = this.readUInt8();\n      if (tmp[offset] === 0) {\n        break;\n      }\n      offset = offset + 1;\n    }\n    if (offset === maxSize) {\n      const reason = `Byte Arrray Exceeded MaxSize ${maxSize}`;\n      errors.throwErr(errors.ERR_INTERNAL, reason);\n    }\n    return tmp.subarray(0, offset + 1);\n  }\n}\n\n/**\n * Encapsulates the Network Write Buffer\n *\n * @class WritePacket\n */\nclass WritePacket extends BaseBuffer {\n  constructor(nsi, caps, protocol) {\n    super(nsi.sAtts.sdu);\n    this.size = this.maxSize;\n    this.isLargeSDU = nsi.sAtts.version >= constants.TNS_VERSION_MIN_LARGE_SDU;\n    this.protocol = protocol;\n    this.packetType = constants.TNS_PACKET_TYPE_DATA;\n    this.caps = caps;\n    this.nsi = nsi;\n  }\n\n  /**\n   * Grows the buffer by sending the existing buffer on the transport. A copy\n   * is made so that the existing buffer can be used for the next batch of data\n   * that needs to be sent\n   */\n  _grow() {\n    this._sendPacket();\n  }\n\n  /**\n   * Sends the data in the buffer on the transport. First, the packet header is\n   * set up by writing the size and packet type.\n   */\n  _sendPacket(finalPacket = false) {\n    const size = this.pos;\n    this.pos = 0;\n    if (this.isLargeSDU) {\n      this.writeUInt32BE(size);\n    } else {\n      this.writeUInt16BE(size);\n      this.writeUInt16BE(0);\n    }\n    this.writeUInt8(this.packetType);\n    this.writeUInt8(0);\n    this.writeUInt16BE(0);\n    let buf = this.buf.subarray(0, size);\n    if (!finalPacket) {\n      buf = Buffer.from(buf);\n      this.startPacket();\n    }\n    this.nsi.ntAdapter.send(buf);\n  }\n\n  /**\n   * Starts a packet.\n   */\n  startPacket(dataFlags = 0) {\n    this.pos = constants.PACKET_HEADER_SIZE;\n    if (this.packetType === constants.TNS_PACKET_TYPE_DATA) {\n      this.writeUInt16BE(dataFlags);\n    }\n  }\n\n  /**\n   * Starts a database request.\n   */\n  startRequest(packetType, dataFlags = 0) {\n    this.packetType = packetType;\n    this.startPacket(dataFlags);\n  }\n\n  /**\n   * Ends a database request.\n   */\n  endRequest() {\n    if (this.pos > constants.PACKET_HEADER_SIZE) {\n      this._sendPacket(true);\n    }\n  }\n  writeKeyValue(key, value, flags = 0) {\n    const keyBytesLen = Buffer.byteLength(key);\n    const valBytesLen = Buffer.byteLength(value);\n    this.writeUB4(keyBytesLen);\n    this.writeBytesWithLength(Buffer.from(key));\n    this.writeUB4(valBytesLen);\n    if (valBytesLen > 0) {\n      this.writeBytesWithLength(Buffer.from(value));\n    }\n    this.writeUB4(flags);\n  }\n\n  /**\n   * Encodes a JavaScript object into OSON and then writes it (QLocator\n   * followed by data) to the buffer.\n   */\n  writeOson(value) {\n    const encoder = new oson.OsonEncoder();\n    const buf = encoder.encode(value);\n    this.writeQLocator(buf.length);\n    this.writeBytesWithLength(buf);\n  }\n  writeSeqNum() {\n    this.writeUInt8(this.protocol.sequenceId);\n    this.protocol.sequenceId = (this.protocol.sequenceId + 1) % 256;\n  }\n}\nmodule.exports = {\n  ReadPacket,\n  WritePacket\n};","map":{"version":3,"names":["BaseBuffer","require","Buffer","constants","oson","utils","errors","TNS_BASE64_ALPHABET_ARRAY","from","BytesChunk","constructor","numBytes","allocLen","remainder","CHUNKED_BYTES_CHUNK_SIZE","buf","allocUnsafe","actualLen","ChunkedBytesBuffer","chunks","endChunkedRead","length","totalNumBytes","chunk","pos","consolidatedChunk","copy","subarray","getBuf","undefined","push","startChunkedRead","splice","ReadPacket","nsi","caps","chunkedBytesBuf","_readBytesWithLength","TNS_LONG_LENGTH_INDICATOR","readBytes","numBytesInChunk","readUB4","skipBytes","size","receivePacket","numBytesLeft","numSplitBytes","Math","min","inChunkedRead","offset","savedPacketPos","savedPackets","packet","syncRecvPacket","isBreak","OutOfPacketsError","startPacket","restorePoint","savedPos","savePoint","packetNum","num","waitForPackets","recvPacket","readOson","skipUB8","skipUB4","decoder","OsonDecoder","readBytesWithLength","skipBytesChunked","decode","readURowID","outputOffset","inputOffset","inputLen","rba","readUInt32BE","partitionID","readUInt16BE","blockNum","slotNum","encodeRowID","outputLen","floor","outputValue","toString","readRowID","readUB2","skipUB1","readUInt8","TNS_NULL_LENGTH_INDICATOR","tempNumBytes","readNullTerminatedBytes","maxSize","tmp","reason","throwErr","ERR_INTERNAL","WritePacket","protocol","sAtts","sdu","isLargeSDU","version","TNS_VERSION_MIN_LARGE_SDU","packetType","TNS_PACKET_TYPE_DATA","_grow","_sendPacket","finalPacket","writeUInt32BE","writeUInt16BE","writeUInt8","ntAdapter","send","dataFlags","PACKET_HEADER_SIZE","startRequest","endRequest","writeKeyValue","key","value","flags","keyBytesLen","byteLength","valBytesLen","writeUB4","writeBytesWithLength","writeOson","encoder","OsonEncoder","encode","writeQLocator","writeSeqNum","sequenceId","module","exports"],"sources":["C:/Users/user1/Desktop/finalproject_penpick/node_modules/oracledb/lib/thin/protocol/packet.js"],"sourcesContent":["// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst { BaseBuffer } = require('./buffer.js');\nconst { Buffer } = require('buffer');\nconst constants = require(\"./constants.js\");\nconst oson = require('./oson.js');\nconst utils = require('./utils.js');\nconst errors = require(\"../../errors.js\");\n\nconst TNS_BASE64_ALPHABET_ARRAY = Buffer.from(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", 'utf8');\n\n/**\n * Class used for byte chunks used in the ChunkedBytesBuffer.\n */\nclass BytesChunk {\n\n  /**\n   * Constructor.\n   * @param {Number} number of bytes to add to the chunk (rounded to the\n   * nearest chunk size to avoid unnecessary allocations and copies)\n   */\n  constructor(numBytes) {\n    this.allocLen = numBytes;\n    const remainder = numBytes % constants.CHUNKED_BYTES_CHUNK_SIZE;\n    if (remainder > 0) {\n      this.allocLen += (constants.CHUNKED_BYTES_CHUNK_SIZE - remainder);\n    }\n    this.buf = Buffer.allocUnsafe(this.allocLen);\n    this.actualLen = 0;\n  }\n\n}\n\n\n/**\n * Class used for handling chunked reads.\n */\nclass ChunkedBytesBuffer {\n\n  /**\n   * Constructor.\n   */\n  constructor() {\n    this.chunks = [];\n  }\n\n  /**\n   * End the chunked read and return a consolidated buffer.\n   */\n  endChunkedRead() {\n    if (this.chunks.length > 1) {\n      let totalNumBytes = 0;\n      for (const chunk of this.chunks) {\n        totalNumBytes += chunk.actualLen;\n      }\n      let pos = 0;\n      const consolidatedChunk = new BytesChunk(totalNumBytes);\n      for (const chunk of this.chunks) {\n        chunk.buf.copy(consolidatedChunk.buf, pos, 0, chunk.actualLen);\n        pos += chunk.actualLen;\n      }\n      consolidatedChunk.actualLen = totalNumBytes;\n      this.chunks = [consolidatedChunk];\n    }\n    const chunk = this.chunks[0];\n    return chunk.buf.subarray(0, chunk.actualLen);\n  }\n\n  /**\n   * Constructor.\n   */\n  getBuf(numBytes) {\n    let chunk;\n    if (this.chunks.length > 0) {\n      chunk = this.chunks[this.chunks.length - 1];\n      if (chunk.allocLen - chunk.actualLen < numBytes) {\n        chunk = undefined;\n      }\n    }\n    if (!chunk) {\n      chunk = new BytesChunk(numBytes);\n      this.chunks.push(chunk);\n    }\n    const buf = chunk.buf.subarray(chunk.actualLen,\n      chunk.actualLen + numBytes);\n    chunk.actualLen += numBytes;\n    return buf;\n  }\n\n  /**\n   * Start a chunked read. This ensures that only one chunk is available and\n   * its actual length is set to zero.\n   */\n  startChunkedRead() {\n    if (this.chunks.length > 0) {\n      this.chunks = this.chunks.splice(0, 1);\n      this.chunks[0].actualLen = 0;\n    }\n  }\n\n}\n\n\n/**\n * Encapsulates the Network Read Buffer\n *\n * @class ReadPacket\n */\n\nclass ReadPacket extends BaseBuffer {\n\n  /**\n   * Constructor.\n   * @param {Object} adapter used for sending/receiving data\n   * @param {Object} capabilities\n   */\n\n  constructor(nsi, caps) {\n    super();\n    this.nsi = nsi;\n    this.caps = caps;\n    this.chunkedBytesBuf = new ChunkedBytesBuffer();\n  }\n\n  /**\n   * Helper function that processes the length. If the length is defined as\n   * TNS_LONG_LENGTH_INDICATOR, a chunked read is performed.\n   */\n  _readBytesWithLength(numBytes) {\n    if (numBytes !== constants.TNS_LONG_LENGTH_INDICATOR) {\n      return this.readBytes(numBytes);\n    }\n    this.chunkedBytesBuf.startChunkedRead();\n    while (true) { // eslint-disable-line\n      const numBytesInChunk = this.readUB4();\n      if (numBytesInChunk === 0) {\n        break;\n      }\n      this.readBytes(numBytesInChunk, true);\n    }\n    return this.chunkedBytesBuf.endChunkedRead();\n  }\n\n  skipBytes(numBytes) {\n\n    // if no bytes are left in the buffer, a new packet needs to be fetched\n    // before anything else can take place\n    if (this.pos === this.size) {\n      this.receivePacket();\n    }\n\n    // if there is enough room in the buffer to satisfy the number of bytes\n    // requested, return the buffer directly\n    const numBytesLeft = this.numBytesLeft();\n    if (numBytes <= numBytesLeft) {\n      this.pos += numBytes;\n      return;\n    }\n    numBytes -= numBytesLeft;\n\n    // acquire packets until the requested number of bytes is satisfied\n    while (numBytes > 0) {\n      this.receivePacket();\n      const numSplitBytes = Math.min(numBytes, this.size - this.pos);\n      this.pos += numSplitBytes;\n      numBytes -= numSplitBytes;\n    }\n  }\n\n  /**\n   * Returns a buffer containing the specified number of bytes. If an\n   * insufficient number of bytes are available, a new packet is read.\n   * @param {Number} specifies the number of bytes to read from the buffer\n   */\n  readBytes(numBytes, inChunkedRead = false) {\n\n    // if no bytes are left in the buffer, a new packet needs to be fetched\n    // before anything else can take place\n    if (this.pos === this.size) {\n      this.receivePacket();\n    }\n\n    // if there is enough room in the buffer to satisfy the number of bytes\n    // requested, return the buffer directly\n    const numBytesLeft = this.numBytesLeft();\n    if (numBytes <= numBytesLeft) {\n      let buf;\n      if (inChunkedRead) {\n        buf = this.chunkedBytesBuf.getBuf(numBytes);\n        this.buf.copy(buf, 0, this.pos, this.pos + numBytes);\n      } else {\n        buf = this.buf.subarray(this.pos, this.pos + numBytes);\n      }\n      this.pos += numBytes;\n      return buf;\n    }\n\n    // the requested bytes are split across multiple packets; if a chunked read\n    // is in progress, a chunk is acquired that will accommodate the requested\n    // bytes; otherwise, a separate buffer will be allocated to accommodate the\n    // requested bytes\n    let buf;\n    if (inChunkedRead) {\n      buf = this.chunkedBytesBuf.getBuf(numBytes);\n    } else {\n      buf = Buffer.allocUnsafe(numBytes);\n    }\n\n    // copy the bytes to the buffer from the remainder of this packet\n    let offset = 0;\n    this.buf.copy(buf, offset, this.pos, this.pos + numBytesLeft);\n    offset += numBytesLeft;\n    numBytes -= numBytesLeft;\n\n    // acquire packets until the requested number of bytes is satisfied\n    while (numBytes > 0) {\n      this.receivePacket();\n      const numSplitBytes = Math.min(numBytes, this.size - this.pos);\n      this.buf.copy(buf, offset, this.pos, this.pos + numSplitBytes);\n      this.pos += numSplitBytes;\n      offset += numSplitBytes;\n      numBytes -= numSplitBytes;\n    }\n\n    return buf;\n\n  }\n\n  /**\n   * Receives a packet from the adapter.\n   */\n  receivePacket() {\n    if (this.savedPacketPos === this.savedPackets.length) {\n      const packet = this.nsi.syncRecvPacket();\n      if (!packet || this.nsi.isBreak)\n        throw new utils.OutOfPacketsError();\n      this.savedPackets.push(packet);\n    }\n    this.startPacket(this.savedPackets[this.savedPacketPos++]);\n  }\n\n  restorePoint() {\n    this.savedPacketPos = 0;\n    this.startPacket(this.savedPackets[this.savedPacketPos++]);\n    this.pos = this.savedPos;\n  }\n\n  savePoint() {\n    if (this.savedPackets) {\n      this.savedPackets = this.savedPackets.splice(this.savedPacketPos - 1);\n    } else {\n      this.savedPackets = [this.packet];\n    }\n    this.savedPacketPos = 1;\n    this.savedPos = this.pos;\n  }\n\n  startPacket(packet) {\n    this.packet = packet;\n    this.buf = packet.buf;\n    this.pos = 10;                      // skip packet heaader and data flags\n    this.size = packet.buf.length;\n    this.packetNum = packet.num;\n  }\n\n  async waitForPackets() {\n    const packet = await this.nsi.recvPacket();\n    if (!this.savedPackets) {\n      this.savedPackets = [packet];\n      this.savedPacketPos = 0;\n    } else {\n      this.savedPackets.push(packet);\n    }\n    this.startPacket(this.savedPackets[this.savedPacketPos++]);\n  }\n\n  /**\n   * Reads OSON (QLocator followed by data) and decodes it into a JavaScript\n   * object.\n   */\n  readOson() {\n    const numBytes = this.readUB4();\n    if (numBytes === 0) {\n      return null;\n    }\n    this.skipUB8();                     // size (unused)\n    this.skipUB4();                     // chunk size (unused)\n    const decoder = new oson.OsonDecoder(this.readBytesWithLength());\n    this.skipBytesChunked();            // locator (unused)\n    return decoder.decode();\n  }\n\n  readURowID() {\n    let outputOffset = 0, inputOffset = 1;\n    let buf = this.readBytesWithLength();\n    if (buf === null)\n      return null;\n    buf = this.readBytesWithLength();\n    let inputLen = buf.length;\n\n    // Handle physical rowid\n    if (buf && buf[0] === 1) {\n      const rba = buf.readUInt32BE(1);\n      const partitionID = buf.readUInt16BE(5);\n      const blockNum = buf.readUInt32BE(7);\n      const slotNum = buf.readUInt16BE(11);\n      return utils.encodeRowID({rba, partitionID, blockNum, slotNum});\n    }\n\n    // handle logical rowid\n    let outputLen = Math.floor(inputLen / 3) * 4;\n    const remainder = inputLen % 3;\n    if (remainder === 1) {\n      outputLen += 1;\n    } else if (remainder === 2) {\n      outputLen += 3;\n    }\n\n    const outputValue =  Buffer.allocUnsafe(outputLen);\n    inputLen -= 1;\n    outputValue[0] = 42;\n    outputOffset += 1;\n    while (inputLen > 0) {\n      // produce first byte of quadruple\n      let pos = buf[inputOffset] >> 2;\n      outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];\n      outputOffset += 1;\n\n      // produce second byte of quadruple, but if only one byte is left,\n      // produce that one byte and exit\n      pos = (buf[inputOffset] & 0x3) << 4;\n      if (inputLen == 1) {\n        outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];\n        break;\n      }\n      inputOffset += 1;\n      pos |= ((buf[inputOffset] & 0xf0) >> 4);\n      outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];\n      outputOffset += 1;\n\n      // produce third byte of quadruple, but if only two bytes are left,\n      // produce that one byte and exit\n      pos = (buf[inputOffset] & 0xf) << 2;\n      if (inputLen == 2) {\n        outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];\n        break;\n      }\n      inputOffset += 1;\n      pos |= ((buf[inputOffset] & 0xc0) >> 6);\n      outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];\n      outputOffset += 1;\n\n      // produce final byte of quadruple\n      pos = buf[inputOffset] & 0x3f;\n      outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];\n      outputOffset += 1;\n      inputOffset += 1;\n      inputLen -= 3;\n    }\n    return outputValue.toString('utf-8');\n  }\n\n  readRowID() {\n    const rba = this.readUB4();\n    const partitionID = this.readUB2();\n    this.skipUB1();\n    const blockNum = this.readUB4();\n    const slotNum = this.readUB2();\n    return {rba, partitionID, blockNum, slotNum};\n  }\n\n  skipBytesChunked() {\n    const numBytes = this.readUInt8();\n    if (numBytes === 0 || numBytes === constants.TNS_NULL_LENGTH_INDICATOR) {\n      return;\n    }\n    if (numBytes !== constants.TNS_LONG_LENGTH_INDICATOR) {\n      this.skipBytes(numBytes);\n    } else {\n      while (true) { // eslint-disable-line\n        const tempNumBytes = this.readUB4();\n        if (tempNumBytes === 0)\n          break;\n        this.skipBytes(tempNumBytes);\n      }\n    }\n  }\n\n  readNullTerminatedBytes(maxSize = 50) {\n    let offset = 0;\n    const tmp = Buffer.allocUnsafe(maxSize);\n    while (offset < maxSize) {\n      tmp[offset] = this.readUInt8();\n      if (tmp[offset] === 0) {\n        break;\n      }\n      offset = offset + 1;\n    }\n    if (offset === maxSize) {\n      const reason = `Byte Arrray Exceeded MaxSize ${maxSize}`;\n      errors.throwErr(errors.ERR_INTERNAL, reason);\n    }\n    return tmp.subarray(0, offset + 1);\n  }\n\n}\n\n\n/**\n * Encapsulates the Network Write Buffer\n *\n * @class WritePacket\n */\nclass WritePacket extends BaseBuffer {\n\n  constructor(nsi, caps, protocol) {\n    super(nsi.sAtts.sdu);\n    this.size = this.maxSize;\n    this.isLargeSDU = nsi.sAtts.version >= constants.TNS_VERSION_MIN_LARGE_SDU;\n    this.protocol = protocol;\n    this.packetType = constants.TNS_PACKET_TYPE_DATA;\n    this.caps = caps;\n    this.nsi = nsi;\n  }\n\n  /**\n   * Grows the buffer by sending the existing buffer on the transport. A copy\n   * is made so that the existing buffer can be used for the next batch of data\n   * that needs to be sent\n   */\n  _grow() {\n    this._sendPacket();\n  }\n\n  /**\n   * Sends the data in the buffer on the transport. First, the packet header is\n   * set up by writing the size and packet type.\n   */\n  _sendPacket(finalPacket = false) {\n    const size = this.pos;\n    this.pos = 0;\n    if (this.isLargeSDU) {\n      this.writeUInt32BE(size);\n    } else {\n      this.writeUInt16BE(size);\n      this.writeUInt16BE(0);\n    }\n    this.writeUInt8(this.packetType);\n    this.writeUInt8(0);\n    this.writeUInt16BE(0);\n    let buf = this.buf.subarray(0, size);\n    if (!finalPacket) {\n      buf = Buffer.from(buf);\n      this.startPacket();\n    }\n    this.nsi.ntAdapter.send(buf);\n  }\n\n  /**\n   * Starts a packet.\n   */\n  startPacket(dataFlags = 0) {\n    this.pos = constants.PACKET_HEADER_SIZE;\n    if (this.packetType === constants.TNS_PACKET_TYPE_DATA) {\n      this.writeUInt16BE(dataFlags);\n    }\n  }\n\n  /**\n   * Starts a database request.\n   */\n  startRequest(packetType, dataFlags = 0) {\n    this.packetType = packetType;\n    this.startPacket(dataFlags);\n  }\n\n  /**\n   * Ends a database request.\n   */\n  endRequest() {\n    if (this.pos > constants.PACKET_HEADER_SIZE) {\n      this._sendPacket(true);\n    }\n  }\n\n  writeKeyValue(key, value, flags = 0) {\n    const keyBytesLen = Buffer.byteLength(key);\n    const valBytesLen = Buffer.byteLength(value);\n    this.writeUB4(keyBytesLen);\n    this.writeBytesWithLength(Buffer.from(key));\n    this.writeUB4(valBytesLen);\n    if (valBytesLen > 0) {\n      this.writeBytesWithLength(Buffer.from(value));\n    }\n    this.writeUB4(flags);\n  }\n\n  /**\n   * Encodes a JavaScript object into OSON and then writes it (QLocator\n   * followed by data) to the buffer.\n   */\n  writeOson(value) {\n    const encoder = new oson.OsonEncoder();\n    const buf = encoder.encode(value);\n    this.writeQLocator(buf.length);\n    this.writeBytesWithLength(buf);\n  }\n\n  writeSeqNum() {\n    this.writeUInt8(this.protocol.sequenceId);\n    this.protocol.sequenceId = (this.protocol.sequenceId + 1) % 256;\n  }\n\n}\n\nmodule.exports = {\n  ReadPacket,\n  WritePacket\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}