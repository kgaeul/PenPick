{"ast":null,"code":"// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst Packet = require(\"./packet.js\");\nconst NTTCP = require(\"./ntTcp.js\");\nconst SessionAtts = require(\"./sessionAtts.js\");\nconst constants = require(\"./constants.js\");\nconst {\n  createNode\n} = require('./connStrategy.js');\nconst errors = require(\"../../errors.js\");\nconst {\n  findNVPairRecurse,\n  createNVPair,\n  findValue\n} = require(\"./nvStrToNvPair.js\");\nconst {\n  Buffer\n} = require('buffer');\nconst EzConnect = require(\"./ezConnectResolver.js\");\nconst {\n  NLParamParser,\n  tnsnamesFilePath\n} = require(\"./paramParser.js\");\nconst process = require('process');\nconst downHostInstance = require(\"./connStrategy.js\").SOLE_INST_DHCACHE;\n/**\n *\n * @param {string} userConfig\n * @returns serverinfo\n */\n\nasync function getConnectionInfo(userConfig) {\n  const connStr = await resolveConnectStr(userConfig.connectString, userConfig.configDir);\n  const addressNode = await createNode(connStr);\n  let nvpair;\n  if (typeof connStr === 'string') nvpair = createNVPair(connStr);else nvpair = connStr; //Already a NVPair\n\n  const serverVal = findValue(nvpair, [\"DESCRIPTION\", \"CONNECT_DATA\", \"SERVER\"]);\n  const connClass = findValue(nvpair, [\"DESCRIPTION\", \"CONNECT_DATA\", \"POOL_CONNECTION_CLASS\"]);\n  const svcname = findValue(nvpair, [\"DESCRIPTION\", \"CONNECT_DATA\", \"SERVICE_NAME\"]);\n  const sid = findValue(nvpair, [\"DESCRIPTION\", \"CONNECT_DATA\", \"SID\"]);\n  const poolPurity = findValue(nvpair, [\"DESCRIPTION\", \"CONNECT_DATA\", \"POOL_PURITY\"]);\n  return [serverVal, connClass, svcname, poolPurity, sid, addressNode];\n}\n\n/**\n * Resolve the connect string to a NV format address\n * @param {String} connStr Connect string\n * @returns AddressNode\n */\nconst nlParamParser = new NLParamParser();\nasync function resolveConnectStr(connectString, configDir) {\n  const connStr = connectString.trim();\n  let resolvedVal = connStr;\n  if (connStr.indexOf(')') == -1 || connStr.indexOf('(') != 0) {\n    if (connStr.indexOf(':') != -1 || connStr.indexOf('/') != -1) {\n      const ezcnObj = new EzConnect(connStr);\n      resolvedVal = ezcnObj.getResolvedUrl();\n      return resolvedVal;\n    } else {\n      //try tns alias\n      const namesFilePath = tnsnamesFilePath(configDir);\n      const p = await nlParamParser.initializeNlpa(namesFilePath);\n      resolvedVal = p.get(connStr.toUpperCase());\n      if (!resolvedVal) errors.throwErr(errors.ERR_TNS_ENTRY_NOT_FOUND, connStr, configDir ? configDir + '/tnsnames.ora' : process.env.TNS_ADMIN + '/tnsnames.ora');\n      resolvedVal = resolvedVal.getListElement(0);\n    }\n  }\n  return resolvedVal;\n}\nasync function resolveAddress(connStr, configDir) {\n  const connstr = await resolveConnectStr(connStr, configDir);\n  return createNode(connstr);\n}\n\n/**\n   * Timeout function\n   * @param {Promise} asyncPromise input promise\n   * @param {int} timeVal timeout value\n   * @returns resolved value of input promise\n   */\nfunction timeout(asyncPromise, timeVal, oper, address, connID) {\n  let timer;\n  const timeoutPromise = new Promise((resolve, reject) => {\n    // max possible value for 32-bit integer\n    if (timeVal > 2147483647) timeVal = 2147483647;\n    timer = setTimeout(() => reject(errors.getErr(errors.ERR_CONNECTION_TIMEDOUT, address.host, address.port, oper, timeVal / 1000, connID)), timeVal);\n  });\n  return Promise.race([asyncPromise, timeoutPromise]).then(result => {\n    clearTimeout(timer);\n    return result;\n  }).catch(err => {\n    clearTimeout(timer);\n    throw err;\n  });\n}\n\n/**\n * Network Session. This will be used for communication with the server.\n * @param {object} userConfig Connection options\n */\nclass NetworkSession {\n  constructor() {\n    this.connected = false;\n    this.isBreak = false;\n    this.isReset = false;\n    this.breakPosted = false;\n  }\n  async getAddress(addressNode, userConfig) {\n    /* Get the next address */\n    const address = await addressNode.execute(userConfig);\n    /* Prepare connection attributes */\n    const uuid = this.sAtts ? this.sAtts.uuid : null;\n    this.sAtts = new SessionAtts(uuid);\n    this.sAtts.setFrom(userConfig);\n    this.sAtts.setFrom(address.desc.params); /* Resolve attributes from Connect String */\n    await this.sAtts.prepare(address.protocol);\n\n    /* Insert Connection ID */\n    const rootNVPair = createNVPair(address.CNdata.join(\"\"));\n    const cdataNVPair = findNVPairRecurse(rootNVPair, \"CONNECT_DATA\");\n    const connidStr = `(CONNECTION_ID=${this.sAtts.connectionId})`;\n    const childNVPair = createNVPair(connidStr);\n    cdataNVPair.addListElement(childNVPair);\n    this.cData = Buffer.from(rootNVPair.toString(), 'ascii');\n    this.cDataNVPair = rootNVPair;\n    this.sAtts.nt.cDataNVPair = rootNVPair;\n    return address;\n  }\n\n  /**\n   * Make the transport level connection\n   */\n  async transportConnect(address) {\n    if (address.protocol.toUpperCase() == 'TCP' && address.httpsProxy) {\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_PARAMETERS, 'https proxy requires protocol as', 'tcps ');\n    }\n    if (address.protocol && (address.protocol.toUpperCase() == 'TCP' || address.protocol.toUpperCase() == 'TCPS')) {\n      this.ntAdapter = new NTTCP(this.sAtts.nt);\n    } else {\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_PARAMETERS, address.protocol + \" protocol not supported\");\n    }\n    await this.ntAdapter.connect(address);\n    this.ntAdapter.startRead();\n    this.sAtts.ntCha = this.ntAdapter.cha;\n    this.sndDatapkt = new Packet.DataPacket(this.sAtts.largeSDU);\n    this.rcvDatapkt = new Packet.DataPacket(this.sAtts.largeSDU);\n  }\n\n  /**\n   * Send the NSPTCN(connect) packet\n   * @param {object} connectPkt Connect Packet\n   */\n  _sendConnect(connectPkt) {\n    this._sendPacket(connectPkt.buf);\n    if (connectPkt.overflow) {\n      this._send(connectPkt.connectData, 0, connectPkt.connectDataLen);\n      this.flush();\n    }\n  }\n\n  /**\n   * Establish network session .Make transport level connection, send NSPTCN(connect packet) and read the response.\n   * @returns NetError.(connection successfully established(NetError.CONNECTED) or reason for failure)\n   */\n  async connect2(address) {\n    /* Sanitise SDU */\n    if (this.sAtts.sdu) {\n      if (this.sAtts.sdu > constants.NSPABSSDULN) {\n        this.sAtts.sdu = constants.NSPABSSDULN;\n      } else if (this.sAtts.sdu < constants.NSPMNSDULN) {\n        this.sAtts.sdu = constants.NSPMNSDULN;\n      }\n    } else {\n      this.sAtts.sdu = constants.NSPDFSDULN;\n    }\n\n    /* Transport connect */\n    if (this.sAtts.transportConnectTimeout) {\n      const asyncPromise = this.transportConnect(address);\n      await timeout(asyncPromise, this.sAtts.transportConnectTimeout, \"transportConnectTimeout\", address, this.sAtts.connectionId);\n    } else {\n      await this.transportConnect(address);\n    }\n\n    /* Send the connect packet */\n    let connectPkt = new Packet.ConnectPacket(this.cData, this.sAtts);\n    this._sendConnect(connectPkt);\n\n    /* Read the response */\n    while (true) {\n      // eslint-disable-line\n      const packet = await this._recvPacket();\n      if (packet.type === constants.NSPTAC) /* ACCEPT */\n        break;\n      if (packet.type === constants.NSPTRF) {\n        /* REFUSE */\n        if (this.refusePkt.overflow) {\n          await this._recvPacket();\n          this.refusePkt.dataBuf = this.rcvDatapkt.buf.subarray(this.rcvDatapkt.offset, this.rcvDatapkt.len).toString();\n        }\n        const nvpair = createNVPair(this.refusePkt.dataBuf);\n        this.refusePkt = null;\n        const err = findValue(nvpair, [\"DESCRIPTION\", \"ERR\"]);\n        if (err == \"12514\") {\n          errors.throwErr(errors.ERR_INVALID_SERVICE_NAME, this.getOption(constants.SVCNAME), address.host, address.port, this.sAtts.connectionId);\n        } else if (err == \"12505\") {\n          errors.throwErr(errors.ERR_INVALID_SID, this.getOption(constants.SID), address.host, address.port, this.sAtts.connectionId);\n        } else if (err) {\n          errors.throwErr(errors.ERR_CONNECTION_REFUSED, address.host, address.port, this.sAtts.connectionId, \"ORA-\" + err);\n        } else {\n          errors.throwErr(errors.ERR_CONNECTION_REFUSED, address.host, address.port, this.sAtts.connectionId, \"refused\");\n        }\n      } else if (packet.type === constants.NSPTRS) {\n        /* RESEND */\n        if ((packet.flags & constants.NSPFSRN) == constants.NSPFSRN) {\n          await this.ntAdapter.renegTLS();\n          this.ntAdapter.startRead();\n        }\n        this._sendConnect(connectPkt);\n      } else if (packet.type === constants.NSPTRD) {\n        /* REDIRECT */\n        let adrLen, adrStr, redirConnData;\n\n        /* Read and connect to Redirect address */\n        if (this.redirectPkt.overflow) {\n          await this._recvPacket();\n          this.redirectPkt.dataBuf = this.rcvDatapkt.buf.subarray(this.rcvDatapkt.offset, this.rcvDatapkt.len);\n        }\n        if (this.redirectPkt.flags & constants.NSPFRDS) {\n          adrLen = this.redirectPkt.dataBuf.indexOf('\\0', 0, 'ascii');\n          adrStr = this.redirectPkt.dataBuf.toString('ascii', 0, adrLen);\n          redirConnData = this.redirectPkt.dataBuf.subarray(adrLen + 1, this.redirectPkt.dataLen);\n        } else {\n          adrStr = this.redirectPkt.dataBuf.toString('ascii');\n          redirConnData = this.cData;\n        }\n        const redirAddressNode = await resolveAddress(adrStr);\n        const host = address.hostname;\n        address = await redirAddressNode.execute();\n        if (address.desc) this.sAtts.setFrom(address.desc.params); /* Add on attributes from redirect connect String */\n        address.originHost = host;\n        this.redirectPkt = null;\n        this.ntAdapter.disconnect(constants.NSFIMM);\n        if (this.sAtts.transportConnectTimeout) {\n          const asyncPromise = this.transportConnect(address);\n          await timeout(asyncPromise, this.sAtts.transportConnectTimeout, \"transportConnectTimeout\", address, this.sAtts.connectionId);\n        } else {\n          await this.transportConnect(address);\n        }\n        connectPkt = new Packet.ConnectPacket(redirConnData, this.sAtts, constants.NSPFRDR);\n        this.sndDatapkt = new Packet.DataPacket(this.sAtts.largeSDU);\n        this._sendConnect(connectPkt);\n      }\n    }\n\n    /* Accepted  */\n    this.connected = true;\n    this.cData = null;\n    this.sndDatapkt = new Packet.DataPacket(this.sAtts.largeSDU);\n    this.sndDatapkt.createPacket(constants.NSPDADAT); //Currently only used for disconnect\n    this.sndDatapkt.offset = this.sndDatapkt.dataPtr;\n    this.sndDatapkt.len = this.sndDatapkt.bufLen;\n    this.markerPkt = new Packet.MarkerPacket(this.sAtts.largeSDU);\n    this.controlPkt = new Packet.ControlPacket();\n    this.ntAdapter.largeSDU = this.sAtts.largeSDU;\n    this.sAtts.nt.wallet = null;\n    this.sAtts.nt.walletPassword = null;\n    return true;\n  }\n\n  /**\n   * Try all available addresses for connection establishment\n   */\n  async connect1(address, addressNode, userConfig) {\n    let connected, savedErr;\n    do {\n      try {\n        if (this.sAtts.connectTimeout) {\n          const asyncPromise = this.connect2(address);\n          connected = await timeout(asyncPromise, this.sAtts.connectTimeout, \"connectTimeout\", address, this.sAtts.connectionId);\n        } else {\n          connected = await this.connect2(address);\n        }\n      } catch (err) {\n        if (err.message.startsWith('NJS-510') && !this.ntAdapter.connected) {\n          downHostInstance.markDownHost(address.host, Date.now()); // mark the host as down\n          this.ntAdapter.connected = true; // Pretend as connected\n        }\n        if (this.ntAdapter) {\n          this.ntAdapter.disconnect(constants.NSFIMM);\n          this.ntAdapter = null;\n        }\n        connected = false;\n        savedErr = err;\n        try {\n          address = await this.getAddress(addressNode, userConfig);\n        } catch (err) {\n          break;\n        }\n      }\n    } while (!connected);\n    if (connected) {\n      return;\n    } else {\n      throw savedErr;\n    }\n  }\n\n  /**\n   * Process packet (Internal)\n   */\n  _processPacket(packet) {\n    switch (packet.type) {\n      case constants.NSPTDA:\n        /* DATA packet */\n        this.rcvDatapkt.fromPacket(packet);\n        break;\n      case constants.NSPTMK:\n        /* MARKER packet */\n        this.markerPkt.fromPacket(packet, this);\n        break;\n      case constants.NSPTCNL:\n        /* CONTROL packet */\n        this.controlPkt.fromPacket(packet);\n        break;\n      case constants.NSPTAC:\n        /* ACCEPT */\n        Packet.AcceptPacket(packet, this.sAtts);\n        this.dbUUID = packet.dbUUID;\n        packet.dbUUID = null;\n        break;\n      case constants.NSPTRF:\n        /* REFUSE */\n        this.refusePkt = new Packet.RefusePacket(packet);\n        break;\n      case constants.NSPTRS:\n        /* RESEND */\n        break;\n      case constants.NSPTRD:\n        /* REDIRECT */\n        this.redirectPkt = new Packet.RedirectPacket(packet);\n        break;\n      default:\n        errors.throwErr(errors.ERR_CONNECTION_INVALID_PACKET);\n    }\n  }\n\n  /**\n   * Receive packet (Internal)\n   * Control packets are consumed internally and discarded\n   */\n  async _recvPacket() {\n    while (true) {\n      // eslint-disable-line\n      const packet = await this.ntAdapter.receive();\n      if (!packet) break;\n      this._processPacket(packet);\n      if (packet.type !== constants.NSPTCNL) return packet;\n    }\n  }\n\n  /**\n   * Send data (Internal)\n   */\n  _sendPacket(buf) {\n    this.ntAdapter.send(buf);\n  }\n\n  /**\n   * Break ongoing operation\n   */\n  sendBreak() {\n    if (this.isBreak) return; /* Already in a break */\n\n    if (!this.connected) {\n      this.isBreak = true; /* Not yet connected. Post the break */\n      this.breakPosted = true;\n      return;\n    }\n    this.isBreak = true;\n    this.markerPkt.prepare(constants.NSPMKTD1, constants.NIQIMARK);\n    this._sendPacket(this.markerPkt.buf);\n  }\n\n  /**\n   * Reset the connection\n   */\n  async reset() {\n    /* If posted send Break */\n    if (this.breakPosted) {\n      this.markerPkt.prepare(constants.NSPMKTD1, constants.NIQBMARK);\n      this._sendPacket(this.markerPkt.buf);\n      this.breakPosted = false;\n    }\n    /* Send Reset */\n    this.markerPkt.prepare(constants.NSPMKTD1, constants.NIQRMARK);\n    this._sendPacket(this.markerPkt.buf);\n\n    /* Await Reset */\n    while (!this.isReset) {\n      await this._recvPacket();\n    }\n\n    /* reset packet buffers */\n    this.sndDatapkt.dataPtr = this.sndDatapkt.dataLen = constants.NSPDADAT;\n    this.sndDatapkt.offset = this.sndDatapkt.dataPtr;\n    this.sndDatapkt.len = this.sndDatapkt.bufLen;\n    this.isBreak = this.isReset = false;\n  }\n\n  /**\n  * Receive packet\n  */\n  async recvPacket() {\n    return await this._recvPacket();\n  }\n  syncRecvPacket() {\n    while (this.ntAdapter.packets.length > 0) {\n      const packet = this.ntAdapter.syncReceive();\n      if (!packet) break;\n      this._processPacket(packet);\n      if (packet.type !== constants.NSPTCNL) return packet;\n    }\n  }\n\n  /**\n   * Send data\n   * @param {Buffer} userBuf User provided buffer\n   * @param {*} offset from which to send data\n   * @param {*} len number of bytes to send\n   */\n  _send(userBuf, offset, len) {\n    if (this.isBreak) {\n      return;\n    }\n    let bytesCopied = 0;\n    this.sndDatapkt.dataLen = this.sndDatapkt.offset;\n    if (this.sndDatapkt.dataLen < this.sndDatapkt.bufLen || !this.sndDatapkt.bufLen) {\n      bytesCopied = this.sndDatapkt.fillBuf(userBuf, offset, len);\n      len -= bytesCopied;\n      offset += bytesCopied;\n      this.sndDatapkt.offset = this.sndDatapkt.dataLen;\n    }\n    while (len) {\n      this._sendPacket(this.sndDatapkt.dataBuf);\n\n      /* If break throw error now */\n      if (this.isBreak) {\n        return;\n      }\n      this.sndDatapkt.dataLen = this.sndDatapkt.dataPtr;\n      this.sndDatapkt.offset = this.sndDatapkt.dataPtr;\n      bytesCopied = this.sndDatapkt.fillBuf(userBuf, offset, len);\n      len -= bytesCopied;\n      offset += bytesCopied;\n      this.sndDatapkt.offset = this.sndDatapkt.dataLen;\n    }\n  }\n\n  /**\n   * Flush send buffers\n   */\n  flush() {\n    if (this.isBreak) {\n      return;\n    }\n    this.sndDatapkt.dataLen = this.sndDatapkt.offset;\n    this.sndDatapkt.prepare2Send();\n    this._sendPacket(Buffer.from(this.sndDatapkt.dataBuf));\n    this.sndDatapkt.dataLen = this.sndDatapkt.dataPtr;\n    this.sndDatapkt.offset = this.sndDatapkt.dataPtr;\n  }\n\n  /**\n   * Establish network connection\n  */\n  async connect(userConfig) {\n    const connStr = userConfig.connectString ? userConfig.connectString : userConfig.connectionString;\n    let addressNode;\n    if (userConfig._connInfo) {\n      addressNode = userConfig._connInfo[5];\n      addressNode.reset();\n    } else {\n      addressNode = await resolveAddress(connStr, userConfig.configDir);\n    }\n    let address;\n    try {\n      address = await this.getAddress(addressNode, userConfig);\n    } catch (err) {\n      if (err.message == \"All options tried\") /* Not even one valid Address */\n        errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_PARAMETERS, \"Ensure the ADDRESS parameters have been entered correctly, the most likely incorrect parameter is the host name\");else errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_PARAMETERS, err.message);\n    }\n    await this.connect1(address, addressNode, userConfig);\n  }\n\n  /**\n   * Disconnect\n   * @param {int} type of disconnect\n   */\n  disconnect(type) {\n    if (!this.connected) {\n      return;\n    }\n    if (type != constants.NSFIMM && !this.ntAdapter.err) {\n      /* Send EOF packet */\n      this.sndDatapkt.dataLen = this.sndDatapkt.offset;\n      this.sndDatapkt.prepare2Send(constants.NSPDAFEOF);\n      this._sendPacket(this.sndDatapkt.dataBuf);\n    }\n    this.ntAdapter.disconnect(type);\n    this.ntAdapter = null;\n    this.connected = false;\n  }\n\n  /**\n   * Get connection attributes\n   * @param {int} opcode type of attribute\n   * @returns attribute value\n   */\n  getOption(opcode) {\n    switch (opcode) {\n      case constants.NS_MOREDATA:\n        /* Is there more data in read buffers */\n        return this.ntAdapter.packets.length > 0;\n      case constants.SVCNAME:\n        /* Service name */\n        return findValue(this.cDataNVPair, [\"DESCRIPTION\", \"CONNECT_DATA\", \"SERVICE_NAME\"]);\n      case constants.SID:\n        /* Service name */\n        return findValue(this.cDataNVPair, [\"DESCRIPTION\", \"CONNECT_DATA\", \"SID\"]);\n      case constants.SERVERTYPE:\n        /* Server type */\n        return findValue(this.cDataNVPair, [\"DESCRIPTION\", \"CONNECT_DATA\", \"SERVER\"]);\n      case constants.REMOTEADDR:\n        /* Peer address */\n        if (this.ntAdapter) {\n          return this.ntAdapter.getOption(opcode); // Pass through to NT\n        } else {\n          return null;\n        }\n      case constants.CONNCLASS:\n        /* Connection Class */\n        return findValue(this.cDataNVPair, [\"DESCRIPTION\", \"CONNECT_DATA\", \"POOL_CONNECTION_CLASS\"]);\n      case constants.PURITY:\n        /* Purity */\n        return findValue(this.cDataNVPair, [\"DESCRIPTION\", \"CONNECT_DATA\", \"POOL_PURITY\"]);\n      case constants.HEALTHCHECK:\n        /* Is connection healthy */\n        return this.connected && this.ntAdapter.connected && !this.ntAdapter.err;\n      default:\n        errors.throwErr(errors.ERR_INTERNAL, \"getOption not supported for opcode \" + opcode);\n    }\n  }\n\n  /**\n   * receive inband notification\n   * @param {Object} obj Return the notification into user provided object\n   * @returns Error number sent from server, or error on the connection. returns 0 if healthy connection\n   */\n  recvInbandNotif() {\n    let error = 0;\n    if (this.controlPkt.errno) {\n      /* Control pkt already read */\n      error = this.controlPkt.errno;\n      return error;\n    } else if (!this.getOption(constants.HEALTHCHECK)) {\n      return errors.ERR_CONNECTION_CLOSED;\n    } else {\n      if (this.getOption(constants.NS_MOREDATA)) {\n        //More data available\n        const packet = this.ntAdapter.syncReceive();\n        if (packet.type == constants.NSPTCNL) {\n          this.controlPkt.fromPacket(packet);\n          error = this.controlPkt.errno;\n          return error;\n        } else {\n          this.ntAdapter.packets.unshift(packet); /* Push packet back */\n          return 0;\n        }\n      } else return 0;\n    }\n  }\n}\nmodule.exports = {\n  NetworkSession,\n  resolveAddress,\n  getConnectionInfo\n};","map":{"version":3,"names":["Packet","require","NTTCP","SessionAtts","constants","createNode","errors","findNVPairRecurse","createNVPair","findValue","Buffer","EzConnect","NLParamParser","tnsnamesFilePath","process","downHostInstance","SOLE_INST_DHCACHE","getConnectionInfo","userConfig","connStr","resolveConnectStr","connectString","configDir","addressNode","nvpair","serverVal","connClass","svcname","sid","poolPurity","nlParamParser","trim","resolvedVal","indexOf","ezcnObj","getResolvedUrl","namesFilePath","p","initializeNlpa","get","toUpperCase","throwErr","ERR_TNS_ENTRY_NOT_FOUND","env","TNS_ADMIN","getListElement","resolveAddress","connstr","timeout","asyncPromise","timeVal","oper","address","connID","timer","timeoutPromise","Promise","resolve","reject","setTimeout","getErr","ERR_CONNECTION_TIMEDOUT","host","port","race","then","result","clearTimeout","catch","err","NetworkSession","constructor","connected","isBreak","isReset","breakPosted","getAddress","execute","uuid","sAtts","setFrom","desc","params","prepare","protocol","rootNVPair","CNdata","join","cdataNVPair","connidStr","connectionId","childNVPair","addListElement","cData","from","toString","cDataNVPair","nt","transportConnect","httpsProxy","ERR_INVALID_CONNECT_STRING_PARAMETERS","ntAdapter","connect","startRead","ntCha","cha","sndDatapkt","DataPacket","largeSDU","rcvDatapkt","_sendConnect","connectPkt","_sendPacket","buf","overflow","_send","connectData","connectDataLen","flush","connect2","sdu","NSPABSSDULN","NSPMNSDULN","NSPDFSDULN","transportConnectTimeout","ConnectPacket","packet","_recvPacket","type","NSPTAC","NSPTRF","refusePkt","dataBuf","subarray","offset","len","ERR_INVALID_SERVICE_NAME","getOption","SVCNAME","ERR_INVALID_SID","SID","ERR_CONNECTION_REFUSED","NSPTRS","flags","NSPFSRN","renegTLS","NSPTRD","adrLen","adrStr","redirConnData","redirectPkt","NSPFRDS","dataLen","redirAddressNode","hostname","originHost","disconnect","NSFIMM","NSPFRDR","createPacket","NSPDADAT","dataPtr","bufLen","markerPkt","MarkerPacket","controlPkt","ControlPacket","wallet","walletPassword","connect1","savedErr","connectTimeout","message","startsWith","markDownHost","Date","now","_processPacket","NSPTDA","fromPacket","NSPTMK","NSPTCNL","AcceptPacket","dbUUID","RefusePacket","RedirectPacket","ERR_CONNECTION_INVALID_PACKET","receive","send","sendBreak","NSPMKTD1","NIQIMARK","reset","NIQBMARK","NIQRMARK","recvPacket","syncRecvPacket","packets","length","syncReceive","userBuf","bytesCopied","fillBuf","prepare2Send","connectionString","_connInfo","NSPDAFEOF","opcode","NS_MOREDATA","SERVERTYPE","REMOTEADDR","CONNCLASS","PURITY","HEALTHCHECK","ERR_INTERNAL","recvInbandNotif","error","errno","ERR_CONNECTION_CLOSED","unshift","module","exports"],"sources":["C:/Users/user1/Desktop/finalproject_penpick/node_modules/oracledb/lib/thin/sqlnet/networkSession.js"],"sourcesContent":["// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst Packet = require(\"./packet.js\");\nconst NTTCP = require(\"./ntTcp.js\");\nconst SessionAtts = require(\"./sessionAtts.js\");\nconst constants = require(\"./constants.js\");\nconst { createNode } = require('./connStrategy.js');\nconst errors = require(\"../../errors.js\");\nconst { findNVPairRecurse, createNVPair, findValue } = require(\"./nvStrToNvPair.js\");\nconst { Buffer } = require('buffer');\nconst EzConnect = require(\"./ezConnectResolver.js\");\nconst { NLParamParser, tnsnamesFilePath } = require(\"./paramParser.js\");\nconst process = require('process');\nconst downHostInstance = require(\"./connStrategy.js\").SOLE_INST_DHCACHE;\n/**\n *\n * @param {string} userConfig\n * @returns serverinfo\n */\n\nasync function getConnectionInfo(userConfig) {\n  const connStr = await resolveConnectStr(userConfig.connectString, userConfig.configDir);\n  const addressNode = await createNode(connStr);\n  let nvpair;\n  if (typeof connStr === 'string')\n    nvpair = createNVPair(connStr);\n  else\n    nvpair = connStr;//Already a NVPair\n\n  const serverVal = findValue(nvpair, [\"DESCRIPTION\", \"CONNECT_DATA\", \"SERVER\"]);\n  const connClass = findValue(nvpair, [\"DESCRIPTION\", \"CONNECT_DATA\", \"POOL_CONNECTION_CLASS\"]);\n  const svcname =   findValue(nvpair, [\"DESCRIPTION\", \"CONNECT_DATA\", \"SERVICE_NAME\"]);\n  const sid =   findValue(nvpair, [\"DESCRIPTION\", \"CONNECT_DATA\", \"SID\"]);\n  const poolPurity = findValue(nvpair, [\"DESCRIPTION\", \"CONNECT_DATA\", \"POOL_PURITY\"]);\n\n  return [serverVal, connClass, svcname, poolPurity, sid, addressNode ];\n}\n\n/**\n * Resolve the connect string to a NV format address\n * @param {String} connStr Connect string\n * @returns AddressNode\n */\nconst nlParamParser =  new NLParamParser;\nasync function resolveConnectStr(connectString, configDir) {\n  const connStr = connectString.trim();\n  let resolvedVal = connStr;\n  if ((connStr.indexOf(')') == -1) || (connStr.indexOf('(') != 0)) {\n    if ((connStr.indexOf(':') != -1) || (connStr.indexOf('/') != -1)) {\n      const ezcnObj = new EzConnect(connStr);\n      resolvedVal = ezcnObj.getResolvedUrl();\n      return resolvedVal;\n    } else {\n      //try tns alias\n      const namesFilePath = tnsnamesFilePath(configDir);\n      const p = await nlParamParser.initializeNlpa(namesFilePath);\n      resolvedVal = p.get(connStr.toUpperCase());\n      if (!resolvedVal)\n        errors.throwErr(errors.ERR_TNS_ENTRY_NOT_FOUND, connStr, configDir ? configDir + '/tnsnames.ora' : process.env.TNS_ADMIN + '/tnsnames.ora');\n      resolvedVal = resolvedVal.getListElement(0);\n    }\n\n  }\n  return resolvedVal;\n\n}\n\nasync function resolveAddress(connStr, configDir) {\n  const connstr = await resolveConnectStr(connStr, configDir);\n  return createNode(connstr);\n}\n\n/**\n   * Timeout function\n   * @param {Promise} asyncPromise input promise\n   * @param {int} timeVal timeout value\n   * @returns resolved value of input promise\n   */\nfunction timeout(asyncPromise, timeVal, oper, address, connID) {\n  let timer;\n\n  const timeoutPromise = new Promise((resolve, reject) => {\n    // max possible value for 32-bit integer\n    if (timeVal > 2147483647)\n      timeVal = 2147483647;\n\n    timer = setTimeout(() => reject(errors.getErr(errors.ERR_CONNECTION_TIMEDOUT, address.host, address.port, oper, timeVal / 1000, connID)), timeVal);\n  });\n  return Promise.race([asyncPromise, timeoutPromise]).then((result) => {\n    clearTimeout(timer);\n    return result;\n  }).catch((err) => {\n    clearTimeout(timer);\n    throw err;\n  });\n}\n\n/**\n * Network Session. This will be used for communication with the server.\n * @param {object} userConfig Connection options\n */\nclass NetworkSession {\n\n  constructor() {\n    this.connected = false;\n    this.isBreak = false;\n    this.isReset = false;\n    this.breakPosted = false;\n  }\n\n  async getAddress(addressNode, userConfig) {\n    /* Get the next address */\n    const address = await addressNode.execute(userConfig);\n    /* Prepare connection attributes */\n    const uuid = this.sAtts ? this.sAtts.uuid : null;\n    this.sAtts = new SessionAtts(uuid);\n    this.sAtts.setFrom(userConfig);\n    this.sAtts.setFrom(address.desc.params);  /* Resolve attributes from Connect String */\n    await this.sAtts.prepare(address.protocol);\n\n    /* Insert Connection ID */\n    const rootNVPair = createNVPair(address.CNdata.join(\"\"));\n    const cdataNVPair = findNVPairRecurse(rootNVPair, \"CONNECT_DATA\");\n    const connidStr = `(CONNECTION_ID=${this.sAtts.connectionId})`;\n    const childNVPair = createNVPair(connidStr);\n    cdataNVPair.addListElement(childNVPair);\n\n    this.cData = Buffer.from(rootNVPair.toString(), 'ascii');\n    this.cDataNVPair = rootNVPair;\n    this.sAtts.nt.cDataNVPair = rootNVPair;\n\n    return (address);\n  }\n\n  /**\n   * Make the transport level connection\n   */\n  async transportConnect(address) {\n    if (address.protocol.toUpperCase() == 'TCP' && address.httpsProxy) {\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_PARAMETERS, 'https proxy requires protocol as', 'tcps ');\n    }\n    if (address.protocol && (address.protocol.toUpperCase() == 'TCP' || address.protocol.toUpperCase() == 'TCPS')) {\n      this.ntAdapter = new NTTCP(this.sAtts.nt);\n    } else {\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_PARAMETERS, address.protocol + \" protocol not supported\");\n    }\n    await this.ntAdapter.connect(address);\n    this.ntAdapter.startRead();\n    this.sAtts.ntCha = this.ntAdapter.cha;\n    this.sndDatapkt = new Packet.DataPacket(this.sAtts.largeSDU);\n    this.rcvDatapkt = new Packet.DataPacket(this.sAtts.largeSDU);\n  }\n\n  /**\n   * Send the NSPTCN(connect) packet\n   * @param {object} connectPkt Connect Packet\n   */\n  _sendConnect(connectPkt) {\n    this._sendPacket(connectPkt.buf);\n    if (connectPkt.overflow) {\n      this._send(connectPkt.connectData, 0, connectPkt.connectDataLen);\n      this.flush();\n    }\n  }\n\n  /**\n   * Establish network session .Make transport level connection, send NSPTCN(connect packet) and read the response.\n   * @returns NetError.(connection successfully established(NetError.CONNECTED) or reason for failure)\n   */\n  async connect2(address) {\n    /* Sanitise SDU */\n    if (this.sAtts.sdu) {\n      if (this.sAtts.sdu > constants.NSPABSSDULN) {\n        this.sAtts.sdu = constants.NSPABSSDULN;\n      } else if (this.sAtts.sdu < constants.NSPMNSDULN) {\n        this.sAtts.sdu = constants.NSPMNSDULN;\n      }\n    } else {\n      this.sAtts.sdu = constants.NSPDFSDULN;\n    }\n\n    /* Transport connect */\n    if (this.sAtts.transportConnectTimeout) {\n      const asyncPromise = this.transportConnect(address);\n      await timeout(asyncPromise, this.sAtts.transportConnectTimeout, \"transportConnectTimeout\", address, this.sAtts.connectionId);\n    } else {\n      await this.transportConnect(address);\n    }\n\n    /* Send the connect packet */\n    let connectPkt = new Packet.ConnectPacket(this.cData, this.sAtts);\n    this._sendConnect(connectPkt);\n\n    /* Read the response */\n      while (true) {  // eslint-disable-line\n      const packet = await this._recvPacket();\n      if (packet.type === constants.NSPTAC) /* ACCEPT */\n        break;\n      if (packet.type === constants.NSPTRF) { /* REFUSE */\n        if (this.refusePkt.overflow) {\n          await this._recvPacket();\n          this.refusePkt.dataBuf = this.rcvDatapkt.buf.subarray(this.rcvDatapkt.offset, this.rcvDatapkt.len).toString();\n        }\n        const nvpair = createNVPair(this.refusePkt.dataBuf);\n        this.refusePkt = null;\n        const err = findValue(nvpair, [\"DESCRIPTION\", \"ERR\"]);\n        if (err == \"12514\") {\n          errors.throwErr(errors.ERR_INVALID_SERVICE_NAME, this.getOption(constants.SVCNAME), address.host, address.port, this.sAtts.connectionId);\n        } else if (err == \"12505\") {\n          errors.throwErr(errors.ERR_INVALID_SID, this.getOption(constants.SID), address.host, address.port, this.sAtts.connectionId);\n        } else if (err) {\n          errors.throwErr(errors.ERR_CONNECTION_REFUSED, address.host, address.port, this.sAtts.connectionId, \"ORA-\" + err);\n        } else {\n          errors.throwErr(errors.ERR_CONNECTION_REFUSED, address.host, address.port, this.sAtts.connectionId, \"refused\");\n        }\n      } else if (packet.type === constants.NSPTRS) { /* RESEND */\n        if ((packet.flags & constants.NSPFSRN) == constants.NSPFSRN) {\n          await this.ntAdapter.renegTLS();\n          this.ntAdapter.startRead();\n        }\n        this._sendConnect(connectPkt);\n      } else if (packet.type === constants.NSPTRD) { /* REDIRECT */\n        let adrLen, adrStr, redirConnData;\n\n        /* Read and connect to Redirect address */\n        if (this.redirectPkt.overflow) {\n          await this._recvPacket();\n          this.redirectPkt.dataBuf = this.rcvDatapkt.buf.subarray(this.rcvDatapkt.offset, this.rcvDatapkt.len);\n        }\n\n        if (this.redirectPkt.flags & constants.NSPFRDS) {\n          adrLen = this.redirectPkt.dataBuf.indexOf('\\0', 0, 'ascii');\n          adrStr = this.redirectPkt.dataBuf.toString('ascii', 0, adrLen);\n          redirConnData = this.redirectPkt.dataBuf.subarray(adrLen + 1, this.redirectPkt.dataLen);\n        } else {\n          adrStr = this.redirectPkt.dataBuf.toString('ascii');\n          redirConnData = this.cData;\n        }\n\n        const redirAddressNode = await resolveAddress(adrStr);\n        const host = address.hostname;\n        address = await redirAddressNode.execute();\n        if (address.desc)\n          this.sAtts.setFrom(address.desc.params);  /* Add on attributes from redirect connect String */\n        address.originHost = host;\n        this.redirectPkt = null;\n        this.ntAdapter.disconnect(constants.NSFIMM);\n\n        if (this.sAtts.transportConnectTimeout) {\n          const asyncPromise = this.transportConnect(address);\n          await timeout(asyncPromise, this.sAtts.transportConnectTimeout, \"transportConnectTimeout\", address, this.sAtts.connectionId);\n        } else {\n          await this.transportConnect(address);\n        }\n\n        connectPkt = new Packet.ConnectPacket(redirConnData, this.sAtts, constants.NSPFRDR);\n        this.sndDatapkt = new Packet.DataPacket(this.sAtts.largeSDU);\n        this._sendConnect(connectPkt);\n      }\n    }\n\n    /* Accepted  */\n    this.connected = true;\n    this.cData = null;\n    this.sndDatapkt = new Packet.DataPacket(this.sAtts.largeSDU);\n    this.sndDatapkt.createPacket(constants.NSPDADAT); //Currently only used for disconnect\n    this.sndDatapkt.offset = this.sndDatapkt.dataPtr;\n    this.sndDatapkt.len = this.sndDatapkt.bufLen;\n    this.markerPkt = new Packet.MarkerPacket(this.sAtts.largeSDU);\n    this.controlPkt = new Packet.ControlPacket();\n    this.ntAdapter.largeSDU = this.sAtts.largeSDU;\n    this.sAtts.nt.wallet = null;\n    this.sAtts.nt.walletPassword = null;\n    return (true);\n  }\n\n  /**\n   * Try all available addresses for connection establishment\n   */\n  async connect1(address, addressNode, userConfig) {\n    let connected, savedErr;\n    do {\n      try {\n        if (this.sAtts.connectTimeout) {\n          const asyncPromise = this.connect2(address);\n          connected = await timeout(asyncPromise, this.sAtts.connectTimeout, \"connectTimeout\", address, this.sAtts.connectionId);\n        } else {\n          connected = await this.connect2(address);\n        }\n      } catch (err) {\n        if (err.message.startsWith('NJS-510') && !this.ntAdapter.connected) {\n          downHostInstance.markDownHost(address.host, Date.now()); // mark the host as down\n          this.ntAdapter.connected = true; // Pretend as connected\n        }\n        if (this.ntAdapter) {\n          this.ntAdapter.disconnect(constants.NSFIMM);\n          this.ntAdapter = null;\n        }\n        connected = false;\n        savedErr = err;\n        try {\n          address = await this.getAddress(addressNode, userConfig);\n        } catch (err) {\n          break;\n        }\n      }\n    } while (!connected);\n    if (connected) {\n      return;\n    } else {\n      throw (savedErr);\n    }\n  }\n\n  /**\n   * Process packet (Internal)\n   */\n  _processPacket(packet) {\n    switch (packet.type) {\n      case constants.NSPTDA: /* DATA packet */\n        this.rcvDatapkt.fromPacket(packet);\n        break;\n      case constants.NSPTMK: /* MARKER packet */\n        this.markerPkt.fromPacket(packet, this);\n        break;\n      case constants.NSPTCNL: /* CONTROL packet */\n        this.controlPkt.fromPacket(packet);\n        break;\n      case constants.NSPTAC: /* ACCEPT */\n        Packet.AcceptPacket(packet, this.sAtts);\n        this.dbUUID = packet.dbUUID;\n        packet.dbUUID = null;\n        break;\n      case constants.NSPTRF: /* REFUSE */\n        this.refusePkt = new Packet.RefusePacket(packet);\n        break;\n      case constants.NSPTRS: /* RESEND */\n        break;\n      case constants.NSPTRD: /* REDIRECT */\n        this.redirectPkt = new Packet.RedirectPacket(packet);\n        break;\n      default:\n        errors.throwErr(errors.ERR_CONNECTION_INVALID_PACKET);\n    }\n  }\n\n  /**\n   * Receive packet (Internal)\n   * Control packets are consumed internally and discarded\n   */\n  async _recvPacket() {\n    while (true) {  // eslint-disable-line\n      const packet = await this.ntAdapter.receive();\n      if (!packet)\n        break;\n      this._processPacket(packet);\n      if (packet.type !== constants.NSPTCNL)\n        return packet;\n    }\n  }\n\n  /**\n   * Send data (Internal)\n   */\n  _sendPacket(buf) {\n    this.ntAdapter.send(buf);\n  }\n\n  /**\n   * Break ongoing operation\n   */\n  sendBreak() {\n    if (this.isBreak)\n      return; /* Already in a break */\n\n    if (!this.connected) {\n      this.isBreak = true; /* Not yet connected. Post the break */\n      this.breakPosted = true;\n      return;\n    }\n\n    this.isBreak = true;\n    this.markerPkt.prepare(constants.NSPMKTD1, constants.NIQIMARK);\n    this._sendPacket(this.markerPkt.buf);\n  }\n\n  /**\n   * Reset the connection\n   */\n  async reset() {\n    /* If posted send Break */\n    if (this.breakPosted) {\n      this.markerPkt.prepare(constants.NSPMKTD1, constants.NIQBMARK);\n      this._sendPacket(this.markerPkt.buf);\n      this.breakPosted = false;\n    }\n    /* Send Reset */\n    this.markerPkt.prepare(constants.NSPMKTD1, constants.NIQRMARK);\n    this._sendPacket(this.markerPkt.buf);\n\n    /* Await Reset */\n    while (!this.isReset) {\n      await this._recvPacket();\n    }\n\n    /* reset packet buffers */\n    this.sndDatapkt.dataPtr = this.sndDatapkt.dataLen = constants.NSPDADAT;\n    this.sndDatapkt.offset = this.sndDatapkt.dataPtr;\n    this.sndDatapkt.len = this.sndDatapkt.bufLen;\n\n    this.isBreak = this.isReset = false;\n  }\n\n  /**\n  * Receive packet\n  */\n  async recvPacket() {\n    return await this._recvPacket();\n  }\n\n  syncRecvPacket() {\n    while (this.ntAdapter.packets.length > 0) {\n      const packet = this.ntAdapter.syncReceive();\n      if (!packet)\n        break;\n      this._processPacket(packet);\n      if (packet.type !== constants.NSPTCNL)\n        return packet;\n    }\n  }\n\n  /**\n   * Send data\n   * @param {Buffer} userBuf User provided buffer\n   * @param {*} offset from which to send data\n   * @param {*} len number of bytes to send\n   */\n  _send(userBuf, offset, len) {\n    if (this.isBreak) {\n      return;\n    }\n    let bytesCopied = 0;\n\n    this.sndDatapkt.dataLen = this.sndDatapkt.offset;\n    if (this.sndDatapkt.dataLen < this.sndDatapkt.bufLen || !this.sndDatapkt.bufLen) {\n      bytesCopied = this.sndDatapkt.fillBuf(userBuf, offset, len);\n      len -= bytesCopied;\n      offset += bytesCopied;\n      this.sndDatapkt.offset = this.sndDatapkt.dataLen;\n    }\n\n    while (len) {\n      this._sendPacket(this.sndDatapkt.dataBuf);\n\n      /* If break throw error now */\n      if (this.isBreak) {\n        return;\n      }\n\n      this.sndDatapkt.dataLen = this.sndDatapkt.dataPtr;\n      this.sndDatapkt.offset = this.sndDatapkt.dataPtr;\n      bytesCopied = this.sndDatapkt.fillBuf(userBuf, offset, len);\n      len -= bytesCopied;\n      offset += bytesCopied;\n      this.sndDatapkt.offset = this.sndDatapkt.dataLen;\n    }\n  }\n\n  /**\n   * Flush send buffers\n   */\n  flush() {\n    if (this.isBreak) {\n      return;\n    }\n    this.sndDatapkt.dataLen = this.sndDatapkt.offset;\n    this.sndDatapkt.prepare2Send();\n    this._sendPacket(Buffer.from(this.sndDatapkt.dataBuf));\n    this.sndDatapkt.dataLen = this.sndDatapkt.dataPtr;\n    this.sndDatapkt.offset = this.sndDatapkt.dataPtr;\n  }\n\n  /**\n   * Establish network connection\n  */\n  async connect(userConfig) {\n    const connStr = userConfig.connectString ? userConfig.connectString : userConfig.connectionString;\n    let addressNode;\n    if (userConfig._connInfo) {\n      addressNode = userConfig._connInfo[5];\n      addressNode.reset();\n    } else {\n      addressNode = await resolveAddress(connStr, userConfig.configDir);\n    }\n    let address;\n    try {\n      address = await this.getAddress(addressNode, userConfig);\n    } catch (err) {\n      if (err.message == \"All options tried\") /* Not even one valid Address */\n        errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_PARAMETERS, \"Ensure the ADDRESS parameters have been entered correctly, the most likely incorrect parameter is the host name\");\n      else\n        errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_PARAMETERS, err.message);\n    }\n    await this.connect1(address, addressNode, userConfig);\n  }\n\n  /**\n   * Disconnect\n   * @param {int} type of disconnect\n   */\n  disconnect(type) {\n    if (!this.connected) {\n      return;\n    }\n    if (type != constants.NSFIMM && !this.ntAdapter.err) {\n      /* Send EOF packet */\n      this.sndDatapkt.dataLen = this.sndDatapkt.offset;\n      this.sndDatapkt.prepare2Send(constants.NSPDAFEOF);\n      this._sendPacket(this.sndDatapkt.dataBuf);\n    }\n    this.ntAdapter.disconnect(type);\n    this.ntAdapter = null;\n    this.connected = false;\n  }\n\n  /**\n   * Get connection attributes\n   * @param {int} opcode type of attribute\n   * @returns attribute value\n   */\n  getOption(opcode) {\n    switch (opcode) {\n\n      case constants.NS_MOREDATA: /* Is there more data in read buffers */\n        return (this.ntAdapter.packets.length > 0);\n\n      case constants.SVCNAME: /* Service name */\n        return findValue(this.cDataNVPair, [\"DESCRIPTION\", \"CONNECT_DATA\", \"SERVICE_NAME\"]);\n\n      case constants.SID: /* Service name */\n        return findValue(this.cDataNVPair, [\"DESCRIPTION\", \"CONNECT_DATA\", \"SID\"]);\n\n      case constants.SERVERTYPE: /* Server type */\n        return findValue(this.cDataNVPair, [\"DESCRIPTION\", \"CONNECT_DATA\", \"SERVER\"]);\n\n      case constants.REMOTEADDR: /* Peer address */\n        if (this.ntAdapter) {\n          return this.ntAdapter.getOption(opcode); // Pass through to NT\n        } else {\n          return null;\n        }\n\n      case constants.CONNCLASS: /* Connection Class */\n        return findValue(this.cDataNVPair, [\"DESCRIPTION\", \"CONNECT_DATA\", \"POOL_CONNECTION_CLASS\"]);\n\n      case constants.PURITY: /* Purity */\n        return findValue(this.cDataNVPair, [\"DESCRIPTION\", \"CONNECT_DATA\", \"POOL_PURITY\"]);\n\n      case constants.HEALTHCHECK: /* Is connection healthy */\n        return (this.connected && this.ntAdapter.connected && !this.ntAdapter.err);\n\n      default:\n        errors.throwErr(errors.ERR_INTERNAL, \"getOption not supported for opcode \" + opcode);\n    }\n  }\n\n  /**\n   * receive inband notification\n   * @param {Object} obj Return the notification into user provided object\n   * @returns Error number sent from server, or error on the connection. returns 0 if healthy connection\n   */\n  recvInbandNotif() {\n    let error = 0;\n    if (this.controlPkt.errno) {     /* Control pkt already read */\n      error = this.controlPkt.errno;\n      return (error);\n    } else if (!this.getOption(constants.HEALTHCHECK)) {\n      return errors.ERR_CONNECTION_CLOSED;\n    } else {\n      if (this.getOption(constants.NS_MOREDATA)) { //More data available\n        const packet = this.ntAdapter.syncReceive();\n\n        if (packet.type == constants.NSPTCNL) {\n          this.controlPkt.fromPacket(packet);\n          error = this.controlPkt.errno;\n          return (error);\n        } else {\n          this.ntAdapter.packets.unshift(packet); /* Push packet back */\n          return (0);\n        }\n      } else\n        return (0);\n    }\n  }\n}\n\nmodule.exports = {\n  NetworkSession,\n  resolveAddress,\n  getConnectionInfo\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}