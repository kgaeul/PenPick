{"ast":null,"code":"// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst constants = require(\"./constants.js\");\nconst Capabilities = require(\"./capabilities.js\");\nconst {\n  WritePacket,\n  ReadPacket\n} = require(\"./packet.js\");\nconst errors = require(\"../../errors\");\nconst utils = require(\"./utils.js\");\n\n/**\n * Handles protocol details.\n *\n * @class Protocol\n */\nclass Protocol {\n  constructor(conn) {\n    this._breakInProgress = false;\n    this.txnInProgress = false;\n    this.connInProgress = true;\n    this.nsi = conn.nscon;\n    this.sequenceId = 1;\n    /**\n     * Compile and Runtime capabilities negotiated with Server\n     * @type {object}\n     */\n    this.caps = new Capabilities(conn.nscon.sAtts.version);\n    this.writeBuf = new WritePacket(conn.nscon, this.caps, this);\n    this.readBuf = new ReadPacket(conn.nscon, this.caps);\n    this.callTimeout = 0;\n  }\n\n  /**\n   * Decodes the message returned by the database. A message may consist of\n   * multiple packets. Not all packets may be available so if insufficient\n   * packets are available, the message decode function is expected to return\n   * the value true if more data is expected to follow.\n   *\n   * If that occurs, waiting occurs until more packets arrive.\n   *\n   * @param {object} message: the RPC dynamic structure specific to the RPC\n   */\n  async _decodeMessage(message) {\n    message.preProcess();\n    await this.readBuf.waitForPackets();\n    while (true) {\n      // eslint-disable-line\n      if (this.nsi.isBreak) {\n        await this.resetMessage();\n        delete this.readBuf.savedBuffers;\n        await this.readBuf.waitForPackets();\n      }\n      try {\n        message.decode(this.readBuf);\n        break;\n      } catch (err) {\n        if (err instanceof utils.OutOfPacketsError) {\n          if (!this.nsi.isBreak) {\n            await this.readBuf.waitForPackets();\n            this.readBuf.restorePoint();\n          }\n          continue;\n        }\n        throw err;\n      }\n    }\n    await message.postProcess();\n  }\n\n  /**\n   * Encodes the message to be sent to the database. A message may be encoded\n   * in multiple packets. In order to facilitate encoding of very large\n   * messages consisting of a large number of packets, the message encode\n   * function is expected to return the value true if more data is to follow.\n   *\n   * If that occurs, waiting occurs until the stream has drained and is ready\n   * to accept more data.\n   *\n   * @param {object} message: the RPC dynamic structure specific to the RPC\n   */\n  async _encodeMessage(message) {\n    const adapter = this.nsi.ntAdapter;\n    this.writeBuf.startRequest(constants.TNS_PACKET_TYPE_DATA);\n    while (message.encode(this.writeBuf)) {\n      await adapter.pauseWrite();\n    }\n    this.writeBuf.endRequest();\n  }\n  async _recoverFromError(caughtErr, message) {\n    /*\n     * We have NJS error(protocol related) detected during packet write/read\n     * operation.  Issue a break and reset to clear channel . We receive the\n     * response as ORA-1013 from the server.\n     */\n    try {\n      this.breakMessage();\n      this._breakInProgress = false;\n      await this.resetMessage();\n      await this.readBuf.waitForPackets();\n      message.decode(this.readBuf);\n    } catch (err) {\n      // Recovery failed\n      this.nsi.disconnect();\n      const newErr = errors.getErr(errors.ERR_CONNECTION_CLOSED);\n      caughtErr.message = newErr.message + \"\\nError recovery failed: \" + err.message + \"\\nOriginal error: \" + caughtErr.message;\n      throw caughtErr;\n    }\n  }\n\n  /**\n   *\n   * @param {object} message The RPC dynamic structure specific to the RPC\n   * @return {Promise}\n   */\n  async _processMessage(message) {\n    let callTimer;\n    let callTimeoutExpired = false;\n    try {\n      if (this.callTimeout > 0) {\n        callTimer = setTimeout(() => {\n          callTimeoutExpired = true;\n          this.breakMessage();\n        }, this.callTimeout);\n      }\n      await this._encodeMessage(message);\n      if (message.messageType !== constants.TNS_MSG_TYPE_ONEWAY_FN) {\n        await this._decodeMessage(message);\n      }\n    } catch (err) {\n      if (!this.connInProgress && err.code !== errors.ERR_CONNECTION_CLOSED_CODE) {\n        await this._recoverFromError(err, message);\n      }\n      throw err;\n    } finally {\n      clearTimeout(callTimer);\n    }\n    if (message.flushOutBinds) {\n      await this.flushOutBindMessage(message);\n    }\n    this.txnInProgress = message.callStatus & constants.TNS_TXN_IN_PROGRESS;\n    if (message.errorOccurred) {\n      if (callTimeoutExpired) {\n        errors.throwErr(errors.ERR_CALL_TIMEOUT_EXCEEDED, this.callTimeout);\n      }\n      let err = new Error(message.errorInfo.message);\n      err.offset = message.errorInfo.pos;\n      err.errorNum = message.errorInfo.num;\n      err = errors.transformErr(err);\n      if (err.code === errors.ERR_CONNECTION_CLOSED_CODE) {\n        this.nsi.disconnect();\n      }\n      throw err;\n    }\n  }\n  async flushOutBindMessage(message) {\n    this.writeBuf.startRequest(constants.TNS_PACKET_TYPE_DATA);\n    this.writeBuf.writeUInt8(constants.TNS_MSG_TYPE_FLUSH_OUT_BINDS);\n    this.writeBuf.endRequest();\n    await this._decodeMessage(message);\n  }\n\n  /**\n   * Send break packet\n   */\n  breakMessage() {\n    this._breakInProgress = true;\n    this.nsi.sendBreak();\n  }\n\n  /**\n   * Reset the connection\n   */\n  async resetMessage() {\n    await this.nsi.reset();\n  }\n}\nmodule.exports = Protocol;","map":{"version":3,"names":["constants","require","Capabilities","WritePacket","ReadPacket","errors","utils","Protocol","constructor","conn","_breakInProgress","txnInProgress","connInProgress","nsi","nscon","sequenceId","caps","sAtts","version","writeBuf","readBuf","callTimeout","_decodeMessage","message","preProcess","waitForPackets","isBreak","resetMessage","savedBuffers","decode","err","OutOfPacketsError","restorePoint","postProcess","_encodeMessage","adapter","ntAdapter","startRequest","TNS_PACKET_TYPE_DATA","encode","pauseWrite","endRequest","_recoverFromError","caughtErr","breakMessage","disconnect","newErr","getErr","ERR_CONNECTION_CLOSED","_processMessage","callTimer","callTimeoutExpired","setTimeout","messageType","TNS_MSG_TYPE_ONEWAY_FN","code","ERR_CONNECTION_CLOSED_CODE","clearTimeout","flushOutBinds","flushOutBindMessage","callStatus","TNS_TXN_IN_PROGRESS","errorOccurred","throwErr","ERR_CALL_TIMEOUT_EXCEEDED","Error","errorInfo","offset","pos","errorNum","num","transformErr","writeUInt8","TNS_MSG_TYPE_FLUSH_OUT_BINDS","sendBreak","reset","module","exports"],"sources":["C:/Users/user1/Desktop/finalproject_penpick/node_modules/oracledb/lib/thin/protocol/protocol.js"],"sourcesContent":["// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst constants = require(\"./constants.js\");\nconst Capabilities = require(\"./capabilities.js\");\nconst {WritePacket, ReadPacket} = require(\"./packet.js\");\nconst errors = require(\"../../errors\");\nconst utils = require(\"./utils.js\");\n\n/**\n * Handles protocol details.\n *\n * @class Protocol\n */\nclass Protocol {\n\n  constructor(conn) {\n    this._breakInProgress = false;\n    this.txnInProgress = false;\n    this.connInProgress = true;\n    this.nsi = conn.nscon;\n    this.sequenceId = 1;\n    /**\n     * Compile and Runtime capabilities negotiated with Server\n     * @type {object}\n     */\n    this.caps = new Capabilities(conn.nscon.sAtts.version);\n    this.writeBuf = new WritePacket(conn.nscon, this.caps, this);\n    this.readBuf = new ReadPacket(conn.nscon, this.caps);\n    this.callTimeout = 0;\n  }\n\n  /**\n   * Decodes the message returned by the database. A message may consist of\n   * multiple packets. Not all packets may be available so if insufficient\n   * packets are available, the message decode function is expected to return\n   * the value true if more data is expected to follow.\n   *\n   * If that occurs, waiting occurs until more packets arrive.\n   *\n   * @param {object} message: the RPC dynamic structure specific to the RPC\n   */\n  async _decodeMessage(message) {\n    message.preProcess();\n    await this.readBuf.waitForPackets();\n    while (true) {     // eslint-disable-line\n      if (this.nsi.isBreak) {\n        await this.resetMessage();\n        delete this.readBuf.savedBuffers;\n        await this.readBuf.waitForPackets();\n      }\n      try {\n        message.decode(this.readBuf);\n        break;\n      } catch (err) {\n        if (err instanceof utils.OutOfPacketsError) {\n          if (!this.nsi.isBreak) {\n            await this.readBuf.waitForPackets();\n            this.readBuf.restorePoint();\n          }\n          continue;\n        }\n        throw (err);\n      }\n    }\n    await message.postProcess();\n  }\n\n  /**\n   * Encodes the message to be sent to the database. A message may be encoded\n   * in multiple packets. In order to facilitate encoding of very large\n   * messages consisting of a large number of packets, the message encode\n   * function is expected to return the value true if more data is to follow.\n   *\n   * If that occurs, waiting occurs until the stream has drained and is ready\n   * to accept more data.\n   *\n   * @param {object} message: the RPC dynamic structure specific to the RPC\n   */\n  async _encodeMessage(message) {\n    const adapter = this.nsi.ntAdapter;\n    this.writeBuf.startRequest(constants.TNS_PACKET_TYPE_DATA);\n    while (message.encode(this.writeBuf)) {\n      await adapter.pauseWrite();\n    }\n    this.writeBuf.endRequest();\n  }\n\n  async _recoverFromError(caughtErr, message) {\n    /*\n     * We have NJS error(protocol related) detected during packet write/read\n     * operation.  Issue a break and reset to clear channel . We receive the\n     * response as ORA-1013 from the server.\n     */\n    try {\n      this.breakMessage();\n      this._breakInProgress = false;\n      await this.resetMessage();\n      await this.readBuf.waitForPackets();\n      message.decode(this.readBuf);\n    } catch (err) { // Recovery failed\n      this.nsi.disconnect();\n      const newErr = errors.getErr(errors.ERR_CONNECTION_CLOSED);\n      caughtErr.message = newErr.message +\n        \"\\nError recovery failed: \" + err.message +\n        \"\\nOriginal error: \" + caughtErr.message;\n      throw caughtErr;\n    }\n  }\n\n  /**\n   *\n   * @param {object} message The RPC dynamic structure specific to the RPC\n   * @return {Promise}\n   */\n  async _processMessage(message) {\n    let callTimer;\n    let callTimeoutExpired = false;\n    try {\n      if (this.callTimeout > 0) {\n        callTimer = setTimeout(() => {\n          callTimeoutExpired = true;\n          this.breakMessage();\n        }, this.callTimeout);\n      }\n      await this._encodeMessage(message);\n      if (message.messageType !== constants.TNS_MSG_TYPE_ONEWAY_FN) {\n        await this._decodeMessage(message);\n      }\n    } catch (err) {\n      if (!this.connInProgress &&\n          err.code !== errors.ERR_CONNECTION_CLOSED_CODE) {\n        await this._recoverFromError(err, message);\n      }\n      throw err;\n    } finally {\n      clearTimeout(callTimer);\n    }\n    if (message.flushOutBinds) {\n      await this.flushOutBindMessage(message);\n    }\n    this.txnInProgress = message.callStatus & constants.TNS_TXN_IN_PROGRESS;\n    if (message.errorOccurred) {\n      if (callTimeoutExpired) {\n        errors.throwErr(errors.ERR_CALL_TIMEOUT_EXCEEDED, this.callTimeout);\n      }\n      let err = new Error(message.errorInfo.message);\n      err.offset = message.errorInfo.pos;\n      err.errorNum = message.errorInfo.num;\n      err = errors.transformErr(err);\n      if (err.code === errors.ERR_CONNECTION_CLOSED_CODE) {\n        this.nsi.disconnect();\n      }\n      throw err;\n    }\n  }\n\n  async flushOutBindMessage(message) {\n    this.writeBuf.startRequest(constants.TNS_PACKET_TYPE_DATA);\n    this.writeBuf.writeUInt8(constants.TNS_MSG_TYPE_FLUSH_OUT_BINDS);\n    this.writeBuf.endRequest();\n    await this._decodeMessage(message);\n  }\n\n  /**\n   * Send break packet\n   */\n  breakMessage() {\n    this._breakInProgress = true;\n    this.nsi.sendBreak();\n  }\n\n  /**\n   * Reset the connection\n   */\n  async resetMessage() {\n    await this.nsi.reset();\n  }\n\n}\n\nmodule.exports = Protocol;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}