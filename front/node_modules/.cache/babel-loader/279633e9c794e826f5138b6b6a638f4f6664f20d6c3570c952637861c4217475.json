{"ast":null,"code":"// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\nconst net = require(\"net\");\nconst process = require(\"process\");\nconst tls = require(\"tls\");\nconst http = require(\"http\");\nconst Timers = require('timers');\nconst constants = require(\"./constants.js\");\nconst errors = require(\"../../errors.js\");\nconst {\n  findValue\n} = require(\"./nvStrToNvPair.js\");\nconst PACKET_HEADER_SIZE = 8;\nconst DEFAULT_PORT = 1521;\nconst DEFAULT_HTTPS_PROXY_PORT = 80;\n\n/* Protocol characteristics */\nconst TCPCHA = 1 << 1 | /* ASYNC support */\n1 << 2 | /* Callback support */\n1 << 3 | /* More Data support */\n1 << 8 | /* Read/Write Readiness support */\n1 << 9 | /* Full Duplex support */\n1 << 12; /* SIGPIPE Support */\n\nlet streamNum = 1;\n\n/**\n * Network Transport TCP/TCPS adapter\n * @param {Address} address Destination Address\n * @param {Object} atts Transport Attributes\n */\nclass NTTCP {\n  constructor(atts) {\n    this.atts = atts;\n    this.cha = TCPCHA;\n    this.connected = false;\n    this.err = false;\n    this.needsDrain = false;\n    this.numPacketsSinceLastWait = 0;\n    this.secure = false;\n    this.largeSDU = false;\n    this.streamNum = streamNum++;\n    this.packetNum = 1;\n    this.doDNMatch = true;\n  }\n\n  /**\n   * DN matching funciton(used with TLS)\n   */\n  dnMatch(serverName, cert) {\n    if (this.atts.sslServerDNMatch && this.doDNMatch) {\n      const toObject = str => str.split(',').map(x => x.split('=').map(y => y.trim())).reduce((a, x) => {\n        a[x[0]] = x[1];\n        return a;\n      }, {});\n      if (this.atts.sslServerCertDN) {\n        /* Full DN Match */\n        const obj = toObject(this.atts.sslServerCertDN);\n        if (Object.keys(obj).length == Object.keys(cert.subject).length) {\n          for (const key in obj) {\n            if (obj[key] != cert.subject[key]) {\n              return errors.getErr(errors.ERR_TLS_DNMATCH_FAILURE);\n            }\n          }\n        } else {\n          return errors.getErr(errors.ERR_TLS_DNMATCH_FAILURE);\n        }\n      } else {\n        if (tls.checkServerIdentity(this.hostName, cert) && (!this.originHost || tls.checkServerIdentity(this.originHost, cert))) {\n          /* Hostname match */\n          if (this.atts.sslAllowWeakDNMatch) {\n            const serviceName = findValue(this.atts.cDataNVPair, [\"DESCRIPTION\", \"CONNECT_DATA\", \"SERVICE_NAME\"]); /* Service Name match */\n            if (serviceName != cert.subject.CN) {\n              return errors.getErr(errors.ERR_TLS_DNMATCH_FAILURE);\n            }\n          } else {\n            const hostName = this.hostName + \" \" + (this.originHost ? \"or \" + this.originHost : \"\");\n            return errors.getErr(errors.ERR_TLS_HOSTMATCH_FAILURE, hostName);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * TLS connection establishment\n   * @returns Promise\n   */\n  async tlsConnect(secureContext, connStream) {\n    this.stream.removeAllListeners();\n    let connectErrCause;\n    const tlsOptions = {\n      host: this.host,\n      socket: connStream,\n      rejectUnauthorized: true,\n      secureContext: secureContext,\n      enableTrace: false,\n      checkServerIdentity: this.dnMatch.bind(this)\n    };\n    await new Promise(resolve => {\n      this.stream = tls.connect(tlsOptions, () => {\n        if (!this.stream.authorized) {\n          connectErrCause = \"server certificate unauthorized\";\n        }\n        resolve();\n      }).on('error', err => {\n        connectErrCause = err.message;\n        resolve();\n      });\n    });\n    if (connectErrCause) errors.throwErr(errors.ERR_TLS_AUTH_FAILURE, this.host, this.port, this.atts.connectionId, connectErrCause);\n    this.connStream = connStream;\n  }\n\n  /**\n   * TCP connection establishment\n   * @returns Promise\n   */\n  async ntConnect(address) {\n    if (!address.port) {\n      address.port = DEFAULT_PORT;\n    }\n    let connectErrCause, proxyConnectErrCause, req;\n    const httpsProxy = address.httpsProxy || this.atts.httpsProxy;\n    let httpsProxyPort = address.httpsProxyPort || this.atts.httpsProxyPort;\n    await new Promise(resolve => {\n      if (httpsProxy) {\n        if (!httpsProxyPort) {\n          httpsProxyPort = DEFAULT_HTTPS_PROXY_PORT;\n        }\n        req = http.request({\n          host: httpsProxy,\n          port: httpsProxyPort,\n          method: 'CONNECT',\n          path: address.host + ':' + address.port\n        });\n        req.once('connect', (res, socket) => {\n          if (res.statusCode == 200) {\n            this.connected = true;\n            this.stream = socket;\n          } else {\n            proxyConnectErrCause = res.statusCode;\n          }\n          resolve();\n        });\n        req.once('error', err => {\n          proxyConnectErrCause = err.message;\n          resolve();\n        });\n        req.end();\n      } else {\n        this.stream = net.connect(address.port, address.host, () => {\n          this.connected = true;\n          resolve();\n        });\n        this.stream.once('error', err => {\n          connectErrCause = err.message;\n          resolve();\n        });\n      }\n    });\n    if (req) req.removeAllListeners();\n    if (!this.connected) {\n      if (proxyConnectErrCause) {\n        errors.throwErr(errors.ERR_PROXY_CONNECTION_FAILURE, httpsProxy, httpsProxyPort, this.atts.connectionId, proxyConnectErrCause);\n      } else {\n        errors.throwErr(errors.ERR_CONNECTION_INCOMPLETE, this.host, this.port, this.atts.connectionId, connectErrCause);\n      }\n    }\n  }\n\n  /**\n   * Network Transport connection establishment\n   * @returns Promise\n   */\n  async connect(address) {\n    /* Connect function for TCP sockets */\n    this.originHost = address.originHost;\n    this.host = address.host;\n    this.hostName = address.hostname;\n    this.port = address.port;\n    try {\n      await this.ntConnect(address);\n      if (this.atts.expireTime || this.atts.enableDCD) {\n        /* Set Keep alives */\n        if (this.atts.expireTime) {\n          this.stream.setKeepAlive(true, this.atts.expireTime);\n        } else {\n          this.stream.setKeepAlive(true);\n        }\n      }\n      if (this.atts.tcpNoDelay) {\n        /* Turn off Nagle's unless explicitly enabled by user */\n        this.stream.setNoDelay(true);\n      }\n      if (address.protocol.toUpperCase() == \"TCPS\") {\n        let secureContext;\n        this.secure = true;\n        if (this.atts.sslAllowWeakDNMatch) this.doDNMatch = false; //Don't match initial connect\n        try {\n          secureContext = tls.createSecureContext({\n            cert: this.atts.wallet,\n            key: this.atts.wallet,\n            passphrase: this.atts.walletPassword,\n            ca: this.atts.wallet\n          });\n        } catch (err) {\n          errors.throwErr(errors.ERR_TLS_INIT_FAILURE);\n        }\n        await this.tlsConnect(secureContext, this.stream);\n      }\n    } finally {\n      if (this.stream) {\n        this.setupEventHandlers();\n      }\n    }\n  }\n\n  /**\n   * Disconnect Network Transoprt\n   * @param {int} type\n   * @returns Proimise\n   */\n  disconnect(type) {\n    /* Disconnect function for TCP sockets */\n    if (this.connected && !this.err) {\n      if (type == constants.NSFIMM) this.stream.destroy();else this.stream.end();\n    }\n    this.stream = null;\n    this.connected = false;\n    this.drainWaiter = null;\n    this.readWaiter = null;\n  }\n\n  /**\n   * Get the string containing a packet dump.\n   * @param {Buffer} buffer containing packet data\n   */\n  getPacketDump(buffer) {\n    const lines = [];\n    for (let i = 0; i < buffer.length; i += 8) {\n      const address = i.toString().padStart(4, '0');\n      const block = buffer.slice(i, i + 8);\n      const hexDumpValues = [];\n      const printableValues = [];\n      for (const hexByte of block) {\n        hexDumpValues.push(hexByte.toString(16).toUpperCase().padStart(2, '0'));\n        if (hexByte > 0x20 && hexByte < 0x7f) {\n          printableValues.push(String.fromCharCode(hexByte));\n        } else {\n          printableValues.push(\".\");\n        }\n      }\n      while (hexDumpValues.length < 8) {\n        hexDumpValues.push(\"  \");\n        printableValues.push(\" \");\n      }\n      const hexValuesBlock = hexDumpValues.join(\" \");\n      const printableBlock = printableValues.join(\"\");\n      lines.push(`${address} : ${hexValuesBlock} |${printableBlock}|`);\n    }\n    return lines.join(\"\\n\");\n  }\n\n  /**\n   * Print the packet to the console.\n   * @param {String} operation which was performed\n   * @param {Buffer} buffer containing packet data\n   */\n  printPacket(operation, buffer) {\n    const now = new Date();\n    const formattedDate = `${now.getFullYear()}-${now.getMonth().toString().padStart(2, '0')}-` + `${now.getDay().toString().padStart(2, '0')} ` + `${now.getHours().toString().padStart(2, '0')}:` + `${now.getMinutes().toString().padStart(2, '0')}:` + `${now.getSeconds().toString().padStart(2, '0')}.` + `${now.getMilliseconds().toString().padStart(3, '0')}`;\n    const packetDump = this.getPacketDump(buffer);\n    console.log(`${formattedDate} ${operation}:\\n${packetDump}\\n`);\n  }\n\n  /**\n   * Check for errors\n   */\n  checkErr() {\n    if (!this.connected || this.err) {\n      let err;\n      if (this.savedErr) {\n        err = errors.getErr(errors.ERR_CONNECTION_LOSTCONTACT, this.host, this.port, this.atts.connectionId, this.savedErr.message);\n      } else {\n        err = errors.getErr(errors.ERR_CONNECTION_EOF, this.host, this.port, this.atts.connectionId);\n      }\n      /* Wrap around NJS-500 */\n      const newErr = errors.getErr(errors.ERR_CONNECTION_CLOSED);\n      newErr.message = newErr.message + \"\\n\" + err.message;\n      throw newErr;\n    }\n  }\n\n  /**\n   * Transport Send\n   * @param {Buffer} buf Buffer to send\n   * @returns Promise\n   */\n  send(buf) {\n    this.checkErr();\n    if (process.env.NODE_ORACLEDB_DEBUG_PACKETS) this.printPacket(`Sending packet ${this.packetNum} on stream ${this.streamNum}`, buf);\n    const result = this.stream.write(buf, err => {\n      if (err) {\n        this.savedErr = err;\n        this.err = true;\n        this._notifyWaiters();\n      }\n    });\n    if (!result) {\n      this.needsDrain = true;\n    }\n    this.numPacketsSinceLastWait++;\n    this.packetNum++;\n  }\n\n  /**\n   * Should writing to the transport be paused? This occurs if draining is\n   * required or if the number of packets written since the last pause exceeds\n   * 100 (in order to avoid starvation of the event loop during large writes).\n   */\n  shouldPauseWrite() {\n    return this.needsDrain || this.numPacketsSinceLastWait >= 100;\n  }\n\n  /**\n   * Perform a wait -- if draining is required, then until the drain event is\n   * emitted or if draining is not required, then a simple setImmediate() that\n   * ensures that the event loop is not starved.\n   */\n  async pauseWrite() {\n    this.checkErr();\n    if (this.needsDrain) {\n      await new Promise(resolve => {\n        this.drainWaiter = resolve;\n      });\n      this.checkErr();\n    } else {\n      await new Promise(resolve => Timers.setImmediate(resolve));\n    }\n    this.numPacketsSinceLastWait = 0;\n  }\n\n  /**\n   * Start Async reads\n   */\n  startRead() {\n    let tempBuf;\n    this.packets = [];\n    this.stream.on('data', chunk => {\n      // append buffer if previous chunk(s) were insufficient for a full packet\n      if (tempBuf) {\n        tempBuf = Buffer.concat([tempBuf, chunk]);\n      } else {\n        tempBuf = chunk;\n      }\n      while (tempBuf.length >= PACKET_HEADER_SIZE) {\n        // determine the length of the packet\n        let len;\n        if (this.largeSDU) {\n          len = tempBuf.readUInt32BE();\n        } else {\n          len = tempBuf.readUInt16BE();\n        }\n\n        // not enough for a full packet so wait for more data to arrive\n        if (len > tempBuf.length) break;\n\n        // enough for a full packet, extract details from the packet header\n        // and pass them along for processing\n        const packet = {\n          buf: tempBuf.subarray(0, len),\n          type: tempBuf[4],\n          flags: tempBuf[5],\n          num: this.packetNum++\n        };\n        this.packets.push(packet);\n        if (this.readWaiter) {\n          this.readWaiter();\n          this.readWaiter = null;\n        }\n        if (process.env.NODE_ORACLEDB_DEBUG_PACKETS) this.printPacket(`Receiving packet ${packet.num} on stream ${this.streamNum}`, packet.buf);\n\n        // if the packet consumed all of the bytes (most common scenario), then\n        // simply clear the temporary buffer; otherwise, retain whatever bytes\n        // are unused and see if sufficient data is available for another\n        // packet\n        if (len === tempBuf.length) {\n          tempBuf = null;\n          break;\n        } else {\n          tempBuf = tempBuf.subarray(len);\n        }\n      }\n    });\n  }\n\n  /**\n   * Synchronous receive\n   * @returns a single packet or undefined if no packets are available\n   */\n  syncReceive() {\n    return this.packets.shift();\n  }\n\n  /**\n   * Asynchronous receive\n   * @returns a single packet\n   */\n  async receive() {\n    if (this.packets.length === 0) {\n      this.checkErr();\n      await new Promise(resolve => {\n        this.readWaiter = resolve;\n        this.numPacketsSinceLastWait = 0;\n      });\n      this.checkErr();\n    }\n    return this.packets.shift();\n  }\n\n  /**\n   * TLS renegotiate\n   * @returns Promise\n   */\n  async renegTLS() {\n    try {\n      this.checkErr();\n      this.doDNMatch = true;\n      const secureContext = tls.createSecureContext({\n        cert: this.atts.wallet,\n        key: this.atts.wallet,\n        passphrase: this.atts.walletPassword,\n        ca: this.atts.wallet\n      });\n      await this.tlsConnect(secureContext, this.connStream);\n    } finally {\n      this.setupEventHandlers();\n    }\n  }\n\n  /**\n   * Setup handling of events\n   */\n  setupEventHandlers() {\n    this.stream.removeAllListeners();\n    this.stream.on('error', err => {\n      this.savedErr = err;\n      this.err = true;\n      this._notifyWaiters();\n    });\n    this.stream.on('end', () => {\n      this.err = true;\n      this._notifyWaiters();\n    });\n    this.stream.on('close', () => {\n      this.connected = false;\n      this._notifyWaiters();\n    });\n    this.stream.on('drain', () => {\n      this.needsDrain = false;\n      if (this.drainWaiter) {\n        this.drainWaiter();\n        this.drainWaiter = null;\n      }\n    });\n  }\n\n  /**\n   * Get Transport Attributes\n   * @param {int} opcode type of attribute\n   * @returns attribute value\n   */\n  getOption(opcode) {\n    this.checkErr();\n    switch (opcode) {\n      case constants.NT_MOREDATA:\n        /* More data available to read */\n        return this.packets.length > 0;\n      case constants.REMOTEADDR:\n        /* Remote Address */\n        {\n          const socket = this.secure ? this.connStream : this.stream;\n          return socket.remoteAddress + \":\" + socket.remotePort;\n        }\n      default:\n        errors.throwErr(errors.ERR_INTERNAL, \"getOption not supported for opcode \" + opcode);\n    }\n  }\n\n  /**\n   * Notify the waiters (drain and read) and reset them, if applicable.\n   */\n  _notifyWaiters() {\n    if (this.drainWaiter) {\n      this.drainWaiter();\n      this.drainWaiter = null;\n    }\n    if (this.readWaiter) {\n      this.readWaiter();\n      this.readWaiter = null;\n    }\n  }\n}\nmodule.exports = NTTCP;","map":{"version":3,"names":["Buffer","require","net","process","tls","http","Timers","constants","errors","findValue","PACKET_HEADER_SIZE","DEFAULT_PORT","DEFAULT_HTTPS_PROXY_PORT","TCPCHA","streamNum","NTTCP","constructor","atts","cha","connected","err","needsDrain","numPacketsSinceLastWait","secure","largeSDU","packetNum","doDNMatch","dnMatch","serverName","cert","sslServerDNMatch","toObject","str","split","map","x","y","trim","reduce","a","sslServerCertDN","obj","Object","keys","length","subject","key","getErr","ERR_TLS_DNMATCH_FAILURE","checkServerIdentity","hostName","originHost","sslAllowWeakDNMatch","serviceName","cDataNVPair","CN","ERR_TLS_HOSTMATCH_FAILURE","tlsConnect","secureContext","connStream","stream","removeAllListeners","connectErrCause","tlsOptions","host","socket","rejectUnauthorized","enableTrace","bind","Promise","resolve","connect","authorized","on","message","throwErr","ERR_TLS_AUTH_FAILURE","port","connectionId","ntConnect","address","proxyConnectErrCause","req","httpsProxy","httpsProxyPort","request","method","path","once","res","statusCode","end","ERR_PROXY_CONNECTION_FAILURE","ERR_CONNECTION_INCOMPLETE","hostname","expireTime","enableDCD","setKeepAlive","tcpNoDelay","setNoDelay","protocol","toUpperCase","createSecureContext","wallet","passphrase","walletPassword","ca","ERR_TLS_INIT_FAILURE","setupEventHandlers","disconnect","type","NSFIMM","destroy","drainWaiter","readWaiter","getPacketDump","buffer","lines","i","toString","padStart","block","slice","hexDumpValues","printableValues","hexByte","push","String","fromCharCode","hexValuesBlock","join","printableBlock","printPacket","operation","now","Date","formattedDate","getFullYear","getMonth","getDay","getHours","getMinutes","getSeconds","getMilliseconds","packetDump","console","log","checkErr","savedErr","ERR_CONNECTION_LOSTCONTACT","ERR_CONNECTION_EOF","newErr","ERR_CONNECTION_CLOSED","send","buf","env","NODE_ORACLEDB_DEBUG_PACKETS","result","write","_notifyWaiters","shouldPauseWrite","pauseWrite","setImmediate","startRead","tempBuf","packets","chunk","concat","len","readUInt32BE","readUInt16BE","packet","subarray","flags","num","syncReceive","shift","receive","renegTLS","getOption","opcode","NT_MOREDATA","REMOTEADDR","remoteAddress","remotePort","ERR_INTERNAL","module","exports"],"sources":["C:/Users/user1/Desktop/finalproject_penpick/node_modules/oracledb/lib/thin/sqlnet/ntTcp.js"],"sourcesContent":["// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst { Buffer } = require('buffer');\nconst net = require(\"net\");\nconst process = require(\"process\");\nconst tls = require(\"tls\");\nconst http = require(\"http\");\nconst Timers = require('timers');\nconst constants = require(\"./constants.js\");\nconst errors = require(\"../../errors.js\");\nconst { findValue } = require(\"./nvStrToNvPair.js\");\n\nconst PACKET_HEADER_SIZE = 8;\nconst DEFAULT_PORT = 1521;\nconst DEFAULT_HTTPS_PROXY_PORT = 80;\n\n/* Protocol characteristics */\nconst TCPCHA = 1 << 1 |    /* ASYNC support */\n  1 << 2 |    /* Callback support */\n  1 << 3 |    /* More Data support */\n  1 << 8 |    /* Read/Write Readiness support */\n  1 << 9 |    /* Full Duplex support */\n  1 << 12;    /* SIGPIPE Support */\n\nlet streamNum = 1;\n\n/**\n * Network Transport TCP/TCPS adapter\n * @param {Address} address Destination Address\n * @param {Object} atts Transport Attributes\n */\nclass NTTCP {\n\n  constructor(atts) {\n    this.atts = atts;\n    this.cha = TCPCHA;\n    this.connected = false;\n    this.err = false;\n    this.needsDrain = false;\n    this.numPacketsSinceLastWait = 0;\n    this.secure = false;\n    this.largeSDU = false;\n    this.streamNum = streamNum++;\n    this.packetNum = 1;\n    this.doDNMatch = true;\n  }\n\n  /**\n   * DN matching funciton(used with TLS)\n   */\n  dnMatch(serverName, cert) {\n    if (this.atts.sslServerDNMatch && this.doDNMatch) {\n      const toObject = str =>str .split(',').map(x => x.split('=').map(y => y.trim())).reduce((a, x) => {\n        a[x[0]] = x[1];\n        return a;\n      }, {});\n      if (this.atts.sslServerCertDN) { /* Full DN Match */\n        const obj = toObject(this.atts.sslServerCertDN);\n        if (Object.keys(obj).length == Object.keys(cert.subject).length) {\n          for (const key in obj) {\n            if (obj[key] != cert.subject[key]) {\n              return (errors.getErr(errors.ERR_TLS_DNMATCH_FAILURE));\n            }\n          }\n        } else {\n          return (errors.getErr(errors.ERR_TLS_DNMATCH_FAILURE));\n        }\n      } else {\n        if (tls.checkServerIdentity(this.hostName, cert) && (!this.originHost || tls.checkServerIdentity(this.originHost, cert))) { /* Hostname match */\n          if (this.atts.sslAllowWeakDNMatch) {\n            const serviceName = findValue(this.atts.cDataNVPair, [\"DESCRIPTION\", \"CONNECT_DATA\", \"SERVICE_NAME\"]); /* Service Name match */\n            if (serviceName != cert.subject.CN) {\n              return (errors.getErr(errors.ERR_TLS_DNMATCH_FAILURE));\n            }\n          } else {\n            const hostName = this.hostName + \" \"  + (this.originHost ? \"or \" + this.originHost : \"\");\n            return (errors.getErr(errors.ERR_TLS_HOSTMATCH_FAILURE, hostName));\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * TLS connection establishment\n   * @returns Promise\n   */\n  async tlsConnect(secureContext, connStream) {\n    this.stream.removeAllListeners();\n    let connectErrCause;\n    const tlsOptions = {\n      host: this.host,\n      socket: connStream,\n      rejectUnauthorized: true,\n      secureContext: secureContext,\n      enableTrace: false,\n      checkServerIdentity: this.dnMatch.bind(this)\n    };\n\n    await new Promise((resolve) => {\n      this.stream = tls.connect(tlsOptions, () => {\n        if (!this.stream.authorized) {\n          connectErrCause = \"server certificate unauthorized\";\n        }\n        resolve();\n      }).on('error', (err) => {\n        connectErrCause = err.message;\n        resolve();\n      });\n    });\n    if (connectErrCause)\n      errors.throwErr(errors.ERR_TLS_AUTH_FAILURE, this.host, this.port, this.atts.connectionId, connectErrCause);\n    this.connStream = connStream;\n  }\n\n  /**\n   * TCP connection establishment\n   * @returns Promise\n   */\n  async ntConnect(address) {\n    if (!address.port) {\n      address.port = DEFAULT_PORT;\n    }\n\n    let connectErrCause, proxyConnectErrCause, req;\n    const httpsProxy = address.httpsProxy || this.atts.httpsProxy;\n    let httpsProxyPort = address.httpsProxyPort || this.atts.httpsProxyPort;\n\n    await new Promise((resolve) => {\n      if (httpsProxy) {\n        if (!httpsProxyPort) {\n          httpsProxyPort = DEFAULT_HTTPS_PROXY_PORT;\n        }\n        req = http.request({\n          host: httpsProxy,\n          port: httpsProxyPort,\n          method: 'CONNECT',\n          path: address.host + ':' + address.port,\n        });\n        req.once('connect', (res, socket) => {\n          if (res.statusCode == 200) {\n            this.connected = true;\n            this.stream = socket;\n          } else {\n            proxyConnectErrCause = res.statusCode;\n          }\n          resolve();\n        });\n        req.once('error', (err) => {\n          proxyConnectErrCause = err.message;\n          resolve();\n        });\n        req.end();\n      } else {\n        this.stream = net.connect(address.port, address.host, () => {\n          this.connected = true;\n          resolve();\n        });\n        this.stream.once('error', (err) => {\n          connectErrCause = err.message;\n          resolve();\n        });\n      }\n    });\n    if (req)\n      req.removeAllListeners();\n    if (!this.connected) {\n      if (proxyConnectErrCause) {\n        errors.throwErr(errors.ERR_PROXY_CONNECTION_FAILURE, httpsProxy, httpsProxyPort, this.atts.connectionId, proxyConnectErrCause);\n      } else {\n        errors.throwErr(errors.ERR_CONNECTION_INCOMPLETE, this.host, this.port, this.atts.connectionId, connectErrCause);\n      }\n    }\n  }\n\n  /**\n   * Network Transport connection establishment\n   * @returns Promise\n   */\n  async connect(address) {  /* Connect function for TCP sockets */\n    this.originHost = address.originHost;\n    this.host = address.host;\n    this.hostName = address.hostname;\n    this.port = address.port;\n\n    try {\n      await this.ntConnect(address);\n      if (this.atts.expireTime || this.atts.enableDCD) {  /* Set Keep alives */\n        if (this.atts.expireTime) {\n          this.stream.setKeepAlive(true, this.atts.expireTime);\n        } else {\n          this.stream.setKeepAlive(true);\n        }\n      }\n      if (this.atts.tcpNoDelay) {  /* Turn off Nagle's unless explicitly enabled by user */\n        this.stream.setNoDelay(true);\n      }\n      if (address.protocol.toUpperCase() == \"TCPS\") {\n        let secureContext;\n        this.secure = true;\n        if (this.atts.sslAllowWeakDNMatch)\n          this.doDNMatch = false; //Don't match initial connect\n        try {\n          secureContext = tls.createSecureContext({\n            cert: this.atts.wallet,\n            key: this.atts.wallet,\n            passphrase: this.atts.walletPassword,\n            ca: this.atts.wallet,\n          });\n        } catch (err) {\n          errors.throwErr(errors.ERR_TLS_INIT_FAILURE);\n        }\n        await this.tlsConnect(secureContext, this.stream);\n      }\n    } finally {\n      if (this.stream) {\n        this.setupEventHandlers();\n      }\n    }\n  }\n\n  /**\n   * Disconnect Network Transoprt\n   * @param {int} type\n   * @returns Proimise\n   */\n  disconnect(type) {   /* Disconnect function for TCP sockets */\n    if (this.connected && !this.err) {\n      if (type == constants.NSFIMM)\n        this.stream.destroy();\n      else\n        this.stream.end();\n    }\n    this.stream = null;\n    this.connected = false;\n    this.drainWaiter = null;\n    this.readWaiter = null;\n  }\n\n  /**\n   * Get the string containing a packet dump.\n   * @param {Buffer} buffer containing packet data\n   */\n  getPacketDump(buffer) {\n    const lines = [];\n    for (let i = 0; i < buffer.length; i += 8) {\n      const address = i.toString().padStart(4, '0');\n      const block = buffer.slice(i, i + 8);\n      const hexDumpValues = [];\n      const printableValues = [];\n      for (const hexByte of block) {\n        hexDumpValues.push(hexByte.toString(16).toUpperCase().padStart(2, '0'));\n        if (hexByte > 0x20 && hexByte < 0x7f) {\n          printableValues.push(String.fromCharCode(hexByte));\n        } else {\n          printableValues.push(\".\");\n        }\n      }\n      while (hexDumpValues.length < 8) {\n        hexDumpValues.push(\"  \");\n        printableValues.push(\" \");\n      }\n      const hexValuesBlock = hexDumpValues.join(\" \");\n      const printableBlock = printableValues.join(\"\");\n      lines.push(`${address} : ${hexValuesBlock} |${printableBlock}|`);\n    }\n    return lines.join(\"\\n\");\n  }\n\n  /**\n   * Print the packet to the console.\n   * @param {String} operation which was performed\n   * @param {Buffer} buffer containing packet data\n   */\n  printPacket(operation, buffer) {\n    const now = new Date();\n    const formattedDate =\n      `${now.getFullYear()}-${now.getMonth().toString().padStart(2, '0')}-` +\n      `${now.getDay().toString().padStart(2, '0')} ` +\n      `${now.getHours().toString().padStart(2, '0')}:` +\n      `${now.getMinutes().toString().padStart(2, '0')}:` +\n      `${now.getSeconds().toString().padStart(2, '0')}.` +\n      `${now.getMilliseconds().toString().padStart(3, '0')}`;\n    const packetDump = this.getPacketDump(buffer);\n    console.log(`${formattedDate} ${operation}:\\n${packetDump}\\n`);\n  }\n\n  /**\n   * Check for errors\n   */\n  checkErr() {\n    if (!this.connected || this.err) {\n      let err;\n      if (this.savedErr) {\n        err = errors.getErr(errors.ERR_CONNECTION_LOSTCONTACT,\n          this.host, this.port,  this.atts.connectionId, this.savedErr.message);\n      } else {\n        err = errors.getErr(errors.ERR_CONNECTION_EOF, this.host, this.port, this.atts.connectionId,);\n      }\n      /* Wrap around NJS-500 */\n      const newErr = errors.getErr(errors.ERR_CONNECTION_CLOSED);\n      newErr.message = newErr.message + \"\\n\" + err.message;\n      throw (newErr);\n    }\n  }\n\n  /**\n   * Transport Send\n   * @param {Buffer} buf Buffer to send\n   * @returns Promise\n   */\n  send(buf) {\n    this.checkErr();\n    if (process.env.NODE_ORACLEDB_DEBUG_PACKETS)\n      this.printPacket(`Sending packet ${this.packetNum} on stream ${this.streamNum}`, buf);\n    const result = this.stream.write(buf, (err) => {\n      if (err) {\n        this.savedErr = err;\n        this.err = true;\n        this._notifyWaiters();\n      }\n    });\n    if (!result) {\n      this.needsDrain = true;\n    }\n    this.numPacketsSinceLastWait++;\n    this.packetNum++;\n  }\n\n  /**\n   * Should writing to the transport be paused? This occurs if draining is\n   * required or if the number of packets written since the last pause exceeds\n   * 100 (in order to avoid starvation of the event loop during large writes).\n   */\n  shouldPauseWrite() {\n    return (this.needsDrain || this.numPacketsSinceLastWait >= 100);\n  }\n\n  /**\n   * Perform a wait -- if draining is required, then until the drain event is\n   * emitted or if draining is not required, then a simple setImmediate() that\n   * ensures that the event loop is not starved.\n   */\n  async pauseWrite() {\n    this.checkErr();\n    if (this.needsDrain) {\n      await new Promise((resolve) => {\n        this.drainWaiter = resolve;\n      });\n      this.checkErr();\n    } else {\n      await new Promise((resolve) => Timers.setImmediate(resolve));\n    }\n    this.numPacketsSinceLastWait = 0;\n  }\n\n  /**\n   * Start Async reads\n   */\n  startRead() {\n    let tempBuf;\n    this.packets = [];\n    this.stream.on('data', (chunk) => {\n\n      // append buffer if previous chunk(s) were insufficient for a full packet\n      if (tempBuf) {\n        tempBuf = Buffer.concat([tempBuf, chunk]);\n      } else {\n        tempBuf = chunk;\n      }\n\n      while (tempBuf.length >= PACKET_HEADER_SIZE) {\n\n        // determine the length of the packet\n        let len;\n        if (this.largeSDU) {\n          len = tempBuf.readUInt32BE();\n        } else {\n          len = tempBuf.readUInt16BE();\n        }\n\n        // not enough for a full packet so wait for more data to arrive\n        if (len > tempBuf.length)\n          break;\n\n        // enough for a full packet, extract details from the packet header\n        // and pass them along for processing\n        const packet = {\n          buf: tempBuf.subarray(0, len),\n          type: tempBuf[4],\n          flags: tempBuf[5],\n          num: this.packetNum++\n        };\n        this.packets.push(packet);\n        if (this.readWaiter) {\n          this.readWaiter();\n          this.readWaiter = null;\n        }\n        if (process.env.NODE_ORACLEDB_DEBUG_PACKETS)\n          this.printPacket(`Receiving packet ${packet.num} on stream ${this.streamNum}`, packet.buf);\n\n        // if the packet consumed all of the bytes (most common scenario), then\n        // simply clear the temporary buffer; otherwise, retain whatever bytes\n        // are unused and see if sufficient data is available for another\n        // packet\n        if (len === tempBuf.length) {\n          tempBuf = null;\n          break;\n        } else {\n          tempBuf = tempBuf.subarray(len);\n        }\n\n      }\n\n    });\n  }\n\n  /**\n   * Synchronous receive\n   * @returns a single packet or undefined if no packets are available\n   */\n  syncReceive() {\n    return this.packets.shift();\n  }\n\n  /**\n   * Asynchronous receive\n   * @returns a single packet\n   */\n  async receive() {\n    if (this.packets.length === 0) {\n      this.checkErr();\n      await new Promise((resolve) => {\n        this.readWaiter = resolve;\n        this.numPacketsSinceLastWait = 0;\n      });\n      this.checkErr();\n    }\n    return this.packets.shift();\n  }\n\n  /**\n   * TLS renegotiate\n   * @returns Promise\n   */\n  async renegTLS() {\n    try {\n      this.checkErr();\n      this.doDNMatch = true;\n      const secureContext = tls.createSecureContext({\n        cert: this.atts.wallet,\n        key: this.atts.wallet,\n        passphrase: this.atts.walletPassword,\n        ca: this.atts.wallet,\n      });\n      await this.tlsConnect(secureContext, this.connStream);\n    } finally {\n      this.setupEventHandlers();\n    }\n  }\n\n  /**\n   * Setup handling of events\n   */\n  setupEventHandlers() {\n    this.stream.removeAllListeners();\n\n    this.stream.on('error', (err) => {\n      this.savedErr = err;\n      this.err = true;\n      this._notifyWaiters();\n    });\n\n    this.stream.on('end', () => {\n      this.err = true;\n      this._notifyWaiters();\n    });\n\n    this.stream.on('close', () => {\n      this.connected = false;\n      this._notifyWaiters();\n    });\n\n    this.stream.on('drain', () => {\n      this.needsDrain = false;\n      if (this.drainWaiter) {\n        this.drainWaiter();\n        this.drainWaiter = null;\n      }\n    });\n\n  }\n\n  /**\n   * Get Transport Attributes\n   * @param {int} opcode type of attribute\n   * @returns attribute value\n   */\n  getOption(opcode) {\n    this.checkErr();\n    switch (opcode) {\n      case constants.NT_MOREDATA: /* More data available to read */\n        return (this.packets.length > 0);\n      case constants.REMOTEADDR: /* Remote Address */\n      {\n        const socket = this.secure ? this.connStream : this.stream;\n        return (socket.remoteAddress + \":\" + socket.remotePort);\n      }\n      default:\n        errors.throwErr(errors.ERR_INTERNAL, \"getOption not supported for opcode \" + opcode);\n    }\n  }\n\n  /**\n   * Notify the waiters (drain and read) and reset them, if applicable.\n   */\n  _notifyWaiters() {\n    if (this.drainWaiter) {\n      this.drainWaiter();\n      this.drainWaiter = null;\n    }\n    if (this.readWaiter) {\n      this.readWaiter();\n      this.readWaiter = null;\n    }\n  }\n\n}\n\nmodule.exports = NTTCP;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}