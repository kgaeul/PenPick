{"ast":null,"code":"// Copyright (c) 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\nconst constants = require('./protocol/constants.js');\nconst errors = require('../errors.js');\nconst types = require('../types.js');\nconst DbObjectImpl = require('../impl/dbObject.js');\nconst {\n  GrowableBuffer\n} = require('./protocol/buffer.js');\nconst ThinLobImpl = require('./lob.js');\nclass DbObjectPickleBuffer extends GrowableBuffer {\n  //---------------------------------------------------------------------------\n  // _readBytesWithLength()\n  //\n  // Helper function that processes the number of bytes (if needed) and then\n  // acquires the specified number of bytes from the buffer.\n  //---------------------------------------------------------------------------\n  _readBytesWithLength(numBytes) {\n    if (numBytes === constants.TNS_LONG_LENGTH_INDICATOR) {\n      numBytes = this.readUInt32BE();\n    }\n    return this.readBytes(numBytes);\n  }\n\n  //---------------------------------------------------------------------------\n  // getIsAtomicNull()\n  //\n  // Reads the next byte and checks to see if the value is atomically null. If\n  // not, the byte is returned to the buffer for further processing.\n  //---------------------------------------------------------------------------\n  getIsAtomicNull() {\n    const value = this.readUInt8();\n    if (value === constants.TNS_OBJ_ATOMIC_NULL || value === constants.TNS_NULL_LENGTH_INDICATOR) {\n      return true;\n    }\n    this.pos -= 1;\n    return false;\n  }\n\n  //---------------------------------------------------------------------------\n  // readHeader()\n  //\n  // Reads the header of the pickled data.\n  //---------------------------------------------------------------------------\n  readHeader(obj) {\n    obj.imageFlags = this.readUInt8();\n    obj.imageVersion = this.readUInt8();\n    this.readLength();\n    if ((obj.imageFlags & constants.TNS_OBJ_NO_PREFIX_SEG) === 0) {\n      const prefixSegLength = this.readLength();\n      this.skipBytes(prefixSegLength);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // readLength()\n  //\n  // Read the length from the buffer. This will be a single byte, unless the\n  // value meets or exeeds TNS_LONG_LENGTH_INDICATOR. In that case, the value\n  // is stored as a 4-byte integer.\n  //---------------------------------------------------------------------------\n  readLength() {\n    const shortLength = this.readUInt8();\n    if (shortLength !== constants.TNS_LONG_LENGTH_INDICATOR) {\n      return shortLength;\n    }\n    return this.readUInt32BE();\n  }\n\n  //---------------------------------------------------------------------------\n  // writeHeader()\n  //\n  // Writes the header of the pickled data. Since the size is unknown at this\n  // point, zero is written initially and the actual size is written later.\n  //---------------------------------------------------------------------------\n  writeHeader(obj) {\n    this.writeUInt8(obj.imageFlags);\n    this.writeUInt8(obj.imageVersion);\n    this.writeUInt8(constants.TNS_LONG_LENGTH_INDICATOR);\n    this.writeUInt32BE(0);\n    if (obj._objType.isCollection) {\n      this.writeUInt8(1); // length of prefix segment\n      this.writeUInt8(1); // prefix segment contents\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // writeLength()\n  //\n  // Writes the length to the buffer.\n  //---------------------------------------------------------------------------\n  writeLength(length) {\n    if (length <= constants.TNS_OBJ_MAX_SHORT_LENGTH) {\n      this.writeUInt8(length);\n    } else {\n      this.writeUInt8(constants.TNS_LONG_LENGTH_INDICATOR);\n      this.writeUInt32BE(length);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _writeRawBytesAndLength()\n  //\n  // Writes the length in the format required before\n  // writing the bytes.\n  //---------------------------------------------------------------------------\n  _writeRawBytesAndLength(value, numBytes) {\n    this.writeLength(numBytes);\n    this.writeBytes(value);\n  }\n}\nclass ThinDbObjectImpl extends DbObjectImpl {\n  constructor(objType, packedData) {\n    if (typeof objType === 'function') {\n      objType = objType.prototype._objType;\n    }\n    super(objType);\n    this.packedData = packedData;\n    this.unpackedAttrs = new Map();\n    if (packedData) {\n      this.unpackedAssocArray = new Map();\n      this.unpackedAssocKeys = undefined;\n    } else if (objType) {\n      const prefix = Buffer.from([0, 0x22, constants.TNS_OBJ_NON_NULL_OID, constants.TNS_OBJ_HAS_EXTENT_OID]);\n      this.toid = Buffer.concat([prefix, objType.oid, constants.TNS_EXTENT_OID]);\n      this.flags = constants.TNS_OBJ_TOP_LEVEL;\n      this.imageFlags = constants.TNS_OBJ_IS_VERSION_81;\n      this.imageVersion = constants.TNS_OBJ_IMAGE_VERSION;\n      if (objType.isCollection) {\n        this.imageFlags |= constants.TNS_OBJ_IS_COLLECTION;\n        if (objType.collectionType === constants.TNS_OBJ_PLSQL_INDEX_TABLE) {\n          this.unpackedAssocArray = new Map();\n        } else {\n          this.unpackedArray = [];\n        }\n      } else {\n        this.imageFlags |= constants.TNS_OBJ_NO_PREFIX_SEG;\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _ensureAssocKeys()\n  //\n  // Ensure that the keys for the associative array have been calculated.\n  // PL/SQL associative arrays keep their keys in sorted order so this must be\n  // calculated when indices are required.\n  //---------------------------------------------------------------------------\n  _ensureAssocKeys() {\n    if (!this.unpackedAssocKeys) {\n      this.unpackedAssocKeys = [...this.unpackedAssocArray.keys()].sort();\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _ensureUnpacked()\n  //\n  // Ensure that the data has been unpacked.\n  //---------------------------------------------------------------------------\n  _ensureUnpacked() {\n    if (this.packedData) {\n      this._unpackData();\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _getPackedData()\n  //\n  // Returns the packed data for the object. This will either be the value\n  // retrieved from the database or generated packed data (for new objects and\n  // those that have had their data unpacked already).\n  //---------------------------------------------------------------------------\n  _getPackedData() {\n    if (this.packedData) return this.packedData;\n    const buf = new DbObjectPickleBuffer();\n    buf.writeHeader(this);\n    this._packData(buf);\n    const size = buf.pos;\n    buf.pos = 3;\n    buf.writeUInt32BE(size);\n    return buf.buf.subarray(0, size);\n  }\n\n  //---------------------------------------------------------------------------\n  // _packData()\n  //\n  // Packs the data from the object into the buffer.\n  //---------------------------------------------------------------------------\n  _packData(buf) {\n    const objType = this._objType;\n    if (objType.isCollection) {\n      buf.writeUInt8(objType.collectionFlags);\n      if (objType.collectionType === constants.TNS_OBJ_PLSQL_INDEX_TABLE) {\n        this._ensureAssocKeys();\n        buf.writeLength(this.unpackedAssocKeys.length);\n        for (const index of this.unpackedAssocKeys) {\n          buf.writeInt32BE(index);\n          this._packValue(buf, objType.elementType, objType.elementTypeClass, this.unpackedAssocArray.get(index));\n        }\n      } else {\n        buf.writeLength(this.unpackedArray.length);\n        for (const value of this.unpackedArray) {\n          this._packValue(buf, objType.elementType, objType.elementTypeClass, value);\n        }\n      }\n    } else {\n      for (const attr of objType.attributes) {\n        this._packValue(buf, attr.type, attr.typeClass, this.unpackedAttrs.get(attr.name));\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _packValue()\n  //\n  // Packs a value into the buffer. At this point it is assumed that the value\n  // matches the correct type.\n  //---------------------------------------------------------------------------\n  _packValue(buf, type, typeClass, value) {\n    if (value === null || value === undefined) {\n      if (typeClass && !typeClass.prototype.isCollection) {\n        buf.writeUInt8(constants.TNS_OBJ_ATOMIC_NULL);\n      } else {\n        buf.writeUInt8(constants.TNS_NULL_LENGTH_INDICATOR);\n      }\n    } else {\n      switch (type) {\n        case types.DB_TYPE_CHAR:\n        case types.DB_TYPE_VARCHAR:\n          buf.writeBytesWithLength(Buffer.from(value));\n          break;\n        case types.DB_TYPE_NCHAR:\n        case types.DB_TYPE_NVARCHAR:\n          buf.writeBytesWithLength(Buffer.from(value, 'utf16le').swap16());\n          break;\n        case types.DB_TYPE_NUMBER:\n          buf.writeOracleNumber(value.toString());\n          break;\n        case types.DB_TYPE_BINARY_INTEGER:\n        case types.DB_TYPE_BOOLEAN:\n          buf.writeUInt8(4);\n          buf.writeUInt32BE(value);\n          break;\n        case types.DB_TYPE_RAW:\n          buf.writeBytesWithLength(value);\n          break;\n        case types.DB_TYPE_BINARY_DOUBLE:\n          buf.writeBinaryDouble(value);\n          break;\n        case types.DB_TYPE_BINARY_FLOAT:\n          buf.writeBinaryFloat(value);\n          break;\n        case types.DB_TYPE_DATE:\n        case types.DB_TYPE_TIMESTAMP:\n        case types.DB_TYPE_TIMESTAMP_LTZ:\n        case types.DB_TYPE_TIMESTAMP_TZ:\n          buf.writeOracleDate(value, type);\n          break;\n        case types.DB_TYPE_OBJECT:\n          if (this._objType.isCollection || value._objType.isCollection) {\n            buf.writeBytesWithLength(value._getPackedData());\n          } else {\n            value._packData(buf);\n          }\n          break;\n        default:\n          errors.throwErr(errors.ERR_NOT_IMPLEMENTED, type);\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _unpackData()\n  //\n  // Unpacks the packed data into a map of JavaScript values.\n  //---------------------------------------------------------------------------\n  _unpackData() {\n    const buf = new DbObjectPickleBuffer(this.packedData);\n    buf.readHeader(this);\n    this._unpackDataFromBuf(buf);\n    this.packedData = undefined;\n  }\n\n  //---------------------------------------------------------------------------\n  // _unpackDataFromBuf()\n  //\n  // Unpacks the data in the buffer into a map of JavaScript values.\n  //---------------------------------------------------------------------------\n  _unpackDataFromBuf(buf) {\n    let unpackedArray, unpackedAssocArray, assocIndex, unpackedAttrs;\n    const objType = this._objType;\n    if (objType.isCollection) {\n      if (objType.collectionType === constants.TNS_OBJ_PLSQL_INDEX_TABLE) {\n        unpackedAssocArray = new Map();\n      } else {\n        unpackedArray = [];\n      }\n      this.collectionFlags = buf.readUInt8();\n      const numElements = buf.readLength();\n      for (let i = 0; i < numElements; i++) {\n        if (objType.collectionType === constants.TNS_OBJ_PLSQL_INDEX_TABLE) {\n          assocIndex = buf.readUInt32BE();\n        }\n        const value = this._unpackValue(buf, objType.elementType, objType.elementTypeClass);\n        if (objType.collectionType === constants.TNS_OBJ_PLSQL_INDEX_TABLE) {\n          unpackedAssocArray.set(assocIndex, value);\n        } else {\n          unpackedArray.push(value);\n        }\n      }\n    } else {\n      unpackedAttrs = new Map();\n      for (const attr of objType.attributes) {\n        const value = this._unpackValue(buf, attr.type, attr.typeClass);\n        unpackedAttrs.set(attr.name, value);\n      }\n    }\n    this.unpackedAttrs = unpackedAttrs;\n    this.unpackedArray = unpackedArray;\n    this.unpackedAssocArray = unpackedAssocArray;\n  }\n\n  //---------------------------------------------------------------------------\n  // _unpackValue()\n  //\n  // Unpacks a single value and returns it.\n  //---------------------------------------------------------------------------\n  _unpackValue(buf, type, typeClass) {\n    let isNull, obj, value;\n    switch (type) {\n      case types.DB_TYPE_NUMBER:\n        value = buf.readOracleNumber();\n        if (value !== null) value = parseFloat(value);\n        return value;\n      case types.DB_TYPE_BINARY_INTEGER:\n        return buf.readBinaryInteger();\n      case types.DB_TYPE_VARCHAR:\n      case types.DB_TYPE_CHAR:\n        return buf.readStr(constants.CSFRM_IMPLICIT);\n      case types.DB_TYPE_NVARCHAR:\n      case types.DB_TYPE_NCHAR:\n        return buf.readStr(constants.CSFRM_NCHAR);\n      case types.DB_TYPE_RAW:\n        value = buf.readBytesWithLength();\n        if (value !== null) value = Buffer.from(value);\n        return value;\n      case types.DB_TYPE_BINARY_DOUBLE:\n        return buf.readBinaryDouble();\n      case types.DB_TYPE_BINARY_FLOAT:\n        return buf.readBinaryFloat();\n      case types.DB_TYPE_DATE:\n      case types.DB_TYPE_TIMESTAMP:\n        return buf.readOracleDate(true);\n      case types.DB_TYPE_TIMESTAMP_LTZ:\n      case types.DB_TYPE_TIMESTAMP_TZ:\n        return buf.readOracleDate(false);\n      case types.DB_TYPE_BOOLEAN:\n        return buf.readBool();\n      case types.DB_TYPE_OBJECT:\n        isNull = buf.getIsAtomicNull();\n        if (isNull) return null;\n        obj = new ThinDbObjectImpl(typeClass);\n        if (obj._objType.isCollection || this._objType.isCollection) {\n          obj.packedData = Buffer.from(buf.readBytesWithLength());\n        } else {\n          obj._unpackDataFromBuf(buf);\n        }\n        return obj;\n      default:\n        errors.throwErr(errors.ERR_NOT_IMPLEMENTED, type);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // append()\n  //\n  // Appends an element to the collection.\n  //---------------------------------------------------------------------------\n  append(value) {\n    this._ensureUnpacked();\n    if (this.unpackedArray) {\n      const objType = this._objType;\n      if (objType.maxNumElements > 0 && this.unpackedArray.length >= objType.maxNumElements) {\n        errors.throwErr(errors.ERR_INVALID_COLL_INDEX_SET, this.unpackedArray.length, 0, objType.maxNumElements);\n      }\n      this.unpackedArray.push(value);\n    } else {\n      this._ensureAssocKeys();\n      let newIndex;\n      if (this.unpackedAssocKeys.length === 0) {\n        newIndex = 0;\n      } else {\n        const keyIndex = this.unpackedAssocKeys.length - 1;\n        newIndex = this.unpackedAssocKeys[keyIndex] + 1;\n      }\n      this.unpackedAssocArray.set(newIndex, value);\n      this.unpackedAssocKeys.push(newIndex);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // deleteElement()\n  //\n  // Deletes an element from a collection.\n  //---------------------------------------------------------------------------\n  deleteElement(index) {\n    this._ensureUnpacked();\n    if (this.unpackedArray) {\n      if (this._objType.collectionType == constants.TNS_OBJ_VARRAY) {\n        errors.throwErr(errors.ERR_DELETE_ELEMENTS_OF_VARRAY);\n      }\n      this.unpackedArray.splice(index, 1);\n    } else {\n      this._unpackedAssocKeys = undefined;\n      this.unpackedAssocArray.delete(index);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // getAttrValue()\n  //\n  // Returns the value of the given attribute on the object.\n  //---------------------------------------------------------------------------\n  getAttrValue(attr) {\n    this._ensureUnpacked();\n    const value = this.unpackedAttrs.get(attr.name);\n    if (value === undefined) return null;\n    return value;\n  }\n\n  //---------------------------------------------------------------------------\n  // getElement()\n  //\n  // Returns an element from the collection.\n  //---------------------------------------------------------------------------\n  getElement(index) {\n    let value;\n    this._ensureUnpacked();\n    if (this.unpackedArray) {\n      value = this.unpackedArray[index];\n    } else {\n      value = this.unpackedAssocArray.get(index);\n    }\n    if (value === undefined) {\n      errors.throwErr(errors.ERR_INVALID_COLL_INDEX_GET, index);\n    }\n    return value;\n  }\n\n  //---------------------------------------------------------------------------\n  // getFirstIndex()\n  //\n  // Returns the first index in a collection.\n  //---------------------------------------------------------------------------\n  getFirstIndex() {\n    this._ensureUnpacked();\n    if (this.unpackedArray) {\n      return 0;\n    } else if (this.unpackedAssocArray) {\n      this._ensureAssocKeys();\n      return this.unpackedAssocKeys[0];\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // getKeys()\n  //\n  // Returns the keys of the collection in a JavaScript array.\n  //---------------------------------------------------------------------------\n  getKeys() {\n    this._ensureUnpacked();\n    if (this.unpackedArray) {\n      return Array.from(this.unpackedArray.keys());\n    } else if (this.unpackedAssocArray) {\n      this._ensureAssocKeys();\n      return Array.from(this.unpackedAssocKeys);\n    }\n    return [];\n  }\n\n  //---------------------------------------------------------------------------\n  // getLastIndex()\n  //\n  // Returns the last index in a collection.\n  //---------------------------------------------------------------------------\n  getLastIndex() {\n    this._ensureUnpacked();\n    if (this.unpackedArray) {\n      if (this.unpackedArray.length > 0) return this.unpackedArray.length - 1;\n    } else if (this.unpackedAssocArray) {\n      this._ensureAssocKeys();\n      return this.unpackedAssocKeys[this.unpackedAssocKeys.length - 1];\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // getNextIndex()\n  //\n  // Returns the next index in a collection.\n  //---------------------------------------------------------------------------\n  getNextIndex(index) {\n    this._ensureUnpacked();\n    if (this.unpackedArray) {\n      if (index + 1 < this.unpackedArray.length) {\n        return index + 1;\n      }\n    } else if (this.unpackedAssocArray) {\n      this._ensureAssocKeys();\n      for (const key of this.unpackedAssocKeys) {\n        if (key > index) return key;\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // getPrevIndex()\n  //\n  // Returns the previous index in a collection.\n  //---------------------------------------------------------------------------\n  getPrevIndex(index) {\n    this._ensureUnpacked();\n    if (this.unpackedArray) {\n      if (index > 0) {\n        return index - 1;\n      }\n    } else if (this.unpackedAssocArray) {\n      this._ensureAssocKeys();\n      for (const key of this.unpackedAssocKeys.reverse()) {\n        if (key < index) return key;\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // getValues()\n  //\n  // Returns the values of the collection in a JavaScript array.\n  //---------------------------------------------------------------------------\n  getValues() {\n    const result = [];\n    this._ensureUnpacked();\n    if (this.unpackedArray) {\n      return Array.from(this.unpackedArray);\n    } else if (this.unpackedAssocArray) {\n      this._ensureAssocKeys();\n      for (const key of this.unpackedAssocKeys) {\n        result.push(this.unpackedAssocArray.get(key));\n      }\n    }\n    return result;\n  }\n\n  //---------------------------------------------------------------------------\n  // hasElement()\n  //\n  // Returns whether an element exists at the given index.\n  //---------------------------------------------------------------------------\n  hasElement(index) {\n    this._ensureUnpacked();\n    if (this.unpackedArray) {\n      return index >= 0 && index < this.unpackedArray.length;\n    }\n    return this.unpackedAssocArray.has(index);\n  }\n\n  //---------------------------------------------------------------------------\n  // setAttrValue()\n  //\n  // Sets the value of the attribute on the object to the given value.\n  //---------------------------------------------------------------------------\n  setAttrValue(attr, value) {\n    this._ensureUnpacked();\n    this.unpackedAttrs.set(attr.name, value);\n  }\n\n  //---------------------------------------------------------------------------\n  // setElement()\n  //\n  // Sets an entry in a collection that is indexed by integers.\n  //---------------------------------------------------------------------------\n  setElement(index, value) {\n    this._ensureUnpacked();\n    if (this.unpackedArray) {\n      const maxIndex = Math.max(this.unpackedArray.length - 1, 0);\n      if (index > maxIndex) {\n        errors.throwErr(errors.ERR_INVALID_COLL_INDEX_SET, index, 0, maxIndex);\n      }\n      this.unpackedArray[index] = value;\n    } else {\n      if (!this.unpackedAssocArray.has(index)) this.unpackedAssocKeys = undefined;\n      this.unpackedAssocArray.set(index, value);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // trim()\n  //\n  // Trim the specified number of elements from the end of the collection.\n  //---------------------------------------------------------------------------\n  trim(numToTrim) {\n    this._ensureUnpacked();\n    if (numToTrim > 0) {\n      this.unpackedArray = this.unpackedArray.slice(0, this.unpackedArray.length - numToTrim);\n    }\n  }\n}\n\n//---------------------------------------------------------------------------\n// readXML()\n//\n// Decodes the raw Bytes to XML string or LOB object.\n//\n//---------------------------------------------------------------------------\nfunction readXML(conn, buf) {\n  let colValue;\n  const xmlObj = new DbObjectPickleBuffer(buf);\n  const tempobj = {};\n  xmlObj.readHeader(tempobj);\n  xmlObj.skipBytes(1);\n  const xmlflag = xmlObj.readUInt32BE();\n  if (xmlflag & constants.TNS_XML_TYPE_FLAG_SKIP_NEXT_4) {\n    xmlObj.skipBytes(4);\n  }\n  const numBytesLeft = xmlObj.numBytesLeft();\n  const ptr = xmlObj.readBytes(numBytesLeft);\n  if (xmlflag & constants.TNS_XML_TYPE_STRING) {\n    colValue = ptr.toString();\n  } else if (xmlflag & constants.TNS_XML_TYPE_LOB) {\n    const lobImpl = new ThinLobImpl();\n    const locator = Buffer.from(ptr);\n    lobImpl.init(conn, locator, types.DB_TYPE_CLOB, 0, 0);\n    colValue = lobImpl;\n  } else {\n    // We only support String and Clob type.\n    errors.throwErr(errors.ERR_UNEXPECTED_XML_TYPE, xmlflag);\n  }\n  return colValue;\n}\nmodule.exports = {\n  ThinDbObjectImpl,\n  readXML\n};","map":{"version":3,"names":["Buffer","require","constants","errors","types","DbObjectImpl","GrowableBuffer","ThinLobImpl","DbObjectPickleBuffer","_readBytesWithLength","numBytes","TNS_LONG_LENGTH_INDICATOR","readUInt32BE","readBytes","getIsAtomicNull","value","readUInt8","TNS_OBJ_ATOMIC_NULL","TNS_NULL_LENGTH_INDICATOR","pos","readHeader","obj","imageFlags","imageVersion","readLength","TNS_OBJ_NO_PREFIX_SEG","prefixSegLength","skipBytes","shortLength","writeHeader","writeUInt8","writeUInt32BE","_objType","isCollection","writeLength","length","TNS_OBJ_MAX_SHORT_LENGTH","_writeRawBytesAndLength","writeBytes","ThinDbObjectImpl","constructor","objType","packedData","prototype","unpackedAttrs","Map","unpackedAssocArray","unpackedAssocKeys","undefined","prefix","from","TNS_OBJ_NON_NULL_OID","TNS_OBJ_HAS_EXTENT_OID","toid","concat","oid","TNS_EXTENT_OID","flags","TNS_OBJ_TOP_LEVEL","TNS_OBJ_IS_VERSION_81","TNS_OBJ_IMAGE_VERSION","TNS_OBJ_IS_COLLECTION","collectionType","TNS_OBJ_PLSQL_INDEX_TABLE","unpackedArray","_ensureAssocKeys","keys","sort","_ensureUnpacked","_unpackData","_getPackedData","buf","_packData","size","subarray","collectionFlags","index","writeInt32BE","_packValue","elementType","elementTypeClass","get","attr","attributes","type","typeClass","name","DB_TYPE_CHAR","DB_TYPE_VARCHAR","writeBytesWithLength","DB_TYPE_NCHAR","DB_TYPE_NVARCHAR","swap16","DB_TYPE_NUMBER","writeOracleNumber","toString","DB_TYPE_BINARY_INTEGER","DB_TYPE_BOOLEAN","DB_TYPE_RAW","DB_TYPE_BINARY_DOUBLE","writeBinaryDouble","DB_TYPE_BINARY_FLOAT","writeBinaryFloat","DB_TYPE_DATE","DB_TYPE_TIMESTAMP","DB_TYPE_TIMESTAMP_LTZ","DB_TYPE_TIMESTAMP_TZ","writeOracleDate","DB_TYPE_OBJECT","throwErr","ERR_NOT_IMPLEMENTED","_unpackDataFromBuf","assocIndex","numElements","i","_unpackValue","set","push","isNull","readOracleNumber","parseFloat","readBinaryInteger","readStr","CSFRM_IMPLICIT","CSFRM_NCHAR","readBytesWithLength","readBinaryDouble","readBinaryFloat","readOracleDate","readBool","append","maxNumElements","ERR_INVALID_COLL_INDEX_SET","newIndex","keyIndex","deleteElement","TNS_OBJ_VARRAY","ERR_DELETE_ELEMENTS_OF_VARRAY","splice","_unpackedAssocKeys","delete","getAttrValue","getElement","ERR_INVALID_COLL_INDEX_GET","getFirstIndex","getKeys","Array","getLastIndex","getNextIndex","key","getPrevIndex","reverse","getValues","result","hasElement","has","setAttrValue","setElement","maxIndex","Math","max","trim","numToTrim","slice","readXML","conn","colValue","xmlObj","tempobj","xmlflag","TNS_XML_TYPE_FLAG_SKIP_NEXT_4","numBytesLeft","ptr","TNS_XML_TYPE_STRING","TNS_XML_TYPE_LOB","lobImpl","locator","init","DB_TYPE_CLOB","ERR_UNEXPECTED_XML_TYPE","module","exports"],"sources":["C:/Users/user1/Desktop/finalproject_penpick/node_modules/oracledb/lib/thin/dbObject.js"],"sourcesContent":["// Copyright (c) 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst { Buffer } = require('buffer');\nconst constants = require('./protocol/constants.js');\nconst errors = require('../errors.js');\nconst types = require('../types.js');\nconst DbObjectImpl = require('../impl/dbObject.js');\nconst { GrowableBuffer } = require('./protocol/buffer.js');\nconst ThinLobImpl = require('./lob.js');\n\nclass DbObjectPickleBuffer extends GrowableBuffer {\n\n  //---------------------------------------------------------------------------\n  // _readBytesWithLength()\n  //\n  // Helper function that processes the number of bytes (if needed) and then\n  // acquires the specified number of bytes from the buffer.\n  //---------------------------------------------------------------------------\n  _readBytesWithLength(numBytes) {\n    if (numBytes === constants.TNS_LONG_LENGTH_INDICATOR) {\n      numBytes = this.readUInt32BE();\n    }\n    return this.readBytes(numBytes);\n  }\n\n  //---------------------------------------------------------------------------\n  // getIsAtomicNull()\n  //\n  // Reads the next byte and checks to see if the value is atomically null. If\n  // not, the byte is returned to the buffer for further processing.\n  //---------------------------------------------------------------------------\n  getIsAtomicNull() {\n    const value = this.readUInt8();\n    if (value === constants.TNS_OBJ_ATOMIC_NULL ||\n        value === constants.TNS_NULL_LENGTH_INDICATOR) {\n      return true;\n    }\n    this.pos -= 1;\n    return false;\n  }\n\n  //---------------------------------------------------------------------------\n  // readHeader()\n  //\n  // Reads the header of the pickled data.\n  //---------------------------------------------------------------------------\n  readHeader(obj) {\n    obj.imageFlags = this.readUInt8();\n    obj.imageVersion = this.readUInt8();\n    this.readLength();\n    if ((obj.imageFlags & constants.TNS_OBJ_NO_PREFIX_SEG) === 0) {\n      const prefixSegLength = this.readLength();\n      this.skipBytes(prefixSegLength);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // readLength()\n  //\n  // Read the length from the buffer. This will be a single byte, unless the\n  // value meets or exeeds TNS_LONG_LENGTH_INDICATOR. In that case, the value\n  // is stored as a 4-byte integer.\n  //---------------------------------------------------------------------------\n  readLength() {\n    const shortLength = this.readUInt8();\n    if (shortLength !== constants.TNS_LONG_LENGTH_INDICATOR) {\n      return shortLength;\n    }\n    return this.readUInt32BE();\n  }\n\n  //---------------------------------------------------------------------------\n  // writeHeader()\n  //\n  // Writes the header of the pickled data. Since the size is unknown at this\n  // point, zero is written initially and the actual size is written later.\n  //---------------------------------------------------------------------------\n  writeHeader(obj) {\n    this.writeUInt8(obj.imageFlags);\n    this.writeUInt8(obj.imageVersion);\n    this.writeUInt8(constants.TNS_LONG_LENGTH_INDICATOR);\n    this.writeUInt32BE(0);\n    if (obj._objType.isCollection) {\n      this.writeUInt8(1);               // length of prefix segment\n      this.writeUInt8(1);               // prefix segment contents\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // writeLength()\n  //\n  // Writes the length to the buffer.\n  //---------------------------------------------------------------------------\n  writeLength(length) {\n    if (length <= constants.TNS_OBJ_MAX_SHORT_LENGTH) {\n      this.writeUInt8(length);\n    } else {\n      this.writeUInt8(constants.TNS_LONG_LENGTH_INDICATOR);\n      this.writeUInt32BE(length);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _writeRawBytesAndLength()\n  //\n  // Writes the length in the format required before\n  // writing the bytes.\n  //---------------------------------------------------------------------------\n  _writeRawBytesAndLength(value, numBytes) {\n    this.writeLength(numBytes);\n    this.writeBytes(value);\n  }\n}\n\nclass ThinDbObjectImpl extends DbObjectImpl {\n\n  constructor(objType, packedData) {\n    if (typeof objType === 'function') {\n      objType = objType.prototype._objType;\n    }\n    super(objType);\n    this.packedData = packedData;\n    this.unpackedAttrs = new Map();\n    if (packedData) {\n      this.unpackedAssocArray = new Map();\n      this.unpackedAssocKeys = undefined;\n    } else if (objType) {\n      const prefix = Buffer.from([0, 0x22, constants.TNS_OBJ_NON_NULL_OID,\n        constants.TNS_OBJ_HAS_EXTENT_OID]);\n      this.toid = Buffer.concat([prefix, objType.oid, constants.TNS_EXTENT_OID]);\n      this.flags = constants.TNS_OBJ_TOP_LEVEL;\n      this.imageFlags = constants.TNS_OBJ_IS_VERSION_81;\n      this.imageVersion = constants.TNS_OBJ_IMAGE_VERSION;\n      if (objType.isCollection) {\n        this.imageFlags |= constants.TNS_OBJ_IS_COLLECTION;\n        if (objType.collectionType === constants.TNS_OBJ_PLSQL_INDEX_TABLE) {\n          this.unpackedAssocArray = new Map();\n        } else {\n          this.unpackedArray = [];\n        }\n      } else {\n        this.imageFlags |= constants.TNS_OBJ_NO_PREFIX_SEG;\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _ensureAssocKeys()\n  //\n  // Ensure that the keys for the associative array have been calculated.\n  // PL/SQL associative arrays keep their keys in sorted order so this must be\n  // calculated when indices are required.\n  //---------------------------------------------------------------------------\n  _ensureAssocKeys() {\n    if (!this.unpackedAssocKeys) {\n      this.unpackedAssocKeys = [...this.unpackedAssocArray.keys()].sort();\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _ensureUnpacked()\n  //\n  // Ensure that the data has been unpacked.\n  //---------------------------------------------------------------------------\n  _ensureUnpacked() {\n    if (this.packedData) {\n      this._unpackData();\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _getPackedData()\n  //\n  // Returns the packed data for the object. This will either be the value\n  // retrieved from the database or generated packed data (for new objects and\n  // those that have had their data unpacked already).\n  //---------------------------------------------------------------------------\n  _getPackedData() {\n    if (this.packedData)\n      return this.packedData;\n    const buf = new DbObjectPickleBuffer();\n    buf.writeHeader(this);\n    this._packData(buf);\n    const size = buf.pos;\n    buf.pos = 3;\n    buf.writeUInt32BE(size);\n    return buf.buf.subarray(0, size);\n  }\n\n  //---------------------------------------------------------------------------\n  // _packData()\n  //\n  // Packs the data from the object into the buffer.\n  //---------------------------------------------------------------------------\n  _packData(buf) {\n    const objType = this._objType;\n    if (objType.isCollection) {\n      buf.writeUInt8(objType.collectionFlags);\n      if (objType.collectionType === constants.TNS_OBJ_PLSQL_INDEX_TABLE) {\n        this._ensureAssocKeys();\n        buf.writeLength(this.unpackedAssocKeys.length);\n        for (const index of this.unpackedAssocKeys) {\n          buf.writeInt32BE(index);\n          this._packValue(buf, objType.elementType, objType.elementTypeClass,\n            this.unpackedAssocArray.get(index));\n        }\n      } else {\n        buf.writeLength(this.unpackedArray.length);\n        for (const value of this.unpackedArray) {\n          this._packValue(buf, objType.elementType, objType.elementTypeClass,\n            value);\n        }\n      }\n    } else {\n      for (const attr of objType.attributes) {\n        this._packValue(buf, attr.type, attr.typeClass,\n          this.unpackedAttrs.get(attr.name));\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _packValue()\n  //\n  // Packs a value into the buffer. At this point it is assumed that the value\n  // matches the correct type.\n  //---------------------------------------------------------------------------\n  _packValue(buf, type, typeClass, value) {\n    if (value === null || value === undefined) {\n      if (typeClass && !typeClass.prototype.isCollection) {\n        buf.writeUInt8(constants.TNS_OBJ_ATOMIC_NULL);\n      } else {\n        buf.writeUInt8(constants.TNS_NULL_LENGTH_INDICATOR);\n      }\n    } else {\n      switch (type) {\n        case types.DB_TYPE_CHAR:\n        case types.DB_TYPE_VARCHAR:\n          buf.writeBytesWithLength(Buffer.from(value));\n          break;\n        case types.DB_TYPE_NCHAR:\n        case types.DB_TYPE_NVARCHAR:\n          buf.writeBytesWithLength(Buffer.from(value, 'utf16le').swap16());\n          break;\n        case types.DB_TYPE_NUMBER:\n          buf.writeOracleNumber(value.toString());\n          break;\n        case types.DB_TYPE_BINARY_INTEGER:\n        case types.DB_TYPE_BOOLEAN:\n          buf.writeUInt8(4);\n          buf.writeUInt32BE(value);\n          break;\n        case types.DB_TYPE_RAW:\n          buf.writeBytesWithLength(value);\n          break;\n        case types.DB_TYPE_BINARY_DOUBLE:\n          buf.writeBinaryDouble(value);\n          break;\n        case types.DB_TYPE_BINARY_FLOAT:\n          buf.writeBinaryFloat(value);\n          break;\n        case types.DB_TYPE_DATE:\n        case types.DB_TYPE_TIMESTAMP:\n        case types.DB_TYPE_TIMESTAMP_LTZ:\n        case types.DB_TYPE_TIMESTAMP_TZ:\n          buf.writeOracleDate(value, type);\n          break;\n        case types.DB_TYPE_OBJECT:\n          if (this._objType.isCollection || value._objType.isCollection) {\n            buf.writeBytesWithLength(value._getPackedData());\n          } else {\n            value._packData(buf);\n          }\n          break;\n        default:\n          errors.throwErr(errors.ERR_NOT_IMPLEMENTED, type);\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _unpackData()\n  //\n  // Unpacks the packed data into a map of JavaScript values.\n  //---------------------------------------------------------------------------\n  _unpackData() {\n    const buf = new DbObjectPickleBuffer(this.packedData);\n    buf.readHeader(this);\n    this._unpackDataFromBuf(buf);\n    this.packedData = undefined;\n  }\n\n  //---------------------------------------------------------------------------\n  // _unpackDataFromBuf()\n  //\n  // Unpacks the data in the buffer into a map of JavaScript values.\n  //---------------------------------------------------------------------------\n  _unpackDataFromBuf(buf) {\n    let unpackedArray, unpackedAssocArray, assocIndex, unpackedAttrs;\n    const objType = this._objType;\n    if (objType.isCollection) {\n      if (objType.collectionType === constants.TNS_OBJ_PLSQL_INDEX_TABLE) {\n        unpackedAssocArray = new Map();\n      } else {\n        unpackedArray = [];\n      }\n      this.collectionFlags = buf.readUInt8();\n      const numElements = buf.readLength();\n      for (let i = 0; i < numElements; i++) {\n        if (objType.collectionType === constants.TNS_OBJ_PLSQL_INDEX_TABLE) {\n          assocIndex = buf.readUInt32BE();\n        }\n        const value = this._unpackValue(buf, objType.elementType,\n          objType.elementTypeClass);\n        if (objType.collectionType === constants.TNS_OBJ_PLSQL_INDEX_TABLE) {\n          unpackedAssocArray.set(assocIndex, value);\n        } else {\n          unpackedArray.push(value);\n        }\n      }\n    } else {\n      unpackedAttrs = new Map();\n      for (const attr of objType.attributes) {\n        const value = this._unpackValue(buf, attr.type, attr.typeClass);\n        unpackedAttrs.set(attr.name, value);\n      }\n    }\n    this.unpackedAttrs = unpackedAttrs;\n    this.unpackedArray = unpackedArray;\n    this.unpackedAssocArray = unpackedAssocArray;\n  }\n\n  //---------------------------------------------------------------------------\n  // _unpackValue()\n  //\n  // Unpacks a single value and returns it.\n  //---------------------------------------------------------------------------\n  _unpackValue(buf, type, typeClass) {\n    let isNull, obj, value;\n    switch (type) {\n      case types.DB_TYPE_NUMBER:\n        value = buf.readOracleNumber();\n        if (value !== null)\n          value = parseFloat(value);\n        return value;\n      case types.DB_TYPE_BINARY_INTEGER:\n        return buf.readBinaryInteger();\n      case types.DB_TYPE_VARCHAR:\n      case types.DB_TYPE_CHAR:\n        return buf.readStr(constants.CSFRM_IMPLICIT);\n      case types.DB_TYPE_NVARCHAR:\n      case types.DB_TYPE_NCHAR:\n        return buf.readStr(constants.CSFRM_NCHAR);\n      case types.DB_TYPE_RAW:\n        value = buf.readBytesWithLength();\n        if (value !== null)\n          value = Buffer.from(value);\n        return value;\n      case types.DB_TYPE_BINARY_DOUBLE:\n        return buf.readBinaryDouble();\n      case types.DB_TYPE_BINARY_FLOAT:\n        return buf.readBinaryFloat();\n      case types.DB_TYPE_DATE:\n      case types.DB_TYPE_TIMESTAMP:\n        return buf.readOracleDate(true);\n      case types.DB_TYPE_TIMESTAMP_LTZ:\n      case types.DB_TYPE_TIMESTAMP_TZ:\n        return buf.readOracleDate(false);\n      case types.DB_TYPE_BOOLEAN:\n        return buf.readBool();\n      case types.DB_TYPE_OBJECT:\n        isNull = buf.getIsAtomicNull();\n        if (isNull)\n          return null;\n        obj = new ThinDbObjectImpl(typeClass);\n        if (obj._objType.isCollection || this._objType.isCollection) {\n          obj.packedData = Buffer.from(buf.readBytesWithLength());\n        } else {\n          obj._unpackDataFromBuf(buf);\n        }\n        return obj;\n      default:\n        errors.throwErr(errors.ERR_NOT_IMPLEMENTED, type);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // append()\n  //\n  // Appends an element to the collection.\n  //---------------------------------------------------------------------------\n  append(value) {\n    this._ensureUnpacked();\n    if (this.unpackedArray) {\n      const objType = this._objType;\n      if (objType.maxNumElements > 0 &&\n          this.unpackedArray.length >= objType.maxNumElements) {\n        errors.throwErr(errors.ERR_INVALID_COLL_INDEX_SET,\n          this.unpackedArray.length, 0, objType.maxNumElements);\n      }\n      this.unpackedArray.push(value);\n    } else {\n      this._ensureAssocKeys();\n      let newIndex;\n      if (this.unpackedAssocKeys.length === 0) {\n        newIndex = 0;\n      } else {\n        const keyIndex = this.unpackedAssocKeys.length - 1;\n        newIndex = this.unpackedAssocKeys[keyIndex] + 1;\n      }\n      this.unpackedAssocArray.set(newIndex, value);\n      this.unpackedAssocKeys.push(newIndex);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // deleteElement()\n  //\n  // Deletes an element from a collection.\n  //---------------------------------------------------------------------------\n  deleteElement(index) {\n    this._ensureUnpacked();\n    if (this.unpackedArray) {\n      if (this._objType.collectionType == constants.TNS_OBJ_VARRAY) {\n        errors.throwErr(errors.ERR_DELETE_ELEMENTS_OF_VARRAY);\n      }\n      this.unpackedArray.splice(index, 1);\n    } else {\n      this._unpackedAssocKeys = undefined;\n      this.unpackedAssocArray.delete(index);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // getAttrValue()\n  //\n  // Returns the value of the given attribute on the object.\n  //---------------------------------------------------------------------------\n  getAttrValue(attr) {\n    this._ensureUnpacked();\n    const value = this.unpackedAttrs.get(attr.name);\n    if (value === undefined)\n      return null;\n    return value;\n  }\n\n  //---------------------------------------------------------------------------\n  // getElement()\n  //\n  // Returns an element from the collection.\n  //---------------------------------------------------------------------------\n  getElement(index) {\n    let value;\n    this._ensureUnpacked();\n    if (this.unpackedArray) {\n      value = this.unpackedArray[index];\n    } else {\n      value = this.unpackedAssocArray.get(index);\n    }\n    if (value === undefined) {\n      errors.throwErr(errors.ERR_INVALID_COLL_INDEX_GET, index);\n    }\n    return value;\n  }\n\n  //---------------------------------------------------------------------------\n  // getFirstIndex()\n  //\n  // Returns the first index in a collection.\n  //---------------------------------------------------------------------------\n  getFirstIndex() {\n    this._ensureUnpacked();\n    if (this.unpackedArray) {\n      return 0;\n    } else if (this.unpackedAssocArray) {\n      this._ensureAssocKeys();\n      return this.unpackedAssocKeys[0];\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // getKeys()\n  //\n  // Returns the keys of the collection in a JavaScript array.\n  //---------------------------------------------------------------------------\n  getKeys() {\n    this._ensureUnpacked();\n    if (this.unpackedArray) {\n      return Array.from(this.unpackedArray.keys());\n    } else if (this.unpackedAssocArray) {\n      this._ensureAssocKeys();\n      return Array.from(this.unpackedAssocKeys);\n    }\n    return [];\n  }\n\n  //---------------------------------------------------------------------------\n  // getLastIndex()\n  //\n  // Returns the last index in a collection.\n  //---------------------------------------------------------------------------\n  getLastIndex() {\n    this._ensureUnpacked();\n    if (this.unpackedArray) {\n      if (this.unpackedArray.length > 0)\n        return this.unpackedArray.length - 1;\n    } else if (this.unpackedAssocArray) {\n      this._ensureAssocKeys();\n      return this.unpackedAssocKeys[this.unpackedAssocKeys.length - 1];\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // getNextIndex()\n  //\n  // Returns the next index in a collection.\n  //---------------------------------------------------------------------------\n  getNextIndex(index) {\n    this._ensureUnpacked();\n    if (this.unpackedArray) {\n      if (index + 1 < this.unpackedArray.length) {\n        return index + 1;\n      }\n    } else if (this.unpackedAssocArray) {\n      this._ensureAssocKeys();\n      for (const key of this.unpackedAssocKeys) {\n        if (key > index)\n          return key;\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // getPrevIndex()\n  //\n  // Returns the previous index in a collection.\n  //---------------------------------------------------------------------------\n  getPrevIndex(index) {\n    this._ensureUnpacked();\n    if (this.unpackedArray) {\n      if (index > 0) {\n        return index - 1;\n      }\n    } else if (this.unpackedAssocArray) {\n      this._ensureAssocKeys();\n      for (const key of this.unpackedAssocKeys.reverse()) {\n        if (key < index)\n          return key;\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // getValues()\n  //\n  // Returns the values of the collection in a JavaScript array.\n  //---------------------------------------------------------------------------\n  getValues() {\n    const result = [];\n    this._ensureUnpacked();\n    if (this.unpackedArray) {\n      return Array.from(this.unpackedArray);\n    } else if (this.unpackedAssocArray) {\n      this._ensureAssocKeys();\n      for (const key of this.unpackedAssocKeys) {\n        result.push(this.unpackedAssocArray.get(key));\n      }\n    }\n    return result;\n  }\n\n  //---------------------------------------------------------------------------\n  // hasElement()\n  //\n  // Returns whether an element exists at the given index.\n  //---------------------------------------------------------------------------\n  hasElement(index) {\n    this._ensureUnpacked();\n    if (this.unpackedArray) {\n      return (index >= 0 && index < this.unpackedArray.length);\n    }\n    return this.unpackedAssocArray.has(index);\n  }\n\n  //---------------------------------------------------------------------------\n  // setAttrValue()\n  //\n  // Sets the value of the attribute on the object to the given value.\n  //---------------------------------------------------------------------------\n  setAttrValue(attr, value) {\n    this._ensureUnpacked();\n    this.unpackedAttrs.set(attr.name, value);\n  }\n\n  //---------------------------------------------------------------------------\n  // setElement()\n  //\n  // Sets an entry in a collection that is indexed by integers.\n  //---------------------------------------------------------------------------\n  setElement(index, value) {\n    this._ensureUnpacked();\n    if (this.unpackedArray) {\n      const maxIndex = Math.max(this.unpackedArray.length - 1, 0);\n      if (index > maxIndex) {\n        errors.throwErr(errors.ERR_INVALID_COLL_INDEX_SET, index, 0, maxIndex);\n      }\n      this.unpackedArray[index] = value;\n    } else {\n      if (!this.unpackedAssocArray.has(index))\n        this.unpackedAssocKeys = undefined;\n      this.unpackedAssocArray.set(index, value);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // trim()\n  //\n  // Trim the specified number of elements from the end of the collection.\n  //---------------------------------------------------------------------------\n  trim(numToTrim) {\n    this._ensureUnpacked();\n    if (numToTrim > 0) {\n      this.unpackedArray = this.unpackedArray.slice(0,\n        this.unpackedArray.length - numToTrim);\n    }\n  }\n\n}\n\n//---------------------------------------------------------------------------\n// readXML()\n//\n// Decodes the raw Bytes to XML string or LOB object.\n//\n//---------------------------------------------------------------------------\nfunction readXML(conn, buf) {\n  let colValue;\n\n  const xmlObj = new DbObjectPickleBuffer(buf);\n  const tempobj = {};\n  xmlObj.readHeader(tempobj);\n  xmlObj.skipBytes(1);\n  const xmlflag = xmlObj.readUInt32BE();\n  if (xmlflag & constants.TNS_XML_TYPE_FLAG_SKIP_NEXT_4) {\n    xmlObj.skipBytes(4);\n  }\n  const numBytesLeft = xmlObj.numBytesLeft();\n  const ptr = xmlObj.readBytes(numBytesLeft);\n  if (xmlflag & constants.TNS_XML_TYPE_STRING) {\n    colValue = ptr.toString();\n  } else if (xmlflag & constants.TNS_XML_TYPE_LOB) {\n    const lobImpl = new ThinLobImpl();\n    const locator = Buffer.from(ptr);\n    lobImpl.init(conn, locator, types.DB_TYPE_CLOB, 0, 0);\n    colValue = lobImpl;\n  } else {\n    // We only support String and Clob type.\n    errors.throwErr(errors.ERR_UNEXPECTED_XML_TYPE, xmlflag);\n  }\n  return colValue;\n}\n\nmodule.exports = { ThinDbObjectImpl, readXML };\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}