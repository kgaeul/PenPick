{"ast":null,"code":"// Copyright (c) 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst {\n  BaseBuffer,\n  GrowableBuffer\n} = require('./buffer.js');\nconst {\n  Buffer\n} = require('buffer');\nconst constants = require(\"./constants.js\");\nconst errors = require(\"../../errors.js\");\nconst types = require(\"../../types.js\");\nconst util = require(\"util\");\n\n/**\n * Class used for decodeing\n */\nclass OsonDecoder extends BaseBuffer {\n  //---------------------------------------------------------------------------\n  // _decodeContainerNode()\n  //\n  // Decodes a container node (object or array) from the tree segment and\n  // returns the JavaScript equivalent.\n  //---------------------------------------------------------------------------\n  _decodeContainerNode(nodeType) {\n    // determine the number of children by examining the 4th and 5th most\n    // significant bits of the node type; determine the offsets in the tree\n    // segment to the field ids array and the value offsets array\n    let container, offsetsPos, fieldIdsPos;\n    let numChildren = this._getNumChildren(nodeType);\n    const isObject = (nodeType & 0x40) === 0;\n    if (numChildren === undefined) {\n      const offset = this._getOffset(nodeType);\n      offsetsPos = this.pos;\n      this.pos = this.treeSegPos + offset;\n      const sharedNodeType = this.readUInt8();\n      numChildren = this._getNumChildren(sharedNodeType);\n      container = isObject ? {} : new Array(numChildren);\n      fieldIdsPos = this.pos;\n    } else if (isObject) {\n      container = {};\n      fieldIdsPos = this.pos;\n      offsetsPos = this.pos + this.fieldIdLength * numChildren;\n    } else {\n      container = new Array(numChildren);\n      offsetsPos = this.pos;\n    }\n    for (let i = 0; i < numChildren; i++) {\n      let name;\n      if (isObject) {\n        let fieldId;\n        if (this.fieldIdLength === 1) {\n          fieldId = this.buf[fieldIdsPos];\n        } else if (this.fieldIdLength == 2) {\n          fieldId = this.buf.readUInt16BE(fieldIdsPos);\n        } else {\n          fieldId = this.buf.readUInt32BE(fieldIdsPos);\n        }\n        name = this.fieldNames[fieldId - 1];\n        fieldIdsPos += this.fieldIdLength;\n      }\n      this.pos = offsetsPos;\n      const offset = this._getOffset(nodeType);\n      offsetsPos = this.pos;\n      this.pos = this.treeSegPos + offset;\n      if (isObject) {\n        container[name] = this._decodeNode();\n      } else {\n        container[i] = this._decodeNode();\n      }\n    }\n    return container;\n  }\n\n  //---------------------------------------------------------------------------\n  // _decodeNode()\n  //\n  // Decodes a node from the tree segment and returns the JavaScript\n  // equivalent.\n  //---------------------------------------------------------------------------\n  _decodeNode() {\n    // if the most significant bit is set the node refers to a container\n    const nodeType = this.readUInt8();\n    if (nodeType & 0x80) {\n      return this._decodeContainerNode(nodeType);\n    }\n\n    // handle simple scalars\n    if (nodeType === constants.TNS_JSON_TYPE_NULL) {\n      return null;\n    } else if (nodeType === constants.TNS_JSON_TYPE_TRUE) {\n      return true;\n    } else if (nodeType === constants.TNS_JSON_TYPE_FALSE) {\n      return false;\n\n      // handle fixed length scalars\n    } else if (nodeType === constants.TNS_JSON_TYPE_DATE || nodeType === constants.TNS_JSON_TYPE_TIMESTAMP7) {\n      return this.parseOracleDate(this.readBytes(7));\n    } else if (nodeType === constants.TNS_JSON_TYPE_TIMESTAMP) {\n      return this.parseOracleDate(this.readBytes(11));\n    } else if (nodeType === constants.TNS_JSON_TYPE_TIMESTAMP_TZ) {\n      return this.parseOracleDate(this.readBytes(13));\n    } else if (nodeType === constants.TNS_JSON_TYPE_BINARY_FLOAT) {\n      return this.parseBinaryFloat(this.readBytes(4));\n    } else if (nodeType === constants.TNS_JSON_TYPE_BINARY_DOUBLE) {\n      return this.parseBinaryDouble(this.readBytes(8));\n\n      // handle scalars with lengths stored outside the node itself\n    } else if (nodeType === constants.TNS_JSON_TYPE_STRING_LENGTH_UINT8) {\n      return this.readBytes(this.readUInt8()).toString();\n    } else if (nodeType === constants.TNS_JSON_TYPE_STRING_LENGTH_UINT16) {\n      return this.readBytes(this.readUInt16BE()).toString();\n    } else if (nodeType === constants.TNS_JSON_TYPE_STRING_LENGTH_UINT32) {\n      return this.readBytes(this.readUInt32BE()).toString();\n    } else if (nodeType === constants.TNS_JSON_TYPE_NUMBER_LENGTH_UINT8) {\n      return parseFloat(this.readOracleNumber());\n    } else if (nodeType === constants.TNS_JSON_TYPE_BINARY_LENGTH_UINT16) {\n      return Buffer.from(this.readBytes(this.readUInt16BE()));\n    } else if (nodeType === constants.TNS_JSON_TYPE_BINARY_LENGTH_UINT32) {\n      return Buffer.from(this.readBytes(this.readUInt32BE()));\n    }\n\n    // handle number/decimal with length stored inside the node itself\n    const typeBits = nodeType & 0xf0;\n    if (typeBits === 0x20 || typeBits === 0x60) {\n      const len = nodeType & 0x0f;\n      return parseFloat(this.parseOracleNumber(this.readBytes(len + 1)));\n\n      // handle integer with length stored inside the node itself\n    } else if (typeBits === 0x40 || typeBits === 0x50) {\n      const len = nodeType & 0x0f;\n      return parseFloat(this.parseOracleNumber(this.readBytes(len)));\n\n      // handle string with length stored inside the node itself\n    } else if ((nodeType & 0xe0) == 0) {\n      if (nodeType === 0) return '';\n      return this.readBytes(nodeType).toString();\n    }\n    errors.throwErr(errors.ERR_UNSUPPORTED_DATA_TYPE_IN_JSON, nodeType);\n  }\n\n  //---------------------------------------------------------------------------\n  // _getNumChildren()\n  //\n  // Returns the number of children a container has. This is determined by\n  // looking at the 4th and 5th most significant bits of the node type.\n  //\n  //   00 - number of children is uint8_t\n  //   01 - number of children is uint16_t\n  //   10 - number of children is uint32_t\n  //   11 - field ids are shared with another object whose offset follows\n  //\n  // In the latter case the value undefined is returned and the number of\n  // children must be read from the shared object at the specified offset.\n  //---------------------------------------------------------------------------\n  _getNumChildren(nodeType) {\n    const childrenBits = nodeType & 0x18;\n    if (childrenBits === 0) {\n      return this.readUInt8();\n    } else if (childrenBits === 0x08) {\n      return this.readUInt16BE();\n    } else if (childrenBits === 0x10) {\n      return this.readUInt32BE();\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _getOffset()\n  //\n  // Returns an offset. The offset will be either a 16-bit or 32-bit value\n  // depending on the value of the 3rd significant bit of the node type.\n  //---------------------------------------------------------------------------\n  _getOffset(nodeType) {\n    if (nodeType & 0x20) {\n      return this.readUInt32BE();\n    } else {\n      return this.readUInt16BE();\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // decode()\n  //\n  // Decodes the OSON and returns a JavaScript object corresponding to its\n  // contents.\n  //---------------------------------------------------------------------------\n  decode() {\n    // parse root header\n    const magic = this.readBytes(3);\n    if (magic[0] !== constants.TNS_JSON_MAGIC_BYTE_1 || magic[1] !== constants.TNS_JSON_MAGIC_BYTE_2 || magic[2] !== constants.TNS_JSON_MAGIC_BYTE_3) {\n      errors.throwErr(errors.ERR_UNEXPECTED_DATA, magic.toString('hex'));\n    }\n    const version = this.readUInt8();\n    if (version !== constants.TNS_JSON_VERSION) {\n      errors.throwErr(errors.ERR_OSON_VERSION_NOT_SUPPORTED, version);\n    }\n    const flags = this.readUInt16BE();\n\n    // scalar values are much simpler\n    if (flags & constants.TNS_JSON_FLAG_IS_SCALAR) {\n      if (flags & constants.TNS_JSON_FLAG_TREE_SEG_UINT32) {\n        this.skipBytes(4);\n      } else {\n        this.skipBytes(2);\n      }\n      return this._decodeNode();\n    }\n\n    // determine the number of field names\n    let numFieldNames;\n    if (flags & constants.TNS_JSON_FLAG_NUM_FNAMES_UINT32) {\n      numFieldNames = this.readUInt32BE();\n      this.fieldIdLength = 4;\n    } else if (flags & constants.TNS_JSON_FLAG_NUM_FNAMES_UINT16) {\n      numFieldNames = this.readUInt16BE();\n      this.fieldIdLength = 2;\n    } else {\n      numFieldNames = this.readUInt8();\n      this.fieldIdLength = 1;\n    }\n\n    // determine the size of the field names segment\n    let fieldNameOffsetsSize, fieldNamesSegSize;\n    if (flags & constants.TNS_JSON_FLAG_FNAMES_SEG_UINT32) {\n      fieldNameOffsetsSize = 4;\n      fieldNamesSegSize = this.readUInt32BE();\n    } else {\n      fieldNameOffsetsSize = 2;\n      fieldNamesSegSize = this.readUInt16BE();\n    }\n\n    // skip the size of the tree segment\n    if (flags & constants.TNS_JSON_FLAG_TREE_SEG_UINT32) {\n      this.skipBytes(4);\n    } else {\n      this.skipBytes(2);\n    }\n\n    // skip the number of \"tiny\" nodes\n    this.skipBytes(2);\n\n    // skip the hash id array\n    let hashIdSize;\n    if (flags & constants.TNS_JSON_FLAG_HASH_ID_UINT8) {\n      hashIdSize = 1;\n    } else if (flags & constants.TNS_JSON_FLAG_HASH_ID_UINT16) {\n      hashIdSize = 2;\n    } else {\n      hashIdSize = 4;\n    }\n    this.skipBytes(numFieldNames * hashIdSize);\n\n    // skip over the field name offsets and field names\n    let fieldNameOffsetsPos = this.pos;\n    this.skipBytes(numFieldNames * fieldNameOffsetsSize);\n    const fieldNamesPos = this.pos;\n    this.skipBytes(fieldNamesSegSize);\n\n    // determine the names of the fields\n    this.fieldNames = new Array(numFieldNames);\n    for (let i = 0; i < numFieldNames; i++) {\n      let offset = fieldNamesPos;\n      if (flags & constants.TNS_JSON_FLAG_FNAMES_SEG_UINT32) {\n        offset += this.buf.readUInt32BE(fieldNameOffsetsPos);\n        fieldNameOffsetsPos += 4;\n      } else {\n        offset += this.buf.readUInt16BE(fieldNameOffsetsPos);\n        fieldNameOffsetsPos += 2;\n      }\n      const len = this.buf[offset];\n      const name = this.buf.subarray(offset + 1, offset + len + 1).toString();\n      this.fieldNames[i] = name;\n    }\n\n    // determine tree segment position in the buffer\n    this.treeSegPos = this.pos;\n\n    // decode the root node\n    return this._decodeNode();\n  }\n}\nclass OsonFieldName {\n  constructor(name) {\n    this.name = name;\n    this.nameBytes = Buffer.from(name);\n    if (this.nameBytes.length > 255) {\n      errors.throwErr(errors.ERR_OSON_FIELD_NAME_LIMITATION);\n    }\n    this.hashId = BigInt(0x811C9DC5);\n    const multiplier = BigInt(16777619);\n    const mask = BigInt(0xffffffff);\n    for (let i = 0; i < this.nameBytes.length; i++) {\n      const c = BigInt(this.nameBytes[i]);\n      this.hashId = (this.hashId ^ c) * multiplier & mask;\n    }\n    this.hashId = Number(this.hashId) & 0xff;\n  }\n}\nclass OsonFieldNamesSegment extends GrowableBuffer {\n  constructor(value) {\n    super();\n    this.fieldNamesMap = new Map();\n    this.fieldNames = [];\n    this._examineNode(value);\n    this._processFieldNames();\n  }\n\n  //---------------------------------------------------------------------------\n  // _exmaineNode()\n  //\n  // Examines the value. If it contains fields, unique names are retained. The\n  // values are then examined to see if they also contain fields. Arrays are\n  // examined to determine they contain elements that contain fields.\n  //---------------------------------------------------------------------------\n  _examineNode(value) {\n    if (Array.isArray(value)) {\n      for (const element of value) {\n        this._examineNode(element);\n      }\n    } else if (value && Array.isArray(value.fields)) {\n      for (let i = 0; i < value.fields.length; i++) {\n        const name = value.fields[i];\n        const element = value.values[i];\n        if (!this.fieldNamesMap.has(name)) {\n          const fieldName = new OsonFieldName(name);\n          this.fieldNamesMap.set(name, fieldName);\n          this.fieldNames.push(fieldName);\n          fieldName.offset = this.pos;\n          this.writeUInt8(fieldName.nameBytes.length);\n          this.writeBytes(fieldName.nameBytes);\n        }\n        this._examineNode(element);\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _processFieldNames()\n  //\n  // Processes the field names in preparation for encoding within OSON.\n  //---------------------------------------------------------------------------\n  _processFieldNames() {\n    this.fieldNames.sort((a, b) => {\n      if (a.hashId < b.hashId) return -1;\n      if (a.hashId > b.hashId) return 1;\n      if (a.nameBytes.length < b.nameBytes.length) return -1;\n      if (a.nameBytes.length > b.nameBytes.length) return 1;\n      if (a.name < b.name) return -1;\n      if (a.name > b.name) return 1;\n      return 0;\n    });\n    for (let i = 0; i < this.fieldNames.length; i++) {\n      this.fieldNames[i].fieldId = i + 1;\n    }\n    if (this.fieldNames.length < 256) {\n      this.fieldIdSize = 1;\n    } else if (this.fieldNames.length < 65536) {\n      this.fieldIdSize = 2;\n    } else {\n      this.fieldIdSize = 4;\n    }\n  }\n}\nclass OsonTreeSegment extends GrowableBuffer {\n  //---------------------------------------------------------------------------\n  // _encodeArray()\n  //\n  // Encodes an array in the OSON tree segment.\n  //---------------------------------------------------------------------------\n  _encodeArray(value, fnamesSeg) {\n    this._encodeContainer(constants.TNS_JSON_TYPE_ARRAY, value.length);\n    const len = value.length * 4;\n    const pos = this.reserveBytes(len);\n    let offsetsBufPos = pos;\n    for (const element of value) {\n      this.buf.writeUInt32BE(this.pos, offsetsBufPos);\n      offsetsBufPos += 4;\n      this.encodeNode(element, fnamesSeg);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _encodeContainer()\n  //\n  // Encodes the first part of a container (array or object) in the OSON tree\n  // segment.\n  //---------------------------------------------------------------------------\n  _encodeContainer(nodeType, numChildren) {\n    nodeType |= 0x20; // use uint32_t for offsets\n    if (numChildren > 65535) {\n      nodeType |= 0x10; // num children is uint32_t\n    } else if (numChildren > 255) {\n      nodeType |= 0x08; // num children is uint16_t\n    }\n    this.writeUInt8(nodeType);\n    if (numChildren < 256) {\n      this.writeUInt8(numChildren);\n    } else if (numChildren < 65536) {\n      this.writeUInt16BE(numChildren);\n    } else {\n      this.writeUInt32BE(numChildren);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _encodeObject()\n  //\n  // Encodes an object in the OSON tree segment.\n  //---------------------------------------------------------------------------\n  _encodeObject(value, fnamesSeg) {\n    const numChildren = value.values.length;\n    this._encodeContainer(constants.TNS_JSON_TYPE_OBJECT, numChildren);\n    const len = numChildren * (fnamesSeg.fieldIdSize + 4);\n    const pos = this.reserveBytes(len);\n    let fieldIdOffset = pos;\n    let valueOffset = pos + numChildren * fnamesSeg.fieldIdSize;\n    for (let i = 0; i < value.fields.length; i++) {\n      const fieldName = fnamesSeg.fieldNamesMap.get(value.fields[i]);\n      if (fnamesSeg.fieldIdSize == 1) {\n        this.buf[fieldIdOffset] = fieldName.fieldId;\n      } else if (fnamesSeg.fieldIdSize == 2) {\n        this.buf.writeUInt16BE(fieldName.fieldId, fieldIdOffset);\n      } else {\n        this.buf.writeUInt32BE(fieldName.fieldId, fieldIdOffset);\n      }\n      this.buf.writeUInt32BE(this.pos, valueOffset);\n      fieldIdOffset += fnamesSeg.fieldIdSize;\n      valueOffset += 4;\n      this.encodeNode(value.values[i], fnamesSeg);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // encodeNode()\n  //\n  // Encodes a value (node) in the OSON tree segment.\n  //---------------------------------------------------------------------------\n  encodeNode(value, fnamesSeg) {\n    // handle null\n    if (value === undefined || value === null) {\n      this.writeUInt8(constants.TNS_JSON_TYPE_NULL);\n\n      // handle booleans\n    } else if (typeof value === 'boolean') {\n      if (value) {\n        this.writeUInt8(constants.TNS_JSON_TYPE_TRUE);\n      } else {\n        this.writeUInt8(constants.TNS_JSON_TYPE_FALSE);\n      }\n\n      // handle numbers\n    } else if (typeof value === 'number') {\n      this.writeUInt8(constants.TNS_JSON_TYPE_NUMBER_LENGTH_UINT8);\n      this.writeOracleNumber(value.toString());\n\n      // handle strings\n    } else if (typeof value === 'string') {\n      const buf = Buffer.from(value);\n      if (buf.length < 256) {\n        this.writeUInt8(constants.TNS_JSON_TYPE_STRING_LENGTH_UINT8);\n        this.writeUInt8(buf.length);\n      } else if (buf.length < 65536) {\n        this.writeUInt8(constants.TNS_JSON_TYPE_STRING_LENGTH_UINT16);\n        this.writeUInt16BE(buf.length);\n      } else {\n        this.writeUInt8(constants.TNS_JSON_TYPE_STRING_LENGTH_UINT32);\n        this.writeUInt32BE(buf.length);\n      }\n      if (buf.length > 0) {\n        this.writeBytes(buf);\n      }\n\n      // handle dates\n    } else if (util.isDate(value)) {\n      if (value.getUTCMilliseconds() === 0) {\n        this.writeUInt8(constants.TNS_JSON_TYPE_TIMESTAMP7);\n        this.writeOracleDate(value, types.DB_TYPE_DATE, false);\n      } else {\n        this.writeUInt8(constants.TNS_JSON_TYPE_TIMESTAMP);\n        this.writeOracleDate(value, types.DB_TYPE_TIMESTAMP, false);\n      }\n\n      // handle buffers\n    } else if (Buffer.isBuffer(value)) {\n      if (value.length < 65536) {\n        this.writeUInt8(constants.TNS_JSON_TYPE_BINARY_LENGTH_UINT16);\n        this.writeUInt16BE(value.length);\n      } else {\n        this.writeUInt8(constants.TNS_JSON_TYPE_BINARY_LENGTH_UINT32);\n        this.writeUInt32BE(value.length);\n      }\n      this.writeBytes(value);\n\n      // handle arrays\n    } else if (Array.isArray(value)) {\n      this._encodeArray(value, fnamesSeg);\n\n      // handle objects\n    } else {\n      this._encodeObject(value, fnamesSeg);\n    }\n  }\n}\nclass OsonEncoder extends GrowableBuffer {\n  //---------------------------------------------------------------------------\n  // encode()\n  //\n  // Encodes the value as OSON and returns a buffer containing the OSON bytes.\n  //---------------------------------------------------------------------------\n  encode(value) {\n    // determine flags to use\n    let fnamesSeg;\n    let flags = constants.TNS_JSON_FLAG_INLINE_LEAF;\n    if (Array.isArray(value) || value && Array.isArray(value.fields)) {\n      flags |= constants.TNS_JSON_FLAG_HASH_ID_UINT8 | constants.TNS_JSON_FLAG_TINY_NODES_STAT;\n      fnamesSeg = new OsonFieldNamesSegment(value);\n      if (fnamesSeg.fieldNames.length > 65535) {\n        flags |= constants.TNS_JSON_FLAG_NUM_FNAMES_UINT32;\n      } else if (fnamesSeg.fieldNames.length > 255) {\n        flags |= constants.TNS_JSON_FLAG_NUM_FNAMES_UINT16;\n      }\n      if (fnamesSeg.pos > 65535) {\n        flags |= constants.TNS_JSON_FLAG_FNAMES_SEG_UINT32;\n      }\n    } else {\n      flags |= constants.TNS_JSON_FLAG_IS_SCALAR;\n    }\n\n    // encode values into the tree segment\n    const treeSeg = new OsonTreeSegment();\n    treeSeg.encodeNode(value, fnamesSeg);\n    if (treeSeg.pos > 65535) {\n      flags |= constants.TNS_JSON_FLAG_TREE_SEG_UINT32;\n    }\n\n    // write initial header\n    this.writeUInt8(constants.TNS_JSON_MAGIC_BYTE_1);\n    this.writeUInt8(constants.TNS_JSON_MAGIC_BYTE_2);\n    this.writeUInt8(constants.TNS_JSON_MAGIC_BYTE_3);\n    this.writeUInt8(constants.TNS_JSON_VERSION);\n    this.writeUInt16BE(flags);\n\n    // write extended header (when value is not scalar)\n    if (fnamesSeg) {\n      // write number of field names\n      if (fnamesSeg.fieldNames.length < 256) {\n        this.writeUInt8(fnamesSeg.fieldNames.length);\n      } else if (fnamesSeg.fieldNames.length < 65536) {\n        this.writeUInt16BE(fnamesSeg.fieldNames.length);\n      } else {\n        this.writeUInt32BE(fnamesSeg.fieldNames.length);\n      }\n\n      // write size of field names segment\n      if (fnamesSeg.pos < 65536) {\n        this.writeUInt16BE(fnamesSeg.pos);\n      } else {\n        this.writeUInt32BE(fnamesSeg.pos);\n      }\n    }\n\n    // write size of tree segment\n    if (treeSeg.pos < 65536) {\n      this.writeUInt16BE(treeSeg.pos);\n    } else {\n      this.writeUInt32BE(treeSeg.pos);\n    }\n\n    // write remainder of header and any data (when value is not scalar)\n    if (fnamesSeg) {\n      // write number of \"tiny\" nodes (always zero)\n      this.writeUInt16BE(0);\n\n      // write array of hash ids\n      for (const fieldName of fnamesSeg.fieldNames) {\n        this.writeUInt8(fieldName.hashId);\n      }\n\n      // write array of field name offsets\n      for (const fieldName of fnamesSeg.fieldNames) {\n        if (fnamesSeg.pos < 65536) {\n          this.writeUInt16BE(fieldName.offset);\n        } else {\n          this.writeUInt32BE(fieldName.offset);\n        }\n      }\n\n      // write field names\n      if (fnamesSeg.pos > 0) {\n        this.writeBytes(fnamesSeg.buf.subarray(0, fnamesSeg.pos));\n      }\n    }\n\n    // write tree segment data\n    this.writeBytes(treeSeg.buf.subarray(0, treeSeg.pos));\n    return this.buf.subarray(0, this.pos);\n  }\n}\nmodule.exports = {\n  OsonDecoder,\n  OsonEncoder\n};","map":{"version":3,"names":["BaseBuffer","GrowableBuffer","require","Buffer","constants","errors","types","util","OsonDecoder","_decodeContainerNode","nodeType","container","offsetsPos","fieldIdsPos","numChildren","_getNumChildren","isObject","undefined","offset","_getOffset","pos","treeSegPos","sharedNodeType","readUInt8","Array","fieldIdLength","i","name","fieldId","buf","readUInt16BE","readUInt32BE","fieldNames","_decodeNode","TNS_JSON_TYPE_NULL","TNS_JSON_TYPE_TRUE","TNS_JSON_TYPE_FALSE","TNS_JSON_TYPE_DATE","TNS_JSON_TYPE_TIMESTAMP7","parseOracleDate","readBytes","TNS_JSON_TYPE_TIMESTAMP","TNS_JSON_TYPE_TIMESTAMP_TZ","TNS_JSON_TYPE_BINARY_FLOAT","parseBinaryFloat","TNS_JSON_TYPE_BINARY_DOUBLE","parseBinaryDouble","TNS_JSON_TYPE_STRING_LENGTH_UINT8","toString","TNS_JSON_TYPE_STRING_LENGTH_UINT16","TNS_JSON_TYPE_STRING_LENGTH_UINT32","TNS_JSON_TYPE_NUMBER_LENGTH_UINT8","parseFloat","readOracleNumber","TNS_JSON_TYPE_BINARY_LENGTH_UINT16","from","TNS_JSON_TYPE_BINARY_LENGTH_UINT32","typeBits","len","parseOracleNumber","throwErr","ERR_UNSUPPORTED_DATA_TYPE_IN_JSON","childrenBits","decode","magic","TNS_JSON_MAGIC_BYTE_1","TNS_JSON_MAGIC_BYTE_2","TNS_JSON_MAGIC_BYTE_3","ERR_UNEXPECTED_DATA","version","TNS_JSON_VERSION","ERR_OSON_VERSION_NOT_SUPPORTED","flags","TNS_JSON_FLAG_IS_SCALAR","TNS_JSON_FLAG_TREE_SEG_UINT32","skipBytes","numFieldNames","TNS_JSON_FLAG_NUM_FNAMES_UINT32","TNS_JSON_FLAG_NUM_FNAMES_UINT16","fieldNameOffsetsSize","fieldNamesSegSize","TNS_JSON_FLAG_FNAMES_SEG_UINT32","hashIdSize","TNS_JSON_FLAG_HASH_ID_UINT8","TNS_JSON_FLAG_HASH_ID_UINT16","fieldNameOffsetsPos","fieldNamesPos","subarray","OsonFieldName","constructor","nameBytes","length","ERR_OSON_FIELD_NAME_LIMITATION","hashId","BigInt","multiplier","mask","c","Number","OsonFieldNamesSegment","value","fieldNamesMap","Map","_examineNode","_processFieldNames","isArray","element","fields","values","has","fieldName","set","push","writeUInt8","writeBytes","sort","a","b","fieldIdSize","OsonTreeSegment","_encodeArray","fnamesSeg","_encodeContainer","TNS_JSON_TYPE_ARRAY","reserveBytes","offsetsBufPos","writeUInt32BE","encodeNode","writeUInt16BE","_encodeObject","TNS_JSON_TYPE_OBJECT","fieldIdOffset","valueOffset","get","writeOracleNumber","isDate","getUTCMilliseconds","writeOracleDate","DB_TYPE_DATE","DB_TYPE_TIMESTAMP","isBuffer","OsonEncoder","encode","TNS_JSON_FLAG_INLINE_LEAF","TNS_JSON_FLAG_TINY_NODES_STAT","treeSeg","module","exports"],"sources":["C:/Users/user1/Desktop/finalproject_penpick/node_modules/oracledb/lib/thin/protocol/oson.js"],"sourcesContent":["// Copyright (c) 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst { BaseBuffer, GrowableBuffer } = require('./buffer.js');\nconst { Buffer } = require('buffer');\nconst constants = require(\"./constants.js\");\nconst errors = require(\"../../errors.js\");\nconst types = require(\"../../types.js\");\nconst util = require(\"util\");\n\n/**\n * Class used for decodeing\n */\nclass OsonDecoder extends BaseBuffer {\n\n  //---------------------------------------------------------------------------\n  // _decodeContainerNode()\n  //\n  // Decodes a container node (object or array) from the tree segment and\n  // returns the JavaScript equivalent.\n  //---------------------------------------------------------------------------\n  _decodeContainerNode(nodeType) {\n\n    // determine the number of children by examining the 4th and 5th most\n    // significant bits of the node type; determine the offsets in the tree\n    // segment to the field ids array and the value offsets array\n    let container, offsetsPos, fieldIdsPos;\n    let numChildren = this._getNumChildren(nodeType);\n    const isObject = ((nodeType & 0x40) === 0);\n    if (numChildren === undefined) {\n      const offset = this._getOffset(nodeType);\n      offsetsPos = this.pos;\n      this.pos = this.treeSegPos + offset;\n      const sharedNodeType = this.readUInt8();\n      numChildren = this._getNumChildren(sharedNodeType);\n      container = (isObject) ? {} : new Array(numChildren);\n      fieldIdsPos = this.pos;\n    } else if (isObject) {\n      container = {};\n      fieldIdsPos = this.pos;\n      offsetsPos = this.pos + this.fieldIdLength * numChildren;\n    } else {\n      container = new Array(numChildren);\n      offsetsPos = this.pos;\n    }\n\n    for (let i = 0; i < numChildren; i++) {\n      let name;\n      if (isObject) {\n        let fieldId;\n        if (this.fieldIdLength === 1) {\n          fieldId = this.buf[fieldIdsPos];\n        } else if (this.fieldIdLength == 2) {\n          fieldId = this.buf.readUInt16BE(fieldIdsPos);\n        } else {\n          fieldId = this.buf.readUInt32BE(fieldIdsPos);\n        }\n        name = this.fieldNames[fieldId - 1];\n        fieldIdsPos += this.fieldIdLength;\n      }\n      this.pos = offsetsPos;\n      const offset = this._getOffset(nodeType);\n      offsetsPos = this.pos;\n      this.pos = this.treeSegPos + offset;\n      if (isObject) {\n        container[name] = this._decodeNode();\n      } else {\n        container[i] = this._decodeNode();\n      }\n    }\n\n    return container;\n  }\n\n  //---------------------------------------------------------------------------\n  // _decodeNode()\n  //\n  // Decodes a node from the tree segment and returns the JavaScript\n  // equivalent.\n  //---------------------------------------------------------------------------\n  _decodeNode() {\n\n    // if the most significant bit is set the node refers to a container\n    const nodeType = this.readUInt8();\n    if (nodeType & 0x80) {\n      return this._decodeContainerNode(nodeType);\n    }\n\n    // handle simple scalars\n    if (nodeType === constants.TNS_JSON_TYPE_NULL) {\n      return null;\n    } else if (nodeType === constants.TNS_JSON_TYPE_TRUE) {\n      return true;\n    } else if (nodeType === constants.TNS_JSON_TYPE_FALSE) {\n      return false;\n\n    // handle fixed length scalars\n    } else if (nodeType === constants.TNS_JSON_TYPE_DATE ||\n        nodeType === constants.TNS_JSON_TYPE_TIMESTAMP7) {\n      return this.parseOracleDate(this.readBytes(7));\n    } else if (nodeType === constants.TNS_JSON_TYPE_TIMESTAMP) {\n      return this.parseOracleDate(this.readBytes(11));\n    } else if (nodeType === constants.TNS_JSON_TYPE_TIMESTAMP_TZ) {\n      return this.parseOracleDate(this.readBytes(13));\n    } else if (nodeType === constants.TNS_JSON_TYPE_BINARY_FLOAT) {\n      return this.parseBinaryFloat(this.readBytes(4));\n    } else if (nodeType === constants.TNS_JSON_TYPE_BINARY_DOUBLE) {\n      return this.parseBinaryDouble(this.readBytes(8));\n\n    // handle scalars with lengths stored outside the node itself\n    } else if (nodeType === constants.TNS_JSON_TYPE_STRING_LENGTH_UINT8) {\n      return this.readBytes(this.readUInt8()).toString();\n    } else if (nodeType === constants.TNS_JSON_TYPE_STRING_LENGTH_UINT16) {\n      return this.readBytes(this.readUInt16BE()).toString();\n    } else if (nodeType === constants.TNS_JSON_TYPE_STRING_LENGTH_UINT32) {\n      return this.readBytes(this.readUInt32BE()).toString();\n    } else if (nodeType === constants.TNS_JSON_TYPE_NUMBER_LENGTH_UINT8) {\n      return parseFloat(this.readOracleNumber());\n    } else if (nodeType === constants.TNS_JSON_TYPE_BINARY_LENGTH_UINT16) {\n      return Buffer.from(this.readBytes(this.readUInt16BE()));\n    } else if (nodeType === constants.TNS_JSON_TYPE_BINARY_LENGTH_UINT32) {\n      return Buffer.from(this.readBytes(this.readUInt32BE()));\n    }\n\n    // handle number/decimal with length stored inside the node itself\n    const typeBits = nodeType & 0xf0;\n    if (typeBits === 0x20 || typeBits === 0x60) {\n      const len = nodeType & 0x0f;\n      return parseFloat(this.parseOracleNumber(this.readBytes(len + 1)));\n\n    // handle integer with length stored inside the node itself\n    } else if (typeBits === 0x40 || typeBits === 0x50) {\n      const len = nodeType & 0x0f;\n      return parseFloat(this.parseOracleNumber(this.readBytes(len)));\n\n    // handle string with length stored inside the node itself\n    } else if ((nodeType & 0xe0) == 0) {\n      if (nodeType === 0)\n        return '';\n      return this.readBytes(nodeType).toString();\n    }\n\n    errors.throwErr(errors.ERR_UNSUPPORTED_DATA_TYPE_IN_JSON, nodeType);\n  }\n\n  //---------------------------------------------------------------------------\n  // _getNumChildren()\n  //\n  // Returns the number of children a container has. This is determined by\n  // looking at the 4th and 5th most significant bits of the node type.\n  //\n  //   00 - number of children is uint8_t\n  //   01 - number of children is uint16_t\n  //   10 - number of children is uint32_t\n  //   11 - field ids are shared with another object whose offset follows\n  //\n  // In the latter case the value undefined is returned and the number of\n  // children must be read from the shared object at the specified offset.\n  //---------------------------------------------------------------------------\n  _getNumChildren(nodeType) {\n    const childrenBits = (nodeType & 0x18);\n    if (childrenBits === 0) {\n      return this.readUInt8();\n    } else if (childrenBits === 0x08) {\n      return this.readUInt16BE();\n    } else if (childrenBits === 0x10) {\n      return this.readUInt32BE();\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _getOffset()\n  //\n  // Returns an offset. The offset will be either a 16-bit or 32-bit value\n  // depending on the value of the 3rd significant bit of the node type.\n  //---------------------------------------------------------------------------\n  _getOffset(nodeType) {\n    if (nodeType & 0x20) {\n      return this.readUInt32BE();\n    } else {\n      return this.readUInt16BE();\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // decode()\n  //\n  // Decodes the OSON and returns a JavaScript object corresponding to its\n  // contents.\n  //---------------------------------------------------------------------------\n  decode() {\n\n    // parse root header\n    const magic = this.readBytes(3);\n    if (magic[0] !== constants.TNS_JSON_MAGIC_BYTE_1 ||\n        magic[1] !== constants.TNS_JSON_MAGIC_BYTE_2 ||\n        magic[2] !== constants.TNS_JSON_MAGIC_BYTE_3) {\n      errors.throwErr(errors.ERR_UNEXPECTED_DATA, magic.toString('hex'));\n    }\n    const version = this.readUInt8();\n    if (version !== constants.TNS_JSON_VERSION) {\n      errors.throwErr(errors.ERR_OSON_VERSION_NOT_SUPPORTED, version);\n    }\n    const flags = this.readUInt16BE();\n\n    // scalar values are much simpler\n    if (flags & constants.TNS_JSON_FLAG_IS_SCALAR) {\n      if (flags & constants.TNS_JSON_FLAG_TREE_SEG_UINT32) {\n        this.skipBytes(4);\n      } else {\n        this.skipBytes(2);\n      }\n      return this._decodeNode();\n    }\n\n    // determine the number of field names\n    let numFieldNames;\n    if (flags & constants.TNS_JSON_FLAG_NUM_FNAMES_UINT32) {\n      numFieldNames = this.readUInt32BE();\n      this.fieldIdLength = 4;\n    } else if (flags & constants.TNS_JSON_FLAG_NUM_FNAMES_UINT16) {\n      numFieldNames = this.readUInt16BE();\n      this.fieldIdLength = 2;\n    } else {\n      numFieldNames = this.readUInt8();\n      this.fieldIdLength = 1;\n    }\n\n    // determine the size of the field names segment\n    let fieldNameOffsetsSize, fieldNamesSegSize;\n    if (flags & constants.TNS_JSON_FLAG_FNAMES_SEG_UINT32) {\n      fieldNameOffsetsSize = 4;\n      fieldNamesSegSize = this.readUInt32BE();\n    } else {\n      fieldNameOffsetsSize = 2;\n      fieldNamesSegSize = this.readUInt16BE();\n    }\n\n    // skip the size of the tree segment\n    if (flags & constants.TNS_JSON_FLAG_TREE_SEG_UINT32) {\n      this.skipBytes(4);\n    } else {\n      this.skipBytes(2);\n    }\n\n    // skip the number of \"tiny\" nodes\n    this.skipBytes(2);\n\n    // skip the hash id array\n    let hashIdSize;\n    if (flags & constants.TNS_JSON_FLAG_HASH_ID_UINT8) {\n      hashIdSize = 1;\n    } else if (flags & constants.TNS_JSON_FLAG_HASH_ID_UINT16) {\n      hashIdSize = 2;\n    } else {\n      hashIdSize = 4;\n    }\n    this.skipBytes(numFieldNames * hashIdSize);\n\n    // skip over the field name offsets and field names\n    let fieldNameOffsetsPos = this.pos;\n    this.skipBytes(numFieldNames * fieldNameOffsetsSize);\n    const fieldNamesPos = this.pos;\n    this.skipBytes(fieldNamesSegSize);\n\n    // determine the names of the fields\n    this.fieldNames = new Array(numFieldNames);\n    for (let i = 0; i < numFieldNames; i++) {\n      let offset = fieldNamesPos;\n      if (flags & constants.TNS_JSON_FLAG_FNAMES_SEG_UINT32) {\n        offset += this.buf.readUInt32BE(fieldNameOffsetsPos);\n        fieldNameOffsetsPos += 4;\n      } else {\n        offset += this.buf.readUInt16BE(fieldNameOffsetsPos);\n        fieldNameOffsetsPos += 2;\n      }\n      const len = this.buf[offset];\n      const name = this.buf.subarray(offset + 1, offset + len + 1).toString();\n      this.fieldNames[i] = name;\n    }\n\n    // determine tree segment position in the buffer\n    this.treeSegPos = this.pos;\n\n    // decode the root node\n    return this._decodeNode();\n  }\n\n}\n\nclass OsonFieldName {\n\n  constructor(name) {\n    this.name = name;\n    this.nameBytes = Buffer.from(name);\n    if (this.nameBytes.length > 255) {\n      errors.throwErr(errors.ERR_OSON_FIELD_NAME_LIMITATION);\n    }\n    this.hashId = BigInt(0x811C9DC5);\n    const multiplier = BigInt(16777619);\n    const mask = BigInt(0xffffffff);\n    for (let i = 0; i < this.nameBytes.length; i++) {\n      const c = BigInt(this.nameBytes[i]);\n      this.hashId = ((this.hashId ^ c) * multiplier) & mask;\n    }\n    this.hashId = Number(this.hashId) & 0xff;\n  }\n\n}\n\nclass OsonFieldNamesSegment extends GrowableBuffer {\n\n  constructor(value) {\n    super();\n    this.fieldNamesMap = new Map();\n    this.fieldNames = [];\n    this._examineNode(value);\n    this._processFieldNames();\n  }\n\n  //---------------------------------------------------------------------------\n  // _exmaineNode()\n  //\n  // Examines the value. If it contains fields, unique names are retained. The\n  // values are then examined to see if they also contain fields. Arrays are\n  // examined to determine they contain elements that contain fields.\n  //---------------------------------------------------------------------------\n  _examineNode(value) {\n    if (Array.isArray(value)) {\n      for (const element of value) {\n        this._examineNode(element);\n      }\n    } else if (value && Array.isArray(value.fields)) {\n      for (let i = 0; i < value.fields.length; i++) {\n        const name = value.fields[i];\n        const element = value.values[i];\n        if (!this.fieldNamesMap.has(name)) {\n          const fieldName = new OsonFieldName(name);\n          this.fieldNamesMap.set(name, fieldName);\n          this.fieldNames.push(fieldName);\n          fieldName.offset = this.pos;\n          this.writeUInt8(fieldName.nameBytes.length);\n          this.writeBytes(fieldName.nameBytes);\n        }\n        this._examineNode(element);\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _processFieldNames()\n  //\n  // Processes the field names in preparation for encoding within OSON.\n  //---------------------------------------------------------------------------\n  _processFieldNames() {\n    this.fieldNames.sort((a, b) => {\n      if (a.hashId < b.hashId)\n        return -1;\n      if (a.hashId > b.hashId)\n        return 1;\n      if (a.nameBytes.length < b.nameBytes.length)\n        return -1;\n      if (a.nameBytes.length > b.nameBytes.length)\n        return 1;\n      if (a.name < b.name)\n        return -1;\n      if (a.name > b.name)\n        return 1;\n      return 0;\n    });\n    for (let i = 0; i < this.fieldNames.length; i++) {\n      this.fieldNames[i].fieldId = i + 1;\n    }\n    if (this.fieldNames.length < 256) {\n      this.fieldIdSize = 1;\n    } else if (this.fieldNames.length < 65536) {\n      this.fieldIdSize = 2;\n    } else {\n      this.fieldIdSize = 4;\n    }\n  }\n\n}\n\nclass OsonTreeSegment extends GrowableBuffer {\n\n  //---------------------------------------------------------------------------\n  // _encodeArray()\n  //\n  // Encodes an array in the OSON tree segment.\n  //---------------------------------------------------------------------------\n  _encodeArray(value, fnamesSeg) {\n    this._encodeContainer(constants.TNS_JSON_TYPE_ARRAY, value.length);\n    const len = value.length * 4;\n    const pos = this.reserveBytes(len);\n    let offsetsBufPos = pos;\n    for (const element of value) {\n      this.buf.writeUInt32BE(this.pos, offsetsBufPos);\n      offsetsBufPos += 4;\n      this.encodeNode(element, fnamesSeg);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _encodeContainer()\n  //\n  // Encodes the first part of a container (array or object) in the OSON tree\n  // segment.\n  //---------------------------------------------------------------------------\n  _encodeContainer(nodeType, numChildren) {\n    nodeType |= 0x20;                   // use uint32_t for offsets\n    if (numChildren > 65535) {\n      nodeType |= 0x10;                 // num children is uint32_t\n    } else if (numChildren > 255) {\n      nodeType |= 0x08;                 // num children is uint16_t\n    }\n    this.writeUInt8(nodeType);\n    if (numChildren < 256) {\n      this.writeUInt8(numChildren);\n    } else if (numChildren < 65536) {\n      this.writeUInt16BE(numChildren);\n    } else {\n      this.writeUInt32BE(numChildren);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _encodeObject()\n  //\n  // Encodes an object in the OSON tree segment.\n  //---------------------------------------------------------------------------\n  _encodeObject(value, fnamesSeg) {\n    const numChildren = value.values.length;\n    this._encodeContainer(constants.TNS_JSON_TYPE_OBJECT, numChildren);\n    const len = numChildren * (fnamesSeg.fieldIdSize + 4);\n    const pos = this.reserveBytes(len);\n    let fieldIdOffset = pos;\n    let valueOffset = pos + (numChildren * fnamesSeg.fieldIdSize);\n\n    for (let i = 0; i < value.fields.length; i++) {\n      const fieldName = fnamesSeg.fieldNamesMap.get(value.fields[i]);\n      if (fnamesSeg.fieldIdSize == 1) {\n        this.buf[fieldIdOffset] = fieldName.fieldId;\n      } else if (fnamesSeg.fieldIdSize == 2) {\n        this.buf.writeUInt16BE(fieldName.fieldId, fieldIdOffset);\n      } else {\n        this.buf.writeUInt32BE(fieldName.fieldId, fieldIdOffset);\n      }\n      this.buf.writeUInt32BE(this.pos, valueOffset);\n      fieldIdOffset += fnamesSeg.fieldIdSize;\n      valueOffset += 4;\n      this.encodeNode(value.values[i], fnamesSeg);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // encodeNode()\n  //\n  // Encodes a value (node) in the OSON tree segment.\n  //---------------------------------------------------------------------------\n  encodeNode(value, fnamesSeg) {\n\n    // handle null\n    if (value === undefined || value === null) {\n      this.writeUInt8(constants.TNS_JSON_TYPE_NULL);\n\n    // handle booleans\n    } else if (typeof value === 'boolean') {\n      if (value) {\n        this.writeUInt8(constants.TNS_JSON_TYPE_TRUE);\n      } else {\n        this.writeUInt8(constants.TNS_JSON_TYPE_FALSE);\n      }\n\n    // handle numbers\n    } else if (typeof value === 'number') {\n      this.writeUInt8(constants.TNS_JSON_TYPE_NUMBER_LENGTH_UINT8);\n      this.writeOracleNumber(value.toString());\n\n    // handle strings\n    } else if (typeof value === 'string') {\n      const buf = Buffer.from(value);\n      if (buf.length < 256) {\n        this.writeUInt8(constants.TNS_JSON_TYPE_STRING_LENGTH_UINT8);\n        this.writeUInt8(buf.length);\n      } else if (buf.length < 65536) {\n        this.writeUInt8(constants.TNS_JSON_TYPE_STRING_LENGTH_UINT16);\n        this.writeUInt16BE(buf.length);\n      } else {\n        this.writeUInt8(constants.TNS_JSON_TYPE_STRING_LENGTH_UINT32);\n        this.writeUInt32BE(buf.length);\n      }\n      if (buf.length > 0) {\n        this.writeBytes(buf);\n      }\n\n    // handle dates\n    } else if (util.isDate(value)) {\n      if (value.getUTCMilliseconds() === 0) {\n        this.writeUInt8(constants.TNS_JSON_TYPE_TIMESTAMP7);\n        this.writeOracleDate(value, types.DB_TYPE_DATE, false);\n      } else {\n        this.writeUInt8(constants.TNS_JSON_TYPE_TIMESTAMP);\n        this.writeOracleDate(value, types.DB_TYPE_TIMESTAMP, false);\n      }\n\n    // handle buffers\n    } else if (Buffer.isBuffer(value)) {\n      if (value.length < 65536) {\n        this.writeUInt8(constants.TNS_JSON_TYPE_BINARY_LENGTH_UINT16);\n        this.writeUInt16BE(value.length);\n      } else {\n        this.writeUInt8(constants.TNS_JSON_TYPE_BINARY_LENGTH_UINT32);\n        this.writeUInt32BE(value.length);\n      }\n      this.writeBytes(value);\n\n    // handle arrays\n    } else if (Array.isArray(value)) {\n      this._encodeArray(value, fnamesSeg);\n\n    // handle objects\n    } else {\n      this._encodeObject(value, fnamesSeg);\n    }\n\n  }\n\n}\n\nclass OsonEncoder extends GrowableBuffer {\n\n  //---------------------------------------------------------------------------\n  // encode()\n  //\n  // Encodes the value as OSON and returns a buffer containing the OSON bytes.\n  //---------------------------------------------------------------------------\n  encode(value) {\n\n    // determine flags to use\n    let fnamesSeg;\n    let flags = constants.TNS_JSON_FLAG_INLINE_LEAF;\n    if (Array.isArray(value) || (value && Array.isArray(value.fields))) {\n      flags |= constants.TNS_JSON_FLAG_HASH_ID_UINT8 |\n        constants.TNS_JSON_FLAG_TINY_NODES_STAT;\n      fnamesSeg = new OsonFieldNamesSegment(value);\n      if (fnamesSeg.fieldNames.length > 65535) {\n        flags |= constants.TNS_JSON_FLAG_NUM_FNAMES_UINT32;\n      } else if (fnamesSeg.fieldNames.length > 255) {\n        flags |= constants.TNS_JSON_FLAG_NUM_FNAMES_UINT16;\n      }\n      if (fnamesSeg.pos > 65535) {\n        flags |= constants.TNS_JSON_FLAG_FNAMES_SEG_UINT32;\n      }\n    } else {\n      flags |= constants.TNS_JSON_FLAG_IS_SCALAR;\n    }\n\n    // encode values into the tree segment\n    const treeSeg = new OsonTreeSegment();\n    treeSeg.encodeNode(value, fnamesSeg);\n    if (treeSeg.pos > 65535) {\n      flags |= constants.TNS_JSON_FLAG_TREE_SEG_UINT32;\n    }\n\n    // write initial header\n    this.writeUInt8(constants.TNS_JSON_MAGIC_BYTE_1);\n    this.writeUInt8(constants.TNS_JSON_MAGIC_BYTE_2);\n    this.writeUInt8(constants.TNS_JSON_MAGIC_BYTE_3);\n    this.writeUInt8(constants.TNS_JSON_VERSION);\n    this.writeUInt16BE(flags);\n\n    // write extended header (when value is not scalar)\n    if (fnamesSeg) {\n\n      // write number of field names\n      if (fnamesSeg.fieldNames.length < 256) {\n        this.writeUInt8(fnamesSeg.fieldNames.length);\n      } else if (fnamesSeg.fieldNames.length < 65536) {\n        this.writeUInt16BE(fnamesSeg.fieldNames.length);\n      } else {\n        this.writeUInt32BE(fnamesSeg.fieldNames.length);\n      }\n\n      // write size of field names segment\n      if (fnamesSeg.pos < 65536) {\n        this.writeUInt16BE(fnamesSeg.pos);\n      } else {\n        this.writeUInt32BE(fnamesSeg.pos);\n      }\n\n    }\n\n    // write size of tree segment\n    if (treeSeg.pos < 65536) {\n      this.writeUInt16BE(treeSeg.pos);\n    } else {\n      this.writeUInt32BE(treeSeg.pos);\n    }\n\n    // write remainder of header and any data (when value is not scalar)\n    if (fnamesSeg) {\n\n      // write number of \"tiny\" nodes (always zero)\n      this.writeUInt16BE(0);\n\n      // write array of hash ids\n      for (const fieldName of fnamesSeg.fieldNames) {\n        this.writeUInt8(fieldName.hashId);\n      }\n\n      // write array of field name offsets\n      for (const fieldName of fnamesSeg.fieldNames) {\n        if (fnamesSeg.pos < 65536) {\n          this.writeUInt16BE(fieldName.offset);\n        } else {\n          this.writeUInt32BE(fieldName.offset);\n        }\n      }\n\n      // write field names\n      if (fnamesSeg.pos > 0) {\n        this.writeBytes(fnamesSeg.buf.subarray(0, fnamesSeg.pos));\n      }\n\n    }\n\n    // write tree segment data\n    this.writeBytes(treeSeg.buf.subarray(0, treeSeg.pos));\n\n    return this.buf.subarray(0, this.pos);\n  }\n\n}\n\nmodule.exports = {\n  OsonDecoder,\n  OsonEncoder\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}