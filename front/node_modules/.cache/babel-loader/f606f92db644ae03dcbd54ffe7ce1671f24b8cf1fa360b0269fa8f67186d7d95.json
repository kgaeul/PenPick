{"ast":null,"code":"// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst Buffer = require(\"buffer\").Buffer;\nconst constants = require(\"./constants.js\");\nconst errors = require(\"../../errors.js\");\nconst MAX_CDATA_LEN = 230;\nconst NSPCNL = 74;\n\n/**\n * Connect Packet (NSPTCN)\n * @param {Buffer} connectData Outgoing Connect Data\n * @param {Object} sAtts Session Attributes\n */\nfunction ConnectPacket(connectData, sAtts, flags = 0) {\n  this.connectData = connectData;\n  this.connectDataLen = connectData.length;\n  this.overflow = false;\n  let size;\n  if (this.connectDataLen <= MAX_CDATA_LEN) {\n    size = NSPCNL + this.connectDataLen;\n  } else {\n    size = NSPCNL;\n    this.overflow = true;\n  }\n\n  /* Building Connect Packet */\n  this.buf = Buffer.allocUnsafe(size).fill(0);\n  this.buf.writeUInt16BE(size, constants.NSPHDLEN);\n  this.buf.writeUInt8(flags, constants.NSPHDFLGS);\n  this.buf.writeUInt8(constants.NSPTCN, constants.NSPHDTYP);\n  this.buf.writeUInt16BE(constants.TNS_VERSION_DESIRED, constants.NSPCNVSN); /* My version */\n  this.buf.writeUInt16BE(constants.TNS_VERSION_MINIMUM, constants.NSPCNLOV); /* Lowest version*/\n\n  /* Options:\n        Note : Node JS does not support TCP Out-of-band so not setting NSGSENDATTN or NSGRECVATTN\n  */\n  const options = constants.NSGDONTCARE;\n  //options = options | constants.NSGUSEVIO  /* Vectored I/O support.Uncomment when support is added */\n  this.buf.writeUInt16BE(options, constants.NSPCNOPT);\n\n  /* SDU */\n  if (sAtts.sdu > constants.NSPMXSDULN) {\n    this.buf.writeUInt16BE(constants.NSPMXSDULN, constants.NSPCNSDU);\n  } else {\n    this.buf.writeUInt16BE(sAtts.sdu, constants.NSPCNSDU);\n  }\n\n  /* TDU */\n  if (sAtts.tdu > constants.NSPMXSDULN) {\n    this.buf.writeUInt16BE(constants.NSPMXSDULN, constants.NSPCNTDU);\n  } else {\n    this.buf.writeUInt16BE(sAtts.tdu, constants.NSPCNTDU);\n  }\n  this.buf.writeUInt16BE(sAtts.ntCha, constants.NSPCNNTC); /* Protocol characteristics */\n\n  this.buf.writeUInt16BE(1, constants.NSPCNONE); /* Endianness does not matter for Node */\n\n  this.buf.writeUInt16BE(this.connectDataLen, constants.NSPCNLEN); /* Connect data Length */\n\n  this.buf.writeUInt16BE(constants.NSPCNDAT, constants.NSPCNOFF); /* Connect data offset */\n\n  this.buf.writeUInt8(constants.NSISUPSECRENEG | constants.NSINADISABLEDFORCONNECTION, constants.NSPCNFL0); /* NA disabled */\n\n  this.buf.writeUInt8(constants.NSISUPSECRENEG | constants.NSINADISABLEDFORCONNECTION, constants.NSPCNFL1); /* NA disabled *\n                                                                                                            /* Connection Pool is not supported */\n  this.buf.writeUInt16BE(0, constants.NSPCNTMO);\n  this.buf.writeUInt16BE(0, constants.NSPCNTCK);\n  this.buf.writeUInt16BE(0, constants.NSPCNADL);\n  this.buf.writeUInt16BE(0, constants.NSPCNAOF);\n  this.buf.writeUInt32BE(sAtts.sdu, constants.NSPCNLSD); /* SDU */\n  this.buf.writeUInt32BE(sAtts.tdu, constants.NSPCNLTD); /* TDU */\n  this.buf.writeUInt32BE(0, constants.NSPCNCFL); /* Compression not supported */\n\n  this.buf.writeUInt32BE(0, constants.NSPCNCFL2); /* No OOB path check support */\n\n  if (!this.overflow && this.connectDataLen) {\n    this.buf.write(connectData.toString('ascii'), constants.NSPCNDAT, this.connectDataLen, \"ascii\");\n  }\n}\n\n/**\n * Data Pakcet (NSPTDA)\n * @param {int} size of Data Packet\n * @param {boolean} isLargeSDU Large SDU\n */\nfunction DataPacket(isLargeSDU) {\n  this.dataPtr = 0; /* data offset start */\n  this.dataLen = 0; /* data offset end */\n  this.offset = 0; /* Offset for buffer read/write (fastpath) */\n  this.len = 0; /* Length of buffer read/write (fastpath) */\n  this.bufLen = 0; /* Length of buffer */\n\n  /**\n   * Create the Data Packet(Internal)\n   */\n  this.createPacket = function (len) {\n    /* Building Data Packet */\n    this.dataPtr = constants.NSPDADAT;\n    this.dataLen = constants.NSPDADAT;\n    this.buf = Buffer.allocUnsafe(len).fill(0);\n    this.buf.writeUInt8(0, constants.NSPHDFLGS);\n    this.buf.writeUInt8(constants.NSPTDA, constants.NSPHDTYP);\n    this.bufLen = len; /* Length of buffer */\n  };\n\n  /**\n   * Populate the Data Packet\n   * @param {Buffer} userbuf User Buffer\n   * @param {int} offset from which to fill data\n   * @param {int} len length of data\n   * @returns number of bytes copied\n   */\n  this.fillBuf = function (userbuf, offset, len, flags = 0) {\n    let bytes2Copy;\n    if (!this.buf) {\n      this.createPacket(len + constants.NSPDADAT); //Currently NS data packets are being used only in the connect/disconnect phase\n    }\n    if (len > this.bufLen - this.dataLen) {\n      bytes2Copy = this.bufLen - this.dataLen;\n    } else {\n      bytes2Copy = len;\n    }\n    if (bytes2Copy) {\n      userbuf.copy(this.buf, this.dataLen, offset, offset + bytes2Copy);\n    }\n    this.dataLen += bytes2Copy;\n    this.prepare2Send(flags);\n    return bytes2Copy;\n  };\n\n  /**\n   * Prepare Data Packet for send\n   * @param {int} flags Data flags\n   */\n  this.prepare2Send = function (flags = 0) {\n    if (isLargeSDU) {\n      this.buf.writeUInt32BE(this.dataLen, constants.NSPHDLEN);\n    } else {\n      this.buf.writeUInt16BE(this.dataLen, constants.NSPHDLEN);\n    }\n    this.buf.writeUInt16BE(flags, constants.NSPDAFLG);\n    this.dataBuf = this.buf.subarray(0, this.dataLen);\n  };\n\n  /**\n   * Construct Data Packet from receive data\n   * @param {Packet} packet NS packet\n   */\n  this.fromPacket = function (packet) {\n    this.buf = packet.buf;\n    this.dataLen = packet.buf.length;\n    this.dataPtr = constants.NSPDADAT;\n    this.offset = this.dataPtr;\n    this.len = this.dataLen;\n    packet.dataOffset = this.dataPtr;\n  };\n}\n\n/**\n * Accept Packet (NSPTAC)\n * @param {Packet} packet NS packet\n * @param {*} sAtts session Attributes\n */\nfunction AcceptPacket(packet, sAtts) {\n  this.buf = packet.buf;\n  this.len = packet.buf.length;\n\n  /* Set negotiated values */\n  sAtts.version = packet.buf.readUInt16BE(constants.NSPACVSN);\n  sAtts.options = packet.buf.readUInt16BE(constants.NSPACOPT);\n  sAtts.sdu = packet.buf.readUInt16BE(constants.NSPACSDU);\n  sAtts.tdu = packet.buf.readUInt16BE(constants.NSPACTDU);\n  if (sAtts.version >= 315) {\n    /* Large SDU Support */\n    sAtts.sdu = packet.buf.readUInt32BE(constants.NSPACLSD);\n    sAtts.tdu = packet.buf.readUInt32BE(constants.NSPACLTD);\n    sAtts.largeSDU = true;\n  }\n\n  /* Accept flags */\n  this.flag0 = packet.buf.readUInt8(constants.NSPACFL0);\n  this.flag1 = packet.buf.readUInt8(constants.NSPACFL1);\n\n  /* UUID - CDB Instance ID */\n  if (sAtts.version >= constants.TNS_VERSION_MIN_UUID) {\n    packet.dbUUID = packet.buf.subarray(constants.TNS_UUID_OFFSET, constants.TNS_UUID_OFFSET + 16);\n    packet.dbUUID = packet.dbUUID.toString('base64');\n  }\n}\n\n/**\n * Refuse Packet\n * @param {*} packet NS packet\n */\nfunction RefusePacket(packet) {\n  this.buf = packet.buf;\n  this.len = packet.buf.length;\n  this.userReason = packet.buf.readUInt8(constants.NSPRFURS);\n  this.systemReason = packet.buf.readUInt8(constants.NSPRFURS);\n  this.dataLen = packet.buf.readUInt16BE(constants.NSPRFLEN);\n  this.dataOff = constants.NSPRFDAT;\n  if (this.len > this.dataOff) {\n    this.dataBuf = this.buf.toString('ascii', this.dataOff, this.len);\n    this.overflow = false;\n  } else {\n    this.overflow = true;\n  }\n}\n\n/**\n * Redirect Packet (NSPTRD)\n * @param {*} packet NS packet\n */\nfunction RedirectPacket(packet) {\n  this.buf = packet.buf;\n  this.len = packet.buf.length;\n  this.flags = packet.flags;\n  this.dataLen = packet.buf.readUInt16BE(constants.NSPRDLEN);\n  this.dataOff = constants.NSPRDDAT;\n  if (this.len > this.dataOff) {\n    this.dataBuf = this.buf.subarray(this.dataOff, this.len);\n    this.overflow = false;\n  } else {\n    this.overflow = true;\n  }\n}\n\n/**\n * Marker Packet (NSPTMK)\n * @param {int} isLargeSDU Large SDU\n */\nfunction MarkerPacket(isLargeSDU) {\n  this.len = constants.NSPMKDAT + 1; /* Packet length */\n  this.buf = Buffer.allocUnsafe(constants.NSPMKDAT + 1); /* Packet Buffer */\n\n  if (isLargeSDU) {\n    this.buf.writeUInt32BE(this.len, constants.NSPHDLEN);\n  } else {\n    this.buf.writeUInt16BE(this.len, constants.NSPHDLEN);\n  }\n  this.buf.writeUInt8(0, constants.NSPHDFLGS);\n  this.buf.writeUInt8(constants.NSPTMK, constants.NSPHDTYP);\n\n  /**\n   * Prepare Marker packet for write\n   * @param {Uint8} type of Marker\n   * @param {Uint8} data Marker byte\n   */\n  this.prepare = function (type, data) {\n    this.buf.writeUInt8(type, constants.NSPMKTYP);\n    this.buf.writeUInt8(data, constants.NSPMKDAT);\n  };\n\n  /**\n   * Marker Packet receive\n   * @param {Packet} packet NS packet\n   * @param {NetworkSession} nsi Network Session\n   */\n  this.fromPacket = function (packet, nsi) {\n    this.type = packet.buf.readUInt8(constants.NSPMKTYP);\n    switch (this.type) {\n      case constants.NSPMKTD0:\n        nsi.isBreak = true;\n        break;\n      case constants.NSPMKTD1:\n        this.data = packet.buf.readUInt8(constants.NSPMKDAT);\n        nsi.isBreak = true;\n        if (this.data == constants.NIQRMARK) {\n          nsi.isReset = true;\n          nsi.isBreak = true;\n        }\n        break;\n      default:\n        errors.throwErr(errors.ERR_INVALID_PACKET);\n    }\n  };\n}\n\n/**\n * Control Packet NSPTCTL\n */\n\nfunction ControlPacket() {\n  /**\n   * Clear(reset) the packet\n   */\n  this.clear = function () {\n    this.errno = 0;\n    this.notif = null;\n    this.notifLen = 0;\n    this.cmd = 0;\n  };\n\n  /**\n   * Control Packet receive\n   * @param {*} packet NS packet\n   */\n  this.fromPacket = function (packet) {\n    const NSECMANSHUT = 12572; // CMAN SHUTDOWN\n    const NSESENDMESG = 12573; // SEND MESSAGE\n    const ORA_ERROR_EMFI_NUMBER = 22; //ORA -error\n    let emfi;\n    let err1;\n    let err2;\n    this.cmd = packet.buf.readUInt16BE(constants.NSPCTLCMD);\n    switch (this.cmd) {\n      case constants.NSPCTL_SERR:\n        emfi = packet.buf.readUInt32BE(constants.NSPCTLDAT);\n        err1 = packet.buf.readUInt32BE(constants.NSPCTLDAT + 4);\n        err2 = packet.buf.readUInt32BE(constants.NSPCTLDAT + 8);\n        if (err1 == NSECMANSHUT) {\n          this.errno = err1;\n        } else if (err1 == NSESENDMESG) {\n          this.errno = err1;\n          this.notifLen = err2;\n          this.notif = Buffer.allocUnsafe(err2 + 1).fill(0);\n          this.buf.copy(this.notif, 0, constants.NSPCTLDAT + 12, constants.NSPCTLDAT + 12 + err2);\n        } else {\n          this.errno = err1;\n          if (emfi == ORA_ERROR_EMFI_NUMBER) {\n            errors.throwErr(errors.ERR_CONNECTION_INBAND, \"ORA\" + \"-\" + err1);\n          } else {\n            errors.throwErr(errors.ERR_CONNECTION_INBAND, \"TNS\" + \"-\" + err1);\n          }\n        }\n        break;\n      default:\n        errors.throwErr(errors.ERR_INVALID_PACKET);\n    }\n  };\n}\nmodule.exports = {\n  ConnectPacket,\n  DataPacket,\n  AcceptPacket,\n  RefusePacket,\n  RedirectPacket,\n  MarkerPacket,\n  ControlPacket\n};","map":{"version":3,"names":["Buffer","require","constants","errors","MAX_CDATA_LEN","NSPCNL","ConnectPacket","connectData","sAtts","flags","connectDataLen","length","overflow","size","buf","allocUnsafe","fill","writeUInt16BE","NSPHDLEN","writeUInt8","NSPHDFLGS","NSPTCN","NSPHDTYP","TNS_VERSION_DESIRED","NSPCNVSN","TNS_VERSION_MINIMUM","NSPCNLOV","options","NSGDONTCARE","NSPCNOPT","sdu","NSPMXSDULN","NSPCNSDU","tdu","NSPCNTDU","ntCha","NSPCNNTC","NSPCNONE","NSPCNLEN","NSPCNDAT","NSPCNOFF","NSISUPSECRENEG","NSINADISABLEDFORCONNECTION","NSPCNFL0","NSPCNFL1","NSPCNTMO","NSPCNTCK","NSPCNADL","NSPCNAOF","writeUInt32BE","NSPCNLSD","NSPCNLTD","NSPCNCFL","NSPCNCFL2","write","toString","DataPacket","isLargeSDU","dataPtr","dataLen","offset","len","bufLen","createPacket","NSPDADAT","NSPTDA","fillBuf","userbuf","bytes2Copy","copy","prepare2Send","NSPDAFLG","dataBuf","subarray","fromPacket","packet","dataOffset","AcceptPacket","version","readUInt16BE","NSPACVSN","NSPACOPT","NSPACSDU","NSPACTDU","readUInt32BE","NSPACLSD","NSPACLTD","largeSDU","flag0","readUInt8","NSPACFL0","flag1","NSPACFL1","TNS_VERSION_MIN_UUID","dbUUID","TNS_UUID_OFFSET","RefusePacket","userReason","NSPRFURS","systemReason","NSPRFLEN","dataOff","NSPRFDAT","RedirectPacket","NSPRDLEN","NSPRDDAT","MarkerPacket","NSPMKDAT","NSPTMK","prepare","type","data","NSPMKTYP","nsi","NSPMKTD0","isBreak","NSPMKTD1","NIQRMARK","isReset","throwErr","ERR_INVALID_PACKET","ControlPacket","clear","errno","notif","notifLen","cmd","NSECMANSHUT","NSESENDMESG","ORA_ERROR_EMFI_NUMBER","emfi","err1","err2","NSPCTLCMD","NSPCTL_SERR","NSPCTLDAT","ERR_CONNECTION_INBAND","module","exports"],"sources":["C:/Users/user1/Desktop/finalproject_penpick/node_modules/oracledb/lib/thin/sqlnet/packet.js"],"sourcesContent":["// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst Buffer = require(\"buffer\").Buffer;\nconst constants = require(\"./constants.js\");\nconst errors = require(\"../../errors.js\");\nconst MAX_CDATA_LEN = 230;\nconst NSPCNL = 74;\n\n/**\n * Connect Packet (NSPTCN)\n * @param {Buffer} connectData Outgoing Connect Data\n * @param {Object} sAtts Session Attributes\n */\nfunction ConnectPacket(connectData, sAtts, flags = 0) {\n  this.connectData = connectData;\n  this.connectDataLen = connectData.length;\n  this.overflow = false;\n\n  let size;\n\n  if (this.connectDataLen <= MAX_CDATA_LEN) {\n    size = NSPCNL + this.connectDataLen;\n  } else {\n    size = NSPCNL;\n    this.overflow = true;\n  }\n\n  /* Building Connect Packet */\n  this.buf = Buffer.allocUnsafe(size).fill(0);\n  this.buf.writeUInt16BE(size, constants.NSPHDLEN);\n  this.buf.writeUInt8(flags, constants.NSPHDFLGS);\n  this.buf.writeUInt8(constants.NSPTCN, constants.NSPHDTYP);\n\n  this.buf.writeUInt16BE(\n    constants.TNS_VERSION_DESIRED,\n    constants.NSPCNVSN\n  ); /* My version */\n  this.buf.writeUInt16BE(\n    constants.TNS_VERSION_MINIMUM,\n    constants.NSPCNLOV\n  ); /* Lowest version*/\n\n  /* Options:\n        Note : Node JS does not support TCP Out-of-band so not setting NSGSENDATTN or NSGRECVATTN\n  */\n  const options = constants.NSGDONTCARE;\n  //options = options | constants.NSGUSEVIO  /* Vectored I/O support.Uncomment when support is added */\n  this.buf.writeUInt16BE(options, constants.NSPCNOPT);\n\n  /* SDU */\n  if (sAtts.sdu > constants.NSPMXSDULN) {\n    this.buf.writeUInt16BE(constants.NSPMXSDULN, constants.NSPCNSDU);\n  } else {\n    this.buf.writeUInt16BE(sAtts.sdu, constants.NSPCNSDU);\n  }\n\n  /* TDU */\n  if (sAtts.tdu > constants.NSPMXSDULN) {\n    this.buf.writeUInt16BE(constants.NSPMXSDULN, constants.NSPCNTDU);\n  } else {\n    this.buf.writeUInt16BE(sAtts.tdu, constants.NSPCNTDU);\n  }\n\n  this.buf.writeUInt16BE(\n    sAtts.ntCha,\n    constants.NSPCNNTC\n  ); /* Protocol characteristics */\n\n  this.buf.writeUInt16BE(\n    1,\n    constants.NSPCNONE\n  ); /* Endianness does not matter for Node */\n\n  this.buf.writeUInt16BE(\n    this.connectDataLen,\n    constants.NSPCNLEN\n  ); /* Connect data Length */\n\n  this.buf.writeUInt16BE(\n    constants.NSPCNDAT,\n    constants.NSPCNOFF\n  ); /* Connect data offset */\n\n  this.buf.writeUInt8(\n    constants.NSISUPSECRENEG | constants.NSINADISABLEDFORCONNECTION,\n    constants.NSPCNFL0\n  ); /* NA disabled */\n\n  this.buf.writeUInt8(\n    constants.NSISUPSECRENEG | constants.NSINADISABLEDFORCONNECTION,\n    constants.NSPCNFL1\n  ); /* NA disabled *\n\n  /* Connection Pool is not supported */\n  this.buf.writeUInt16BE(0, constants.NSPCNTMO);\n  this.buf.writeUInt16BE(0, constants.NSPCNTCK);\n  this.buf.writeUInt16BE(0, constants.NSPCNADL);\n  this.buf.writeUInt16BE(0, constants.NSPCNAOF);\n\n  this.buf.writeUInt32BE(sAtts.sdu, constants.NSPCNLSD); /* SDU */\n  this.buf.writeUInt32BE(sAtts.tdu, constants.NSPCNLTD); /* TDU */\n  this.buf.writeUInt32BE(0, constants.NSPCNCFL); /* Compression not supported */\n\n  this.buf.writeUInt32BE(\n    0,\n    constants.NSPCNCFL2\n  ); /* No OOB path check support */\n\n  if (!this.overflow && this.connectDataLen) {\n    this.buf.write(connectData.toString('ascii'), constants.NSPCNDAT, this.connectDataLen, \"ascii\");\n  }\n}\n\n/**\n * Data Pakcet (NSPTDA)\n * @param {int} size of Data Packet\n * @param {boolean} isLargeSDU Large SDU\n */\nfunction DataPacket(isLargeSDU) {\n  this.dataPtr = 0; /* data offset start */\n  this.dataLen = 0; /* data offset end */\n  this.offset = 0; /* Offset for buffer read/write (fastpath) */\n  this.len = 0; /* Length of buffer read/write (fastpath) */\n  this.bufLen = 0; /* Length of buffer */\n\n  /**\n   * Create the Data Packet(Internal)\n   */\n  this.createPacket = function(len) {\n    /* Building Data Packet */\n    this.dataPtr = constants.NSPDADAT;\n    this.dataLen = constants.NSPDADAT;\n    this.buf = Buffer.allocUnsafe(len).fill(0);\n    this.buf.writeUInt8(0, constants.NSPHDFLGS);\n    this.buf.writeUInt8(constants.NSPTDA, constants.NSPHDTYP);\n    this.bufLen = len; /* Length of buffer */\n  };\n\n  /**\n   * Populate the Data Packet\n   * @param {Buffer} userbuf User Buffer\n   * @param {int} offset from which to fill data\n   * @param {int} len length of data\n   * @returns number of bytes copied\n   */\n  this.fillBuf = function(userbuf, offset, len, flags = 0) {\n    let bytes2Copy;\n\n    if (!this.buf) {\n      this.createPacket(len + constants.NSPDADAT); //Currently NS data packets are being used only in the connect/disconnect phase\n    }\n\n    if (len > this.bufLen - this.dataLen) {\n      bytes2Copy = this.bufLen - this.dataLen;\n    } else {\n      bytes2Copy = len;\n    }\n    if (bytes2Copy) {\n      userbuf.copy(this.buf, this.dataLen, offset, offset + bytes2Copy);\n    }\n    this.dataLen += bytes2Copy;\n\n    this.prepare2Send(flags);\n\n    return bytes2Copy;\n  };\n\n  /**\n   * Prepare Data Packet for send\n   * @param {int} flags Data flags\n   */\n  this.prepare2Send = function(flags = 0) {\n    if (isLargeSDU) {\n      this.buf.writeUInt32BE(this.dataLen, constants.NSPHDLEN);\n    } else {\n      this.buf.writeUInt16BE(this.dataLen, constants.NSPHDLEN);\n    }\n\n    this.buf.writeUInt16BE(flags, constants.NSPDAFLG);\n    this.dataBuf = this.buf.subarray(0, this.dataLen);\n  };\n\n  /**\n   * Construct Data Packet from receive data\n   * @param {Packet} packet NS packet\n   */\n  this.fromPacket = function(packet) {\n    this.buf = packet.buf;\n    this.dataLen = packet.buf.length;\n    this.dataPtr = constants.NSPDADAT;\n    this.offset = this.dataPtr;\n    this.len = this.dataLen;\n    packet.dataOffset = this.dataPtr;\n  };\n}\n\n/**\n * Accept Packet (NSPTAC)\n * @param {Packet} packet NS packet\n * @param {*} sAtts session Attributes\n */\nfunction AcceptPacket(packet, sAtts) {\n  this.buf = packet.buf;\n  this.len = packet.buf.length;\n\n  /* Set negotiated values */\n  sAtts.version = packet.buf.readUInt16BE(constants.NSPACVSN);\n  sAtts.options = packet.buf.readUInt16BE(constants.NSPACOPT);\n  sAtts.sdu = packet.buf.readUInt16BE(constants.NSPACSDU);\n  sAtts.tdu = packet.buf.readUInt16BE(constants.NSPACTDU);\n\n  if (sAtts.version >= 315) {\n    /* Large SDU Support */\n    sAtts.sdu = packet.buf.readUInt32BE(constants.NSPACLSD);\n    sAtts.tdu = packet.buf.readUInt32BE(constants.NSPACLTD);\n    sAtts.largeSDU = true;\n  }\n\n  /* Accept flags */\n  this.flag0 = packet.buf.readUInt8(constants.NSPACFL0);\n  this.flag1 = packet.buf.readUInt8(constants.NSPACFL1);\n\n  /* UUID - CDB Instance ID */\n  if (sAtts.version >= constants.TNS_VERSION_MIN_UUID) {\n    packet.dbUUID = packet.buf.subarray(constants.TNS_UUID_OFFSET,\n      constants.TNS_UUID_OFFSET + 16);\n    packet.dbUUID = packet.dbUUID.toString('base64');\n  }\n}\n\n/**\n * Refuse Packet\n * @param {*} packet NS packet\n */\nfunction RefusePacket(packet) {\n  this.buf = packet.buf;\n  this.len = packet.buf.length;\n  this.userReason = packet.buf.readUInt8(constants.NSPRFURS);\n  this.systemReason = packet.buf.readUInt8(constants.NSPRFURS);\n  this.dataLen = packet.buf.readUInt16BE(constants.NSPRFLEN);\n  this.dataOff = constants.NSPRFDAT;\n\n  if (this.len > this.dataOff) {\n    this.dataBuf = this.buf.toString('ascii', this.dataOff, this.len);\n    this.overflow = false;\n  } else {\n    this.overflow = true;\n  }\n}\n\n/**\n * Redirect Packet (NSPTRD)\n * @param {*} packet NS packet\n */\nfunction RedirectPacket(packet) {\n  this.buf = packet.buf;\n  this.len = packet.buf.length;\n  this.flags = packet.flags;\n  this.dataLen = packet.buf.readUInt16BE(constants.NSPRDLEN);\n  this.dataOff = constants.NSPRDDAT;\n\n  if (this.len > this.dataOff) {\n    this.dataBuf = this.buf.subarray(this.dataOff, this.len);\n    this.overflow = false;\n  } else {\n    this.overflow = true;\n  }\n}\n\n/**\n * Marker Packet (NSPTMK)\n * @param {int} isLargeSDU Large SDU\n */\nfunction MarkerPacket(isLargeSDU) {\n  this.len = constants.NSPMKDAT + 1; /* Packet length */\n  this.buf = Buffer.allocUnsafe(constants.NSPMKDAT + 1); /* Packet Buffer */\n\n  if (isLargeSDU) {\n    this.buf.writeUInt32BE(this.len, constants.NSPHDLEN);\n  } else {\n    this.buf.writeUInt16BE(this.len, constants.NSPHDLEN);\n  }\n  this.buf.writeUInt8(0, constants.NSPHDFLGS);\n  this.buf.writeUInt8(constants.NSPTMK, constants.NSPHDTYP);\n\n  /**\n   * Prepare Marker packet for write\n   * @param {Uint8} type of Marker\n   * @param {Uint8} data Marker byte\n   */\n  this.prepare = function(type, data) {\n    this.buf.writeUInt8(type, constants.NSPMKTYP);\n    this.buf.writeUInt8(data, constants.NSPMKDAT);\n  };\n\n  /**\n   * Marker Packet receive\n   * @param {Packet} packet NS packet\n   * @param {NetworkSession} nsi Network Session\n   */\n  this.fromPacket = function(packet, nsi) {\n    this.type = packet.buf.readUInt8(constants.NSPMKTYP);\n\n    switch (this.type) {\n      case constants.NSPMKTD0:\n        nsi.isBreak = true;\n        break;\n      case constants.NSPMKTD1:\n        this.data = packet.buf.readUInt8(constants.NSPMKDAT);\n        nsi.isBreak = true;\n        if (this.data == constants.NIQRMARK) {\n          nsi.isReset = true;\n          nsi.isBreak = true;\n        }\n        break;\n      default:\n        errors.throwErr(errors.ERR_INVALID_PACKET);\n    }\n  };\n}\n\n/**\n * Control Packet NSPTCTL\n */\n\nfunction ControlPacket() {\n  /**\n   * Clear(reset) the packet\n   */\n  this.clear = function() {\n    this.errno = 0;\n    this.notif = null;\n    this.notifLen = 0;\n    this.cmd = 0;\n  };\n\n  /**\n   * Control Packet receive\n   * @param {*} packet NS packet\n   */\n  this.fromPacket = function(packet) {\n    const NSECMANSHUT = 12572; // CMAN SHUTDOWN\n    const NSESENDMESG = 12573; // SEND MESSAGE\n    const ORA_ERROR_EMFI_NUMBER = 22; //ORA -error\n    let emfi;\n    let err1;\n    let err2;\n\n    this.cmd = packet.buf.readUInt16BE(constants.NSPCTLCMD);\n    switch (this.cmd) {\n      case constants.NSPCTL_SERR:\n        emfi = packet.buf.readUInt32BE(constants.NSPCTLDAT);\n        err1 = packet.buf.readUInt32BE(constants.NSPCTLDAT + 4);\n        err2 = packet.buf.readUInt32BE(constants.NSPCTLDAT + 8);\n\n        if (err1 == NSECMANSHUT) {\n          this.errno = err1;\n        } else if (err1 == NSESENDMESG) {\n          this.errno = err1;\n          this.notifLen = err2;\n          this.notif = Buffer.allocUnsafe(err2 + 1).fill(0);\n          this.buf.copy(this.notif, 0, constants.NSPCTLDAT + 12, constants.NSPCTLDAT + 12 + err2);\n        } else {\n          this.errno = err1;\n          if (emfi == ORA_ERROR_EMFI_NUMBER) {\n            errors.throwErr(errors.ERR_CONNECTION_INBAND, \"ORA\" + \"-\" + err1);\n          } else {\n            errors.throwErr(errors.ERR_CONNECTION_INBAND, \"TNS\" + \"-\" + err1);\n          }\n        }\n        break;\n      default:\n        errors.throwErr(errors.ERR_INVALID_PACKET);\n    }\n  };\n}\n\nmodule.exports = {\n  ConnectPacket,\n  DataPacket,\n  AcceptPacket,\n  RefusePacket,\n  RedirectPacket,\n  MarkerPacket,\n  ControlPacket\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}