{"ast":null,"code":"// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\nconst constants = require(\"./constants.js\");\nconst errors = require(\"../../errors.js\");\nconst settings = require(\"../../settings.js\");\nconst types = require(\"../../types.js\");\n\n/**\n * Base buffer class used for managing buffered data without unnecessary\n * copying.\n */\nclass BaseBuffer {\n  //---------------------------------------------------------------------------\n  // constructor()\n  //\n  // The initializer is either an integer specifying the size of the buffer, or\n  // an existing Buffer, which is used directly.\n  //---------------------------------------------------------------------------\n  constructor(initializer) {\n    if (typeof initializer === 'number') {\n      this.buf = Buffer.alloc(initializer);\n      this.size = 0;\n      this.maxSize = initializer;\n    } else if (initializer) {\n      this.buf = initializer;\n      this.size = this.maxSize = initializer.length;\n    }\n    this.pos = 0;\n  }\n\n  //---------------------------------------------------------------------------\n  // _grow()\n  //\n  // Called when the buffer needs to grow. The base function simply raises an\n  // error.\n  //---------------------------------------------------------------------------\n  _grow(numBytes) {\n    errors.throwErr(errors.ERR_BUFFER_LENGTH_INSUFFICIENT, this.numBytesLeft(), numBytes);\n  }\n\n  //---------------------------------------------------------------------------\n  // _readBytesWithLength()\n  //\n  // Helper function that processes the number of bytes (if needed) and then\n  // acquires the specified number of bytes from the buffer. The base function\n  // simply uses the length as given.\n  //---------------------------------------------------------------------------\n  _readBytesWithLength(numBytes) {\n    return this.readBytes(numBytes);\n  }\n\n  //---------------------------------------------------------------------------\n  // _readInteger()\n  //\n  // Read an integer from the buffer of the specified maximum size and returns\n  // it. The signed flag indicates whether the value is allowed to be signed or\n  // not and the skip flag indicates whether the data should simply be skipped.\n  //---------------------------------------------------------------------------\n  _readInteger(maxSize, signed, skip) {\n    let isNegative = false;\n    let size = this.readUInt8();\n    if (size === 0) {\n      return 0;\n    } else if (size & 0x80) {\n      if (!signed) {\n        errors.throwErr(errors.ERR_UNEXPECTED_NEGATIVE_INTEGER, this.pos, this.packetNum);\n      }\n      isNegative = true;\n      size = size & 0x7f;\n    }\n    if (size > maxSize) {\n      errors.throwErr(errors.ERR_INTEGER_TOO_LARGE, size, maxSize, this.pos, this.packetNum);\n    }\n    if (skip) {\n      this.skipBytes(size);\n    } else {\n      const buf = this.readBytes(size);\n      const value = buf.readUIntBE(0, size);\n      return isNegative ? -value : value;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // numBytesLeft()\n  //\n  // Returns the number of bytes that are remaining in the buffer.\n  //---------------------------------------------------------------------------\n  numBytesLeft() {\n    return this.size - this.pos;\n  }\n\n  //---------------------------------------------------------------------------\n  // parseBinaryDouble()\n  //\n  // Parses a binary double from the supplied buffer and returns a Number.\n  // It is assumed at this point that the size of the buffer is 8 bytes. A copy\n  // is made of the buffer in order to ensure that the original buffer is not\n  // modified. If it is and data spans multiple packets, incorrect data may be\n  // returned!\n  //---------------------------------------------------------------------------\n  parseBinaryDouble(buf) {\n    buf = Buffer.from(buf);\n    if (buf[0] & 0x80) {\n      buf[0] &= 0x7f;\n    } else {\n      // complement the bits for a negative number\n      buf[0] ^= 0xff;\n      buf[1] ^= 0xff;\n      buf[2] ^= 0xff;\n      buf[3] ^= 0xff;\n      buf[4] ^= 0xff;\n      buf[5] ^= 0xff;\n      buf[6] ^= 0xff;\n      buf[7] ^= 0xff;\n    }\n    return buf.readDoubleBE();\n  }\n\n  //---------------------------------------------------------------------------\n  // parseBinaryFloat()\n  //\n  // Parses a binary float from the supplied buffer and returns a Number.  It\n  // is assumed at this point that the size of the buffer is 4 bytes. A copy is\n  // made of the buffer in order to ensure that the original buffer is not\n  // modified. If it is and data spans multiple packets, incorrect data may be\n  // returned!\n  //---------------------------------------------------------------------------\n  parseBinaryFloat(buf) {\n    buf = Buffer.from(buf);\n    if (buf[0] & 0x80) {\n      buf[0] &= 0x7f;\n    } else {\n      // complement the bits for a negative number\n      buf[0] ^= 0xff;\n      buf[1] ^= 0xff;\n      buf[2] ^= 0xff;\n      buf[3] ^= 0xff;\n    }\n    return buf.readFloatBE();\n  }\n\n  //---------------------------------------------------------------------------\n  // parseOracleDate()\n  //\n  // Parses an Oracle date from the supplied buffer and returns a Date. It is\n  // assumed at this point that the size of the buffer is either 7 bytes (date\n  // or compressed timestamp), 11 bytes (timestamp) or 13 bytes (timestamp with\n  // time zone). Time zone information is discarded because Node.js uses UTC\n  // timestamps and the server returns the data in that format, too. The Date\n  // type in Node.js doesn't support time zone information.\n  //---------------------------------------------------------------------------\n  parseOracleDate(buf, useLocalTime = true) {\n    let fseconds = 0;\n    if (buf.length >= 11) {\n      fseconds = Math.floor(buf.readUInt32BE(7) / (1000 * 1000));\n    }\n    const year = (buf[0] - 100) * 100 + buf[1] - 100;\n    return settings._makeDate(useLocalTime, year, buf[2], buf[3], buf[4] - 1, buf[5] - 1, buf[6] - 1, fseconds, 0);\n  }\n\n  //---------------------------------------------------------------------------\n  // parseOracleNumber()\n  //\n  // Parses an Oracle number from the supplied buffer and returns a Number. It\n  // is assumed at this point that the buffer only contains the encoded numeric\n  // data.\n  //---------------------------------------------------------------------------\n  parseOracleNumber(buf) {\n    // the first byte is the exponent; positive numbers have the highest\n    // order bit set, whereas negative numbers have the highest order bit\n    // cleared and the bits inverted\n    let exponent = buf[0];\n    const isPositive = Boolean(exponent & 0x80);\n    if (!isPositive) {\n      exponent = exponent ^ 0xFF;\n    }\n    exponent -= 193;\n    let decimalPointIndex = exponent * 2 + 2;\n\n    // a mantissa length of 0 implies a value of 0 (if positive) or a value\n    // of -1e126 (if negative)\n    if (buf.length === 1) {\n      if (isPositive) {\n        return \"0\";\n      }\n      return \"-1e126\";\n    }\n\n    // check for the trailing 102 byte for negative numbers and, if present,\n    // reduce the number of mantissa digits\n    let numBytes = buf.length;\n    if (!isPositive && buf[buf.length - 1] === 102) {\n      numBytes -= 1;\n    }\n\n    // process the mantissa bytes which are the remaining bytes; each\n    // mantissa byte is a base-100 digit\n    let base100Digit;\n    const digits = [];\n    for (let i = 1; i < numBytes; i++) {\n      // positive numbers have 1 added to them; negative numbers are\n      // subtracted from the value 101\n      if (isPositive) {\n        base100Digit = buf[i] - 1;\n      } else {\n        base100Digit = 101 - buf[i];\n      }\n\n      // process the first digit; leading zeroes are ignored\n      let digit = Math.floor(base100Digit / 10);\n      if (digit === 0 && i === 1) {\n        decimalPointIndex -= 1;\n      } else if (digit === 10) {\n        digits.push(\"1\");\n        digits.push(\"0\");\n        decimalPointIndex += 1;\n      } else if (digit !== 0 || i > 1) {\n        digits.push(digit.toString());\n      }\n\n      // process the second digit; trailing zeroes are ignored\n      digit = base100Digit % 10;\n      if (digit !== 0 || i < numBytes - 1) {\n        digits.push(digit.toString());\n      }\n    }\n\n    // create string of digits for transformation to JS value\n    const chars = [];\n\n    // if negative, include the sign\n    if (!isPositive) {\n      chars.push(\"-\");\n    }\n\n    // if the decimal point index is 0 or less, add the decimal point and\n    // any leading zeroes that are needed\n    if (decimalPointIndex <= 0) {\n      chars.push(\".\");\n      if (decimalPointIndex < 0) chars.push(\"0\".repeat(-decimalPointIndex));\n    }\n\n    // add each of the digits\n    for (let i = 0; i < digits.length; i++) {\n      if (i > 0 && i === decimalPointIndex) {\n        chars.push(\".\");\n      }\n      chars.push(digits[i]);\n    }\n\n    // if the decimal point index exceeds the number of digits, add any\n    // trailing zeroes that are needed\n    if (decimalPointIndex > digits.length) {\n      for (let i = digits.length; i < decimalPointIndex; i++) {\n        chars.push(\"0\");\n      }\n    }\n\n    // convert result to a Number\n    return chars.join(\"\");\n  }\n\n  //---------------------------------------------------------------------------\n  // readBinaryDouble()\n  //\n  // Reads a binary double value from the buffer and returns a Number or a\n  // String, depending on the desired type.\n  //---------------------------------------------------------------------------\n  readBinaryDouble() {\n    const buf = this.readBytesWithLength();\n    if (!buf) {\n      return null;\n    }\n    return this.parseBinaryDouble(buf);\n  }\n\n  //---------------------------------------------------------------------------\n  // readBinaryFloat()\n  //\n  // Reads a binary float value from the buffer and returns a Number or a\n  // String, depending on the desired type.\n  //---------------------------------------------------------------------------\n  readBinaryFloat() {\n    const buf = this.readBytesWithLength();\n    if (!buf) {\n      return null;\n    }\n    return this.parseBinaryFloat(buf);\n  }\n\n  //---------------------------------------------------------------------------\n  // readBool()\n  //\n  // Reads a boolean value from the buffer and returns a Boolean.\n  //---------------------------------------------------------------------------\n  readBool() {\n    const buf = this.readBytesWithLength();\n    if (!buf) {\n      return null;\n    }\n    return buf[buf.length - 1] === 1;\n  }\n\n  //---------------------------------------------------------------------------\n  // readBytes()\n  //\n  // Returns a Buffer containing the specified number of bytes. If an\n  // insufficient number of bytes are available an error is thrown.\n  //---------------------------------------------------------------------------\n  readBytes(numBytes) {\n    const numBytesLeft = this.numBytesLeft();\n    if (numBytes > numBytesLeft) {\n      errors.throwErr(errors.ERR_UNEXPECTED_END_OF_DATA, numBytes, numBytesLeft);\n    }\n    const buf = this.buf.subarray(this.pos, this.pos + numBytes);\n    this.pos += numBytes;\n    return buf;\n  }\n\n  //---------------------------------------------------------------------------\n  // readBytesWithLength()\n  //\n  // Reads the length from the buffer and then returns a Buffer containing the\n  // specified number of bytes. If the length is 0 or the special null length\n  // indicator value, null is returned instead.\n  //---------------------------------------------------------------------------\n  readBytesWithLength() {\n    const numBytes = this.readUInt8();\n    if (numBytes === 0 || numBytes === constants.TNS_NULL_LENGTH_INDICATOR) return null;\n    return this._readBytesWithLength(numBytes);\n  }\n\n  //---------------------------------------------------------------------------\n  // readDbObject()\n  //\n  // Reads a database object from the buffer and returns the implementation\n  // object (or null, if the object is atomically null).\n  //---------------------------------------------------------------------------\n  readDbObject() {\n    const obj = {};\n    let numBytes = this.readUB4();\n    if (numBytes > 0) obj.toid = Buffer.from(this.readBytesWithLength());\n    numBytes = this.readUB4();\n    if (numBytes > 0) obj.oid = Buffer.from(this.readBytesWithLength());\n    numBytes = this.readUB4();\n    if (numBytes > 0) obj.snapshot = Buffer.from(this.readBytesWithLength());\n    this.skipUB2(); // version\n    numBytes = this.readUB4();\n    this.skipUB2(); // flags\n    if (numBytes > 0) obj.packedData = Buffer.from(this.readBytesWithLength());\n    return obj;\n  }\n\n  //---------------------------------------------------------------------------\n  // readInt8()\n  //\n  // Reads a signed 8-bit integer from the buffer.\n  //---------------------------------------------------------------------------\n  readInt8() {\n    const buf = this.readBytes(1);\n    return buf.readInt8();\n  }\n\n  //---------------------------------------------------------------------------\n  // readOracleDate()\n  //\n  // Reads an Oracle date from the buffer and returns a Date or a String,\n  // depending on the desired type.\n  //---------------------------------------------------------------------------\n  readOracleDate(useLocalTime) {\n    const buf = this.readBytesWithLength();\n    if (!buf) {\n      return null;\n    }\n    return this.parseOracleDate(buf, useLocalTime);\n  }\n\n  //---------------------------------------------------------------------------\n  // readOracleNumber()\n  //\n  // Reads an Oracle number from the buffer and returns a Number or a String,\n  // depending on the desired type.\n  //---------------------------------------------------------------------------\n  readOracleNumber() {\n    const buf = this.readBytesWithLength();\n    if (!buf) {\n      return null;\n    }\n    return this.parseOracleNumber(buf);\n  }\n\n  //---------------------------------------------------------------------------\n  // readSB2()\n  //\n  // Reads a signed, variable length integer of up to 2 bytes in length.\n  //---------------------------------------------------------------------------\n  readSB2() {\n    return this._readInteger(2, true, false);\n  }\n\n  //---------------------------------------------------------------------------\n  // readSB4()\n  //\n  // Reads a signed, variable length integer of up to 4 bytes in length.\n  //---------------------------------------------------------------------------\n  readSB4() {\n    return this._readInteger(4, true, false);\n  }\n\n  //---------------------------------------------------------------------------\n  // readSB8()\n  //\n  // Reads a signed, variable length integer of up to 8 bytes in length.\n  //---------------------------------------------------------------------------\n  readSB8() {\n    return this._readInteger(8, true, false);\n  }\n\n  //---------------------------------------------------------------------------\n  // readStr()\n  //\n  // Reads a string from the buffer in the specified character set form.\n  //---------------------------------------------------------------------------\n  readStr(csfrm) {\n    const buf = this.readBytesWithLength();\n    if (!buf) {\n      return null;\n    }\n    if (csfrm === constants.CSFRM_IMPLICIT) return buf.toString();\n\n    // need a copy of the buffer since swap16() changes the buffer in place and\n    // it is possible that the buffer may need to be rescanned (for the case\n    // where insufficient packets are available during the initial scan)\n    return Buffer.from(buf).swap16().toString('utf16le');\n  }\n\n  //---------------------------------------------------------------------------\n  // readUB2()\n  //\n  // Reads an unsigned, variable length integer of up to 2 bytes in length.\n  //---------------------------------------------------------------------------\n  readUB2() {\n    return this._readInteger(2, false, false);\n  }\n\n  //---------------------------------------------------------------------------\n  // readUB4()\n  //\n  // Reads an unsigned, variable length integer of up to 4 bytes in length.\n  //---------------------------------------------------------------------------\n  readUB4() {\n    return this._readInteger(4, false, false);\n  }\n\n  //---------------------------------------------------------------------------\n  // readUB8()\n  //\n  // Reads an unsigned, variable length integer of up to 8 bytes in length.\n  //---------------------------------------------------------------------------\n  readUB8() {\n    return this._readInteger(8, false, false);\n  }\n\n  //---------------------------------------------------------------------------\n  // readUInt8()\n  //\n  // Reads an unsigned 8-bit integer from the buffer.\n  //---------------------------------------------------------------------------\n  readUInt8() {\n    const buf = this.readBytes(1);\n    return buf[0];\n  }\n\n  //---------------------------------------------------------------------------\n  // readUInt16BE()\n  //\n  // Reads an unsigned 16-bit integer from the buffer in big endian order.\n  //---------------------------------------------------------------------------\n  readUInt16BE() {\n    const buf = this.readBytes(2);\n    return buf.readUInt16BE();\n  }\n\n  //---------------------------------------------------------------------------\n  // readUInt16LE()\n  //\n  // Reads an unsigned 16-bit integer from the buffer in little endian order.\n  //---------------------------------------------------------------------------\n  readUInt16LE() {\n    const buf = this.readBytes(2);\n    return buf.readUInt16LE();\n  }\n\n  //---------------------------------------------------------------------------\n  // readUInt32BE()\n  //\n  // Reads an unsigned 32-bit integer from the buffer in big endian order.\n  //---------------------------------------------------------------------------\n  readUInt32BE() {\n    const buf = this.readBytes(4);\n    return buf.readUInt32BE();\n  }\n\n  //---------------------------------------------------------------------------\n  // reserveBytes()\n  //\n  // Reserves the specified number of bytes in the buffer. If not enough bytes\n  // remain in the buffer, the buffer is grown.\n  //---------------------------------------------------------------------------\n  reserveBytes(numBytes) {\n    if (numBytes > this.numBytesLeft()) {\n      this._grow(this.pos + numBytes);\n    }\n    const pos = this.pos;\n    this.pos += numBytes;\n    return pos;\n  }\n\n  //---------------------------------------------------------------------------\n  // skipBytes()\n  //\n  // Skips the specified number of bytes in the buffer.\n  //---------------------------------------------------------------------------\n  skipBytes(numBytes) {\n    if (numBytes > this.numBytesLeft()) errors.throwErr(errors.ERR_UNEXPECTED_END_OF_DATA);\n    this.pos += numBytes;\n  }\n\n  //---------------------------------------------------------------------------\n  // skipSB4()\n  //\n  // Skips a signed, variable length integer of up to 4 bytes in length.\n  //---------------------------------------------------------------------------\n  skipSB4() {\n    return this._readInteger(4, true, true);\n  }\n\n  //---------------------------------------------------------------------------\n  // skipUB1()\n  //\n  // Skips a single byte integer in the buffer.\n  //---------------------------------------------------------------------------\n  skipUB1() {\n    this.skipBytes(1);\n  }\n\n  //---------------------------------------------------------------------------\n  // skipUB2()\n  //\n  // Skips an unsigned, variable length integer of up to 2 bytes in length.\n  //---------------------------------------------------------------------------\n  skipUB2() {\n    return this._readInteger(2, false, true);\n  }\n\n  //---------------------------------------------------------------------------\n  // skipUB4()\n  //\n  // Skips an unsigned, variable length integer of up to 4 bytes in length.\n  //---------------------------------------------------------------------------\n  skipUB4() {\n    return this._readInteger(4, false, true);\n  }\n\n  //---------------------------------------------------------------------------\n  // skipUB8()\n  //\n  // Skips an unsigned, variable length integer of up to 8 bytes in length.\n  //---------------------------------------------------------------------------\n  skipUB8() {\n    return this._readInteger(8, false, true);\n  }\n\n  //---------------------------------------------------------------------------\n  // writeBinaryDouble()\n  //\n  // Writes the number in binary double format to the buffer.\n  //---------------------------------------------------------------------------\n  writeBinaryDouble(n) {\n    this.writeUInt8(8);\n    const pos = this.reserveBytes(8);\n    this.buf.writeDoubleBE(n, pos);\n    if ((this.buf[pos] & 0x80) === 0) {\n      this.buf[pos] |= 0x80;\n    } else {\n      // We complement the bits for a negative number\n      this.buf[pos] ^= 0xff;\n      this.buf[pos + 1] ^= 0xff;\n      this.buf[pos + 2] ^= 0xff;\n      this.buf[pos + 3] ^= 0xff;\n      this.buf[pos + 4] ^= 0xff;\n      this.buf[pos + 5] ^= 0xff;\n      this.buf[pos + 6] ^= 0xff;\n      this.buf[pos + 7] ^= 0xff;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // writeBinaryFloat()\n  //\n  // Writes the number in binary float format to the buffer.\n  //---------------------------------------------------------------------------\n  writeBinaryFloat(n) {\n    this.writeUInt8(4);\n    const pos = this.reserveBytes(4);\n    this.buf.writeFloatBE(n, pos);\n    if ((this.buf[pos] & 0x80) === 0) {\n      this.buf[pos] |= 0x80;\n    } else {\n      // We complement the bits for a negative number\n      this.buf[pos] ^= 0xff;\n      this.buf[pos + 1] ^= 0xff;\n      this.buf[pos + 2] ^= 0xff;\n      this.buf[pos + 3] ^= 0xff;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // writeBytes()\n  //\n  // Writes the bytes in the supplied buffer to the buffer.\n  //---------------------------------------------------------------------------\n  writeBytes(value) {\n    let start = 0;\n    let valueLen = value.length;\n    while (valueLen > 0) {\n      const bytesLeft = this.numBytesLeft();\n      if (bytesLeft === 0) {\n        this._grow(this.pos + valueLen);\n      }\n      const bytesToWrite = Math.min(bytesLeft, valueLen);\n      value.copy(this.buf, this.pos, start, start + bytesToWrite);\n      this.pos += bytesToWrite;\n      start += bytesToWrite;\n      valueLen -= bytesToWrite;\n    }\n  }\n\n  // _writeRawBytesAndLength()\n  //\n  // Writes the length in the format required before\n  // writing the bytes.\n  //---------------------------------------------------------------------------\n  _writeRawBytesAndLength(value, numBytes) {\n    if (numBytes <= constants.TNS_MAX_SHORT_LENGTH) {\n      this.writeUInt8(numBytes);\n      if (numBytes > 0) {\n        this.writeBytes(value);\n      }\n    } else {\n      let start = 0;\n      this.writeUInt8(constants.TNS_LONG_LENGTH_INDICATOR);\n      while (numBytes > 0) {\n        const chunkLen = Math.min(numBytes, constants.BUFFER_CHUNK_SIZE);\n        this.writeUB4(chunkLen);\n        this.writeBytes(value.subarray(start, start + chunkLen));\n        numBytes -= chunkLen;\n        start += chunkLen;\n      }\n      this.writeUB4(0);\n    }\n  }\n  //---------------------------------------------------------------------------\n  // writeBytesWithLength()\n  //\n  // Writes the bytes in the supplied buffer to the buffer, but first writes\n  // the length. If the length exceeds a fixed value, the value is written in\n  // chunks instead.\n  //---------------------------------------------------------------------------\n  writeBytesWithLength(value) {\n    const numBytes = value.length;\n    this._writeRawBytesAndLength(value, numBytes);\n  }\n\n  //---------------------------------------------------------------------------\n  // writeDbObject()\n  //\n  // Writes a database object to the buffer.\n  //---------------------------------------------------------------------------\n  writeDbObject(obj) {\n    this.writeUB4(obj.toid.length);\n    this.writeBytesWithLength(obj.toid);\n    if (obj.oid) {\n      this.writeUB4(obj.oid.length);\n      this.writeBytesWithLength(obj.oid);\n    } else {\n      this.writeUB4(0);\n    }\n    this.writeUB4(0); // snapshot\n    this.writeUB4(0); // version\n    const packedData = obj._getPackedData();\n    this.writeUB4(packedData.length);\n    this.writeUB4(obj.flags);\n    this.writeBytesWithLength(packedData);\n  }\n\n  //---------------------------------------------------------------------------\n  // writeOracleDate()\n  //\n  // Writes the date to the buffer using the given Oracle type. Note that if a\n  // timestamp with zero milliseconds is written, the type is automatically\n  // changed to DB_TYPE_DATE (except for DB_TYPE_TIMESTAMP_TZ which requires\n  // the full amount to be written).\n  //---------------------------------------------------------------------------\n  writeOracleDate(date, type, writeLength = true) {\n    let fsec;\n    let length = type._bufferSizeFactor;\n    if (length > 7) {\n      fsec = date.getUTCMilliseconds() * 1000 * 1000;\n      if (fsec === 0 && length <= 11) length = 7;\n    }\n    if (writeLength) {\n      this.writeUInt8(length);\n    }\n    const pos = this.reserveBytes(length);\n    if (type === types.DB_TYPE_DATE || type == types.DB_TYPE_TIMESTAMP) {\n      const year = date.getFullYear();\n      this.buf[pos] = Math.trunc(year / 100) + 100;\n      this.buf[pos + 1] = year % 100 + 100;\n      this.buf[pos + 2] = date.getMonth() + 1;\n      this.buf[pos + 3] = date.getDate();\n      this.buf[pos + 4] = date.getHours() + 1;\n      this.buf[pos + 5] = date.getMinutes() + 1;\n      this.buf[pos + 6] = date.getSeconds() + 1;\n    } else {\n      const year = date.getUTCFullYear();\n      this.buf[pos] = Math.trunc(year / 100) + 100;\n      this.buf[pos + 1] = year % 100 + 100;\n      this.buf[pos + 2] = date.getUTCMonth() + 1;\n      this.buf[pos + 3] = date.getUTCDate();\n      this.buf[pos + 4] = date.getUTCHours() + 1;\n      this.buf[pos + 5] = date.getUTCMinutes() + 1;\n      this.buf[pos + 6] = date.getUTCSeconds() + 1;\n    }\n    if (length > 7) {\n      this.buf.writeInt32BE(fsec, pos + 7);\n      if (length > 11) {\n        this.buf[pos + 11] = constants.TZ_HOUR_OFFSET;\n        this.buf[pos + 12] = constants.TZ_MINUTE_OFFSET;\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // writeOracleNumber()\n  //\n  // Writes the number (in string form) in Oracle Number format to the buffer.\n  //---------------------------------------------------------------------------\n  writeOracleNumber(value) {\n    // determine if number is negative\n    let isNegative = false;\n    if (value[0] === '-') {\n      isNegative = true;\n      value = value.substring(1);\n    }\n\n    // parse the exponent, if one is present\n    let exponent = 0;\n    const exponentPos = value.indexOf('e');\n    if (exponentPos > 0) {\n      exponent = Number(value.substring(exponentPos + 1));\n      value = value.substring(0, exponentPos);\n    }\n\n    // adjust the exponent and the value if there is a decimal point\n    const decimalPos = value.indexOf('.');\n    if (decimalPos > 0) {\n      exponent -= value.length - decimalPos - 1;\n      value = value.substring(0, decimalPos) + value.substring(decimalPos + 1);\n    }\n\n    // strip any leading zeroes\n    if (value[0] === '0') {\n      value = value.replace(/^0+/, \"\");\n    }\n\n    // strip any trailing zeroes\n    if (value.length > 0 && value[value.length - 1] === '0') {\n      const trimmedValue = value.replace(/0+$/, \"\");\n      exponent += value.length - trimmedValue.length;\n      value = trimmedValue;\n    }\n\n    // throw exception if number cannot be represented as an Oracle Number\n    if (value.length > constants.NUMBER_MAX_DIGITS || exponent > 126 || exponent < -129) {\n      errors.throwErr(errors.ERR_ORACLE_NUMBER_NO_REPR);\n    }\n\n    // if the exponent is odd, append a zero\n    if (exponent > 0 && exponent % 2 === 1 || exponent < 0 && exponent % 2 === -1) {\n      exponent--;\n      value += \"0\";\n    }\n\n    // add a leading zero if the number of digits is odd\n    if (value.length % 2 === 1) {\n      value = \"0\" + value;\n    }\n\n    // write the encoded data to the wire\n    const appendSentinel = isNegative && value.length < constants.NUMBER_MAX_DIGITS;\n    const numPairs = value.length / 2;\n    let exponentOnWire = (exponent + value.length) / 2 + 192;\n    if (isNegative) {\n      exponentOnWire = exponentOnWire ^ 0xFF;\n    } else if (value.length === 0 && exponent === 0) {\n      exponentOnWire = 128;\n    }\n    let pos = this.reserveBytes(numPairs + 2 + appendSentinel);\n    this.buf[pos++] = numPairs + 1 + appendSentinel;\n    this.buf[pos++] = exponentOnWire;\n    for (let i = 0; i < value.length; i += 2) {\n      const base100Digit = Number(value.substring(i, i + 2));\n      if (isNegative) {\n        this.buf[pos++] = 101 - base100Digit;\n      } else {\n        this.buf[pos++] = base100Digit + 1;\n      }\n    }\n    if (appendSentinel) {\n      this.buf[pos] = 102;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // writeQLocator()\n  //\n  // Writes a QLocator. QLocators are always 40 bytes in length.\n  //---------------------------------------------------------------------------\n  writeQLocator(numBytes) {\n    this.writeUB4(40); // QLocator length\n    this.writeUInt8(40); // repeated length\n    this.writeUInt16BE(38); // internal length\n    this.writeUInt16BE(constants.TNS_LOB_QLOCATOR_VERSION);\n    this.writeUInt8(constants.TNS_LOB_LOC_FLAGS_VALUE_BASED | constants.TNS_LOB_LOC_FLAGS_BLOB | constants.TNS_LOB_LOC_FLAGS_ABSTRACT);\n    this.writeUInt8(constants.TNS_LOB_LOC_FLAGS_INIT);\n    this.writeUInt16BE(0); // additional flags\n    this.writeUInt16BE(1); // byt1\n    this.writeUInt64BE(numBytes);\n    this.writeUInt16BE(0); // unused\n    this.writeUInt16BE(0); // csid\n    this.writeUInt16BE(0); // unused\n    this.writeUInt64BE(0); // unused\n    this.writeUInt64BE(0); // unused\n  }\n\n  //---------------------------------------------------------------------------\n  // writeStr()\n  //\n  // Writes the string to the buffer.\n  //---------------------------------------------------------------------------\n  writeStr(s) {\n    this.writeBytes(Buffer.from(s));\n  }\n\n  //---------------------------------------------------------------------------\n  // writeInt32BE()\n  //\n  // Writes a signed 32-bit integer to the buffer in big endian order.\n  //---------------------------------------------------------------------------\n  writeInt32BE(n) {\n    const pos = this.reserveBytes(4);\n    this.buf.writeInt32BE(n, pos);\n  }\n\n  //---------------------------------------------------------------------------\n  // writeUB4()\n  //\n  // Writes an unsigned integer (up to 4 bytes in length) in variable length\n  // format to the buffer.\n  //---------------------------------------------------------------------------\n  writeUB4(value) {\n    if (value === 0) {\n      this.writeUInt8(0);\n    } else if (value <= 0xff) {\n      this.writeUInt8(1);\n      this.writeUInt8(value);\n    } else if (value <= 0xffff) {\n      this.writeUInt8(2);\n      this.writeUInt16BE(value);\n    } else {\n      this.writeUInt8(4);\n      this.writeUInt32BE(value);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // writeUB2()\n  //\n  // Writes an unsigned integer (up to 2 bytes in length) in variable length\n  // format to the buffer.\n  //---------------------------------------------------------------------------\n  writeUB2(value) {\n    if (value === 0) {\n      this.writeUInt8(0);\n    } else if (value <= 0xff) {\n      this.writeUInt8(1);\n      this.writeUInt8(value);\n    } else {\n      this.writeUInt8(2);\n      this.writeUInt16BE(value);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // writeUB8()\n  //\n  // Writes an unsigned integer (up to 8 bytes in length) in variable length\n  // format to the buffer.\n  //---------------------------------------------------------------------------\n  writeUB8(value) {\n    if (value === 0) {\n      this.writeUInt8(0);\n    } else if (value <= 0xff) {\n      this.writeUInt8(1);\n      this.writeUInt8(value);\n    } else if (value <= 0xffff) {\n      this.writeUInt8(2);\n      this.writeUInt16BE(value);\n    } else if (value <= 0xffffffff) {\n      this.writeUInt8(4);\n      this.writeUInt32BE(value);\n    } else {\n      this.writeUInt8(8);\n      this.writeUInt64BE(value);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // writeUInt8()\n  //\n  // Writes an unsigned 8-bit integer to the buffer.\n  //---------------------------------------------------------------------------\n  writeUInt8(n) {\n    const pos = this.reserveBytes(1);\n    this.buf[pos] = n;\n  }\n\n  //---------------------------------------------------------------------------\n  // writeUInt16BE()\n  //\n  // Writes an unsigned 16-bit integer to the buffer in big endian order.\n  //---------------------------------------------------------------------------\n  writeUInt16BE(n) {\n    const pos = this.reserveBytes(2);\n    this.buf.writeUInt16BE(n, pos);\n  }\n\n  //---------------------------------------------------------------------------\n  // writeUInt32BE()\n  //\n  // Writes an unsigned 32-bit integer to the buffer in big endian order.\n  //---------------------------------------------------------------------------\n  writeUInt32BE(n) {\n    const pos = this.reserveBytes(4);\n    this.buf.writeUInt32BE(n, pos);\n  }\n\n  //---------------------------------------------------------------------------\n  // writeUInt64BE()\n  //\n  // Writes an unsigned 64-bit integer to the buffer in big endian order. Since\n  // Node.js doesn't support anything above 32-bits without using BigInt, the\n  // higher order bits are simply written as 0.\n  //---------------------------------------------------------------------------\n  writeUInt64BE(n) {\n    const pos = this.reserveBytes(8);\n    this.buf.writeUInt32BE(0, pos);\n    this.buf.writeUInt32BE(n, pos + 4);\n  }\n\n  //---------------------------------------------------------------------------\n  // writeUInt16LE()\n  //\n  // Writes an unsigned 16-bit integer to the buffer in little endian order.\n  //---------------------------------------------------------------------------\n  writeUInt16LE(n) {\n    const pos = this.reserveBytes(2);\n    this.buf.writeUInt16LE(n, pos);\n  }\n}\nclass GrowableBuffer extends BaseBuffer {\n  //---------------------------------------------------------------------------\n  // constructor()\n  //\n  // Initializes the buffer with an initial fixed chunk size.\n  //---------------------------------------------------------------------------\n  constructor(initializer) {\n    if (initializer) {\n      super(initializer);\n    } else {\n      super(constants.BUFFER_CHUNK_SIZE);\n      this.size = this.maxSize;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _grow()\n  //\n  // Called when the buffer needs to grow. Ensures that sufficient space is\n  // allocated to include the requested number of bytes, rounded to the nearest\n  // chunk size.\n  //---------------------------------------------------------------------------\n  _grow(numBytes) {\n    const remainder = numBytes % constants.BUFFER_CHUNK_SIZE;\n    if (remainder > 0) {\n      numBytes += constants.BUFFER_CHUNK_SIZE - remainder;\n    }\n    const buf = Buffer.allocUnsafe(numBytes);\n    this.buf.copy(buf);\n    this.buf = buf;\n    this.maxSize = this.size = numBytes;\n  }\n}\nmodule.exports = {\n  BaseBuffer,\n  GrowableBuffer\n};","map":{"version":3,"names":["Buffer","require","constants","errors","settings","types","BaseBuffer","constructor","initializer","buf","alloc","size","maxSize","length","pos","_grow","numBytes","throwErr","ERR_BUFFER_LENGTH_INSUFFICIENT","numBytesLeft","_readBytesWithLength","readBytes","_readInteger","signed","skip","isNegative","readUInt8","ERR_UNEXPECTED_NEGATIVE_INTEGER","packetNum","ERR_INTEGER_TOO_LARGE","skipBytes","value","readUIntBE","parseBinaryDouble","from","readDoubleBE","parseBinaryFloat","readFloatBE","parseOracleDate","useLocalTime","fseconds","Math","floor","readUInt32BE","year","_makeDate","parseOracleNumber","exponent","isPositive","Boolean","decimalPointIndex","base100Digit","digits","i","digit","push","toString","chars","repeat","join","readBinaryDouble","readBytesWithLength","readBinaryFloat","readBool","ERR_UNEXPECTED_END_OF_DATA","subarray","TNS_NULL_LENGTH_INDICATOR","readDbObject","obj","readUB4","toid","oid","snapshot","skipUB2","packedData","readInt8","readOracleDate","readOracleNumber","readSB2","readSB4","readSB8","readStr","csfrm","CSFRM_IMPLICIT","swap16","readUB2","readUB8","readUInt16BE","readUInt16LE","reserveBytes","skipSB4","skipUB1","skipUB4","skipUB8","writeBinaryDouble","n","writeUInt8","writeDoubleBE","writeBinaryFloat","writeFloatBE","writeBytes","start","valueLen","bytesLeft","bytesToWrite","min","copy","_writeRawBytesAndLength","TNS_MAX_SHORT_LENGTH","TNS_LONG_LENGTH_INDICATOR","chunkLen","BUFFER_CHUNK_SIZE","writeUB4","writeBytesWithLength","writeDbObject","_getPackedData","flags","writeOracleDate","date","type","writeLength","fsec","_bufferSizeFactor","getUTCMilliseconds","DB_TYPE_DATE","DB_TYPE_TIMESTAMP","getFullYear","trunc","getMonth","getDate","getHours","getMinutes","getSeconds","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","writeInt32BE","TZ_HOUR_OFFSET","TZ_MINUTE_OFFSET","writeOracleNumber","substring","exponentPos","indexOf","Number","decimalPos","replace","trimmedValue","NUMBER_MAX_DIGITS","ERR_ORACLE_NUMBER_NO_REPR","appendSentinel","numPairs","exponentOnWire","writeQLocator","writeUInt16BE","TNS_LOB_QLOCATOR_VERSION","TNS_LOB_LOC_FLAGS_VALUE_BASED","TNS_LOB_LOC_FLAGS_BLOB","TNS_LOB_LOC_FLAGS_ABSTRACT","TNS_LOB_LOC_FLAGS_INIT","writeUInt64BE","writeStr","s","writeUInt32BE","writeUB2","writeUB8","writeUInt16LE","GrowableBuffer","remainder","allocUnsafe","module","exports"],"sources":["C:/Users/user1/Desktop/finalproject_penpick/node_modules/oracledb/lib/thin/protocol/buffer.js"],"sourcesContent":["// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst { Buffer } = require('buffer');\nconst constants = require(\"./constants.js\");\nconst errors = require(\"../../errors.js\");\nconst settings = require(\"../../settings.js\");\nconst types = require(\"../../types.js\");\n\n/**\n * Base buffer class used for managing buffered data without unnecessary\n * copying.\n */\nclass BaseBuffer {\n\n  //---------------------------------------------------------------------------\n  // constructor()\n  //\n  // The initializer is either an integer specifying the size of the buffer, or\n  // an existing Buffer, which is used directly.\n  //---------------------------------------------------------------------------\n  constructor(initializer) {\n    if (typeof initializer === 'number') {\n      this.buf = Buffer.alloc(initializer);\n      this.size = 0;\n      this.maxSize = initializer;\n    } else if (initializer) {\n      this.buf = initializer;\n      this.size = this.maxSize = initializer.length;\n    }\n    this.pos = 0;\n  }\n\n  //---------------------------------------------------------------------------\n  // _grow()\n  //\n  // Called when the buffer needs to grow. The base function simply raises an\n  // error.\n  //---------------------------------------------------------------------------\n  _grow(numBytes) {\n    errors.throwErr(errors.ERR_BUFFER_LENGTH_INSUFFICIENT, this.numBytesLeft(),\n      numBytes);\n  }\n\n  //---------------------------------------------------------------------------\n  // _readBytesWithLength()\n  //\n  // Helper function that processes the number of bytes (if needed) and then\n  // acquires the specified number of bytes from the buffer. The base function\n  // simply uses the length as given.\n  //---------------------------------------------------------------------------\n  _readBytesWithLength(numBytes) {\n    return this.readBytes(numBytes);\n  }\n\n  //---------------------------------------------------------------------------\n  // _readInteger()\n  //\n  // Read an integer from the buffer of the specified maximum size and returns\n  // it. The signed flag indicates whether the value is allowed to be signed or\n  // not and the skip flag indicates whether the data should simply be skipped.\n  //---------------------------------------------------------------------------\n  _readInteger(maxSize, signed, skip) {\n    let isNegative = false;\n    let size = this.readUInt8();\n    if (size === 0) {\n      return 0;\n    } else if (size & 0x80) {\n      if (!signed) {\n        errors.throwErr(errors.ERR_UNEXPECTED_NEGATIVE_INTEGER, this.pos, this.packetNum);\n      }\n      isNegative = true;\n      size = size & 0x7f;\n    }\n    if (size > maxSize) {\n      errors.throwErr(errors.ERR_INTEGER_TOO_LARGE, size, maxSize, this.pos, this.packetNum);\n    }\n    if (skip) {\n      this.skipBytes(size);\n    } else {\n      const buf = this.readBytes(size);\n      const value = buf.readUIntBE(0, size);\n      return (isNegative) ? -value : value;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // numBytesLeft()\n  //\n  // Returns the number of bytes that are remaining in the buffer.\n  //---------------------------------------------------------------------------\n  numBytesLeft() {\n    return this.size - this.pos;\n  }\n\n  //---------------------------------------------------------------------------\n  // parseBinaryDouble()\n  //\n  // Parses a binary double from the supplied buffer and returns a Number.\n  // It is assumed at this point that the size of the buffer is 8 bytes. A copy\n  // is made of the buffer in order to ensure that the original buffer is not\n  // modified. If it is and data spans multiple packets, incorrect data may be\n  // returned!\n  //---------------------------------------------------------------------------\n  parseBinaryDouble(buf) {\n    buf = Buffer.from(buf);\n    if (buf[0] & 0x80) {\n      buf[0] &= 0x7f;\n    } else {\n      // complement the bits for a negative number\n      buf[0] ^= 0xff;\n      buf[1] ^= 0xff;\n      buf[2] ^= 0xff;\n      buf[3] ^= 0xff;\n      buf[4] ^= 0xff;\n      buf[5] ^= 0xff;\n      buf[6] ^= 0xff;\n      buf[7] ^= 0xff;\n    }\n    return buf.readDoubleBE();\n  }\n\n  //---------------------------------------------------------------------------\n  // parseBinaryFloat()\n  //\n  // Parses a binary float from the supplied buffer and returns a Number.  It\n  // is assumed at this point that the size of the buffer is 4 bytes. A copy is\n  // made of the buffer in order to ensure that the original buffer is not\n  // modified. If it is and data spans multiple packets, incorrect data may be\n  // returned!\n  //---------------------------------------------------------------------------\n  parseBinaryFloat(buf) {\n    buf = Buffer.from(buf);\n    if (buf[0] & 0x80) {\n      buf[0] &= 0x7f;\n    } else {\n      // complement the bits for a negative number\n      buf[0] ^= 0xff;\n      buf[1] ^= 0xff;\n      buf[2] ^= 0xff;\n      buf[3] ^= 0xff;\n    }\n    return buf.readFloatBE();\n  }\n\n  //---------------------------------------------------------------------------\n  // parseOracleDate()\n  //\n  // Parses an Oracle date from the supplied buffer and returns a Date. It is\n  // assumed at this point that the size of the buffer is either 7 bytes (date\n  // or compressed timestamp), 11 bytes (timestamp) or 13 bytes (timestamp with\n  // time zone). Time zone information is discarded because Node.js uses UTC\n  // timestamps and the server returns the data in that format, too. The Date\n  // type in Node.js doesn't support time zone information.\n  //---------------------------------------------------------------------------\n  parseOracleDate(buf, useLocalTime = true) {\n    let fseconds = 0;\n    if (buf.length >= 11) {\n      fseconds = Math.floor(buf.readUInt32BE(7) / (1000 * 1000));\n    }\n    const year = (buf[0] - 100) * 100 + buf[1] - 100;\n    return settings._makeDate(useLocalTime, year, buf[2], buf[3], buf[4] - 1,\n      buf[5] - 1, buf[6] - 1, fseconds, 0);\n  }\n\n  //---------------------------------------------------------------------------\n  // parseOracleNumber()\n  //\n  // Parses an Oracle number from the supplied buffer and returns a Number. It\n  // is assumed at this point that the buffer only contains the encoded numeric\n  // data.\n  //---------------------------------------------------------------------------\n  parseOracleNumber(buf) {\n\n    // the first byte is the exponent; positive numbers have the highest\n    // order bit set, whereas negative numbers have the highest order bit\n    // cleared and the bits inverted\n    let exponent = buf[0];\n    const isPositive = Boolean(exponent & 0x80);\n    if (!isPositive) {\n      exponent = (exponent ^ 0xFF);\n    }\n    exponent -= 193;\n    let decimalPointIndex = exponent * 2 + 2;\n\n    // a mantissa length of 0 implies a value of 0 (if positive) or a value\n    // of -1e126 (if negative)\n    if (buf.length === 1) {\n      if (isPositive) {\n        return \"0\";\n      }\n      return \"-1e126\";\n    }\n\n    // check for the trailing 102 byte for negative numbers and, if present,\n    // reduce the number of mantissa digits\n    let numBytes = buf.length;\n    if (!isPositive && buf[buf.length - 1] === 102) {\n      numBytes -= 1;\n    }\n\n    // process the mantissa bytes which are the remaining bytes; each\n    // mantissa byte is a base-100 digit\n    let base100Digit;\n    const digits = [];\n    for (let i = 1; i < numBytes; i++) {\n\n      // positive numbers have 1 added to them; negative numbers are\n      // subtracted from the value 101\n      if (isPositive) {\n        base100Digit = buf[i] - 1;\n      } else {\n        base100Digit = 101 - buf[i];\n      }\n\n      // process the first digit; leading zeroes are ignored\n      let digit = Math.floor(base100Digit / 10);\n      if (digit === 0 && i === 1) {\n        decimalPointIndex -= 1;\n      } else if (digit === 10) {\n        digits.push(\"1\");\n        digits.push(\"0\");\n        decimalPointIndex += 1;\n      } else if (digit !== 0 || i > 1) {\n        digits.push(digit.toString());\n      }\n\n      // process the second digit; trailing zeroes are ignored\n      digit = base100Digit % 10;\n      if (digit !== 0 || i < numBytes - 1) {\n        digits.push(digit.toString());\n      }\n    }\n\n    // create string of digits for transformation to JS value\n    const chars = [];\n\n    // if negative, include the sign\n    if (!isPositive) {\n      chars.push(\"-\");\n    }\n\n    // if the decimal point index is 0 or less, add the decimal point and\n    // any leading zeroes that are needed\n    if (decimalPointIndex <= 0) {\n      chars.push(\".\");\n      if (decimalPointIndex < 0)\n        chars.push(\"0\".repeat(-decimalPointIndex));\n    }\n\n    // add each of the digits\n    for (let i = 0; i < digits.length; i++) {\n      if (i > 0 && i === decimalPointIndex) {\n        chars.push(\".\");\n      }\n      chars.push(digits[i]);\n    }\n\n    // if the decimal point index exceeds the number of digits, add any\n    // trailing zeroes that are needed\n    if (decimalPointIndex > digits.length) {\n      for (let i = digits.length; i < decimalPointIndex; i++) {\n        chars.push(\"0\");\n      }\n    }\n\n    // convert result to a Number\n    return chars.join(\"\");\n  }\n\n  //---------------------------------------------------------------------------\n  // readBinaryDouble()\n  //\n  // Reads a binary double value from the buffer and returns a Number or a\n  // String, depending on the desired type.\n  //---------------------------------------------------------------------------\n  readBinaryDouble() {\n    const buf = this.readBytesWithLength();\n    if (!buf) {\n      return null;\n    }\n    return this.parseBinaryDouble(buf);\n  }\n\n  //---------------------------------------------------------------------------\n  // readBinaryFloat()\n  //\n  // Reads a binary float value from the buffer and returns a Number or a\n  // String, depending on the desired type.\n  //---------------------------------------------------------------------------\n  readBinaryFloat() {\n    const buf = this.readBytesWithLength();\n    if (!buf) {\n      return null;\n    }\n    return this.parseBinaryFloat(buf);\n  }\n\n  //---------------------------------------------------------------------------\n  // readBool()\n  //\n  // Reads a boolean value from the buffer and returns a Boolean.\n  //---------------------------------------------------------------------------\n  readBool() {\n    const buf = this.readBytesWithLength();\n    if (!buf) {\n      return null;\n    }\n    return (buf[buf.length - 1] === 1);\n  }\n\n  //---------------------------------------------------------------------------\n  // readBytes()\n  //\n  // Returns a Buffer containing the specified number of bytes. If an\n  // insufficient number of bytes are available an error is thrown.\n  //---------------------------------------------------------------------------\n  readBytes(numBytes) {\n    const numBytesLeft = this.numBytesLeft();\n    if (numBytes > numBytesLeft) {\n      errors.throwErr(errors.ERR_UNEXPECTED_END_OF_DATA, numBytes,\n        numBytesLeft);\n    }\n    const buf = this.buf.subarray(this.pos, this.pos + numBytes);\n    this.pos += numBytes;\n    return buf;\n  }\n\n  //---------------------------------------------------------------------------\n  // readBytesWithLength()\n  //\n  // Reads the length from the buffer and then returns a Buffer containing the\n  // specified number of bytes. If the length is 0 or the special null length\n  // indicator value, null is returned instead.\n  //---------------------------------------------------------------------------\n  readBytesWithLength() {\n    const numBytes = this.readUInt8();\n    if (numBytes === 0 || numBytes === constants.TNS_NULL_LENGTH_INDICATOR)\n      return null;\n    return this._readBytesWithLength(numBytes);\n  }\n\n  //---------------------------------------------------------------------------\n  // readDbObject()\n  //\n  // Reads a database object from the buffer and returns the implementation\n  // object (or null, if the object is atomically null).\n  //---------------------------------------------------------------------------\n  readDbObject() {\n    const obj = {};\n    let numBytes = this.readUB4();\n    if (numBytes > 0)\n      obj.toid = Buffer.from(this.readBytesWithLength());\n    numBytes = this.readUB4();\n    if (numBytes > 0)\n      obj.oid = Buffer.from(this.readBytesWithLength());\n    numBytes = this.readUB4();\n    if (numBytes > 0)\n      obj.snapshot = Buffer.from(this.readBytesWithLength());\n    this.skipUB2();                     // version\n    numBytes = this.readUB4();\n    this.skipUB2();                     // flags\n    if (numBytes > 0)\n      obj.packedData = Buffer.from(this.readBytesWithLength());\n    return obj;\n  }\n\n  //---------------------------------------------------------------------------\n  // readInt8()\n  //\n  // Reads a signed 8-bit integer from the buffer.\n  //---------------------------------------------------------------------------\n  readInt8() {\n    const buf = this.readBytes(1);\n    return buf.readInt8();\n  }\n\n  //---------------------------------------------------------------------------\n  // readOracleDate()\n  //\n  // Reads an Oracle date from the buffer and returns a Date or a String,\n  // depending on the desired type.\n  //---------------------------------------------------------------------------\n  readOracleDate(useLocalTime) {\n    const buf = this.readBytesWithLength();\n    if (!buf) {\n      return null;\n    }\n    return this.parseOracleDate(buf, useLocalTime);\n  }\n\n  //---------------------------------------------------------------------------\n  // readOracleNumber()\n  //\n  // Reads an Oracle number from the buffer and returns a Number or a String,\n  // depending on the desired type.\n  //---------------------------------------------------------------------------\n  readOracleNumber() {\n    const buf = this.readBytesWithLength();\n    if (!buf) {\n      return null;\n    }\n    return this.parseOracleNumber(buf);\n  }\n\n  //---------------------------------------------------------------------------\n  // readSB2()\n  //\n  // Reads a signed, variable length integer of up to 2 bytes in length.\n  //---------------------------------------------------------------------------\n  readSB2() {\n    return this._readInteger(2, true, false);\n  }\n\n  //---------------------------------------------------------------------------\n  // readSB4()\n  //\n  // Reads a signed, variable length integer of up to 4 bytes in length.\n  //---------------------------------------------------------------------------\n  readSB4() {\n    return this._readInteger(4, true, false);\n  }\n\n  //---------------------------------------------------------------------------\n  // readSB8()\n  //\n  // Reads a signed, variable length integer of up to 8 bytes in length.\n  //---------------------------------------------------------------------------\n  readSB8() {\n    return this._readInteger(8, true, false);\n  }\n\n  //---------------------------------------------------------------------------\n  // readStr()\n  //\n  // Reads a string from the buffer in the specified character set form.\n  //---------------------------------------------------------------------------\n  readStr(csfrm) {\n    const buf = this.readBytesWithLength();\n    if (!buf) {\n      return null;\n    }\n    if (csfrm === constants.CSFRM_IMPLICIT)\n      return buf.toString();\n\n    // need a copy of the buffer since swap16() changes the buffer in place and\n    // it is possible that the buffer may need to be rescanned (for the case\n    // where insufficient packets are available during the initial scan)\n    return Buffer.from(buf).swap16().toString('utf16le');\n  }\n\n  //---------------------------------------------------------------------------\n  // readUB2()\n  //\n  // Reads an unsigned, variable length integer of up to 2 bytes in length.\n  //---------------------------------------------------------------------------\n  readUB2() {\n    return this._readInteger(2, false, false);\n  }\n\n  //---------------------------------------------------------------------------\n  // readUB4()\n  //\n  // Reads an unsigned, variable length integer of up to 4 bytes in length.\n  //---------------------------------------------------------------------------\n  readUB4() {\n    return this._readInteger(4, false, false);\n  }\n\n  //---------------------------------------------------------------------------\n  // readUB8()\n  //\n  // Reads an unsigned, variable length integer of up to 8 bytes in length.\n  //---------------------------------------------------------------------------\n  readUB8() {\n    return this._readInteger(8, false, false);\n  }\n\n  //---------------------------------------------------------------------------\n  // readUInt8()\n  //\n  // Reads an unsigned 8-bit integer from the buffer.\n  //---------------------------------------------------------------------------\n  readUInt8() {\n    const buf = this.readBytes(1);\n    return buf[0];\n  }\n\n  //---------------------------------------------------------------------------\n  // readUInt16BE()\n  //\n  // Reads an unsigned 16-bit integer from the buffer in big endian order.\n  //---------------------------------------------------------------------------\n  readUInt16BE() {\n    const buf = this.readBytes(2);\n    return buf.readUInt16BE();\n  }\n\n  //---------------------------------------------------------------------------\n  // readUInt16LE()\n  //\n  // Reads an unsigned 16-bit integer from the buffer in little endian order.\n  //---------------------------------------------------------------------------\n  readUInt16LE() {\n    const buf = this.readBytes(2);\n    return buf.readUInt16LE();\n  }\n\n  //---------------------------------------------------------------------------\n  // readUInt32BE()\n  //\n  // Reads an unsigned 32-bit integer from the buffer in big endian order.\n  //---------------------------------------------------------------------------\n  readUInt32BE() {\n    const buf = this.readBytes(4);\n    return buf.readUInt32BE();\n  }\n\n  //---------------------------------------------------------------------------\n  // reserveBytes()\n  //\n  // Reserves the specified number of bytes in the buffer. If not enough bytes\n  // remain in the buffer, the buffer is grown.\n  //---------------------------------------------------------------------------\n  reserveBytes(numBytes) {\n    if (numBytes > this.numBytesLeft()) {\n      this._grow(this.pos + numBytes);\n    }\n    const pos = this.pos;\n    this.pos += numBytes;\n    return pos;\n  }\n\n  //---------------------------------------------------------------------------\n  // skipBytes()\n  //\n  // Skips the specified number of bytes in the buffer.\n  //---------------------------------------------------------------------------\n  skipBytes(numBytes) {\n    if (numBytes > this.numBytesLeft())\n      errors.throwErr(errors.ERR_UNEXPECTED_END_OF_DATA);\n    this.pos += numBytes;\n  }\n\n  //---------------------------------------------------------------------------\n  // skipSB4()\n  //\n  // Skips a signed, variable length integer of up to 4 bytes in length.\n  //---------------------------------------------------------------------------\n  skipSB4() {\n    return this._readInteger(4, true, true);\n  }\n\n  //---------------------------------------------------------------------------\n  // skipUB1()\n  //\n  // Skips a single byte integer in the buffer.\n  //---------------------------------------------------------------------------\n  skipUB1() {\n    this.skipBytes(1);\n  }\n\n  //---------------------------------------------------------------------------\n  // skipUB2()\n  //\n  // Skips an unsigned, variable length integer of up to 2 bytes in length.\n  //---------------------------------------------------------------------------\n  skipUB2() {\n    return this._readInteger(2, false, true);\n  }\n\n  //---------------------------------------------------------------------------\n  // skipUB4()\n  //\n  // Skips an unsigned, variable length integer of up to 4 bytes in length.\n  //---------------------------------------------------------------------------\n  skipUB4() {\n    return this._readInteger(4, false, true);\n  }\n\n  //---------------------------------------------------------------------------\n  // skipUB8()\n  //\n  // Skips an unsigned, variable length integer of up to 8 bytes in length.\n  //---------------------------------------------------------------------------\n  skipUB8() {\n    return this._readInteger(8, false, true);\n  }\n\n  //---------------------------------------------------------------------------\n  // writeBinaryDouble()\n  //\n  // Writes the number in binary double format to the buffer.\n  //---------------------------------------------------------------------------\n  writeBinaryDouble(n) {\n    this.writeUInt8(8);\n    const pos = this.reserveBytes(8);\n    this.buf.writeDoubleBE(n, pos);\n    if ((this.buf[pos] & 0x80) === 0) {\n      this.buf[pos] |= 0x80;\n    } else {\n      // We complement the bits for a negative number\n      this.buf[pos] ^= 0xff;\n      this.buf[pos + 1] ^= 0xff;\n      this.buf[pos + 2] ^= 0xff;\n      this.buf[pos + 3] ^= 0xff;\n      this.buf[pos + 4] ^= 0xff;\n      this.buf[pos + 5] ^= 0xff;\n      this.buf[pos + 6] ^= 0xff;\n      this.buf[pos + 7] ^= 0xff;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // writeBinaryFloat()\n  //\n  // Writes the number in binary float format to the buffer.\n  //---------------------------------------------------------------------------\n  writeBinaryFloat(n) {\n    this.writeUInt8(4);\n    const pos = this.reserveBytes(4);\n    this.buf.writeFloatBE(n, pos);\n    if ((this.buf[pos] & 0x80) === 0) {\n      this.buf[pos] |= 0x80;\n    } else {\n      // We complement the bits for a negative number\n      this.buf[pos] ^= 0xff;\n      this.buf[pos + 1] ^= 0xff;\n      this.buf[pos + 2] ^= 0xff;\n      this.buf[pos + 3] ^= 0xff;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // writeBytes()\n  //\n  // Writes the bytes in the supplied buffer to the buffer.\n  //---------------------------------------------------------------------------\n  writeBytes(value) {\n    let start = 0;\n    let valueLen = value.length;\n    while (valueLen > 0) {\n      const bytesLeft = this.numBytesLeft();\n      if (bytesLeft === 0) {\n        this._grow(this.pos + valueLen);\n      }\n      const bytesToWrite = Math.min(bytesLeft, valueLen);\n      value.copy(this.buf, this.pos, start, start + bytesToWrite);\n      this.pos += bytesToWrite;\n      start += bytesToWrite;\n      valueLen -= bytesToWrite;\n    }\n  }\n\n  // _writeRawBytesAndLength()\n  //\n  // Writes the length in the format required before\n  // writing the bytes.\n  //---------------------------------------------------------------------------\n  _writeRawBytesAndLength(value, numBytes) {\n    if (numBytes <= constants.TNS_MAX_SHORT_LENGTH) {\n      this.writeUInt8(numBytes);\n      if (numBytes > 0) {\n        this.writeBytes(value);\n      }\n    } else {\n      let start = 0;\n      this.writeUInt8(constants.TNS_LONG_LENGTH_INDICATOR);\n      while (numBytes > 0) {\n        const chunkLen = Math.min(numBytes, constants.BUFFER_CHUNK_SIZE);\n        this.writeUB4(chunkLen);\n        this.writeBytes(value.subarray(start, start + chunkLen));\n        numBytes -= chunkLen;\n        start += chunkLen;\n      }\n      this.writeUB4(0);\n    }\n  }\n  //---------------------------------------------------------------------------\n  // writeBytesWithLength()\n  //\n  // Writes the bytes in the supplied buffer to the buffer, but first writes\n  // the length. If the length exceeds a fixed value, the value is written in\n  // chunks instead.\n  //---------------------------------------------------------------------------\n  writeBytesWithLength(value) {\n    const numBytes = value.length;\n    this._writeRawBytesAndLength(value, numBytes);\n  }\n\n  //---------------------------------------------------------------------------\n  // writeDbObject()\n  //\n  // Writes a database object to the buffer.\n  //---------------------------------------------------------------------------\n  writeDbObject(obj) {\n    this.writeUB4(obj.toid.length);\n    this.writeBytesWithLength(obj.toid);\n    if (obj.oid) {\n      this.writeUB4(obj.oid.length);\n      this.writeBytesWithLength(obj.oid);\n    } else {\n      this.writeUB4(0);\n    }\n    this.writeUB4(0);                   // snapshot\n    this.writeUB4(0);                   // version\n    const packedData = obj._getPackedData();\n    this.writeUB4(packedData.length);\n    this.writeUB4(obj.flags);\n    this.writeBytesWithLength(packedData);\n  }\n\n  //---------------------------------------------------------------------------\n  // writeOracleDate()\n  //\n  // Writes the date to the buffer using the given Oracle type. Note that if a\n  // timestamp with zero milliseconds is written, the type is automatically\n  // changed to DB_TYPE_DATE (except for DB_TYPE_TIMESTAMP_TZ which requires\n  // the full amount to be written).\n  //---------------------------------------------------------------------------\n  writeOracleDate(date, type, writeLength = true) {\n    let fsec;\n    let length = type._bufferSizeFactor;\n    if (length > 7) {\n      fsec = date.getUTCMilliseconds() * 1000 * 1000;\n      if (fsec === 0 && length <= 11)\n        length = 7;\n    }\n    if (writeLength) {\n      this.writeUInt8(length);\n    }\n    const pos = this.reserveBytes(length);\n    if (type === types.DB_TYPE_DATE || type == types.DB_TYPE_TIMESTAMP) {\n      const year = date.getFullYear();\n      this.buf[pos] = Math.trunc(year / 100) + 100;\n      this.buf[pos + 1] = year % 100 + 100;\n      this.buf[pos + 2] = date.getMonth() + 1;\n      this.buf[pos + 3] = date.getDate();\n      this.buf[pos + 4] = date.getHours() + 1;\n      this.buf[pos + 5] = date.getMinutes() + 1;\n      this.buf[pos + 6] = date.getSeconds() + 1;\n    } else {\n      const year = date.getUTCFullYear();\n      this.buf[pos] = Math.trunc(year / 100) + 100;\n      this.buf[pos + 1] = year % 100 + 100;\n      this.buf[pos + 2] = date.getUTCMonth() + 1;\n      this.buf[pos + 3] = date.getUTCDate();\n      this.buf[pos + 4] = date.getUTCHours() + 1;\n      this.buf[pos + 5] = date.getUTCMinutes() + 1;\n      this.buf[pos + 6] = date.getUTCSeconds() + 1;\n    }\n    if (length > 7) {\n      this.buf.writeInt32BE(fsec, pos + 7);\n      if (length > 11) {\n        this.buf[pos + 11] = constants.TZ_HOUR_OFFSET;\n        this.buf[pos + 12] = constants.TZ_MINUTE_OFFSET;\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // writeOracleNumber()\n  //\n  // Writes the number (in string form) in Oracle Number format to the buffer.\n  //---------------------------------------------------------------------------\n  writeOracleNumber(value) {\n\n    // determine if number is negative\n    let isNegative = false;\n    if (value[0] === '-') {\n      isNegative = true;\n      value = value.substring(1);\n    }\n\n    // parse the exponent, if one is present\n    let exponent = 0;\n    const exponentPos = value.indexOf('e');\n    if (exponentPos > 0) {\n      exponent = Number(value.substring(exponentPos + 1));\n      value = value.substring(0, exponentPos);\n    }\n\n    // adjust the exponent and the value if there is a decimal point\n    const decimalPos = value.indexOf('.');\n    if (decimalPos > 0) {\n      exponent -= (value.length - decimalPos - 1);\n      value = value.substring(0, decimalPos) + value.substring(decimalPos + 1);\n    }\n\n    // strip any leading zeroes\n    if (value[0] === '0') {\n      value = value.replace(/^0+/, \"\");\n    }\n\n    // strip any trailing zeroes\n    if (value.length > 0 && value[value.length - 1] === '0') {\n      const trimmedValue = value.replace(/0+$/, \"\");\n      exponent += (value.length - trimmedValue.length);\n      value = trimmedValue;\n    }\n\n    // throw exception if number cannot be represented as an Oracle Number\n    if (value.length > constants.NUMBER_MAX_DIGITS || exponent > 126 ||\n        exponent < -129) {\n      errors.throwErr(errors.ERR_ORACLE_NUMBER_NO_REPR);\n    }\n\n    // if the exponent is odd, append a zero\n    if ((exponent > 0 && exponent % 2 === 1) ||\n        (exponent < 0 && exponent % 2 === -1)) {\n      exponent--;\n      value += \"0\";\n    }\n\n    // add a leading zero if the number of digits is odd\n    if (value.length % 2 === 1) {\n      value = \"0\" + value;\n    }\n\n    // write the encoded data to the wire\n    const appendSentinel =\n      (isNegative && value.length < constants.NUMBER_MAX_DIGITS);\n    const numPairs = value.length / 2;\n    let exponentOnWire = ((exponent + value.length) / 2) + 192;\n    if (isNegative) {\n      exponentOnWire = (exponentOnWire ^ 0xFF);\n    } else if (value.length === 0 && exponent === 0) {\n      exponentOnWire = 128;\n    }\n    let pos = this.reserveBytes(numPairs + 2 + appendSentinel);\n    this.buf[pos++] = numPairs + 1 + appendSentinel;\n    this.buf[pos++] = exponentOnWire;\n    for (let i = 0; i < value.length; i += 2) {\n      const base100Digit = Number(value.substring(i, i + 2));\n      if (isNegative) {\n        this.buf[pos++] = 101 - base100Digit;\n      } else {\n        this.buf[pos++] = base100Digit + 1;\n      }\n    }\n    if (appendSentinel) {\n      this.buf[pos] = 102;\n    }\n\n  }\n\n  //---------------------------------------------------------------------------\n  // writeQLocator()\n  //\n  // Writes a QLocator. QLocators are always 40 bytes in length.\n  //---------------------------------------------------------------------------\n  writeQLocator(numBytes) {\n    this.writeUB4(40);                  // QLocator length\n    this.writeUInt8(40);                // repeated length\n    this.writeUInt16BE(38);             // internal length\n    this.writeUInt16BE(constants.TNS_LOB_QLOCATOR_VERSION);\n    this.writeUInt8(constants.TNS_LOB_LOC_FLAGS_VALUE_BASED |\n      constants.TNS_LOB_LOC_FLAGS_BLOB | constants.TNS_LOB_LOC_FLAGS_ABSTRACT);\n    this.writeUInt8(constants.TNS_LOB_LOC_FLAGS_INIT);\n    this.writeUInt16BE(0);              // additional flags\n    this.writeUInt16BE(1);              // byt1\n    this.writeUInt64BE(numBytes);\n    this.writeUInt16BE(0);              // unused\n    this.writeUInt16BE(0);              // csid\n    this.writeUInt16BE(0);              // unused\n    this.writeUInt64BE(0);              // unused\n    this.writeUInt64BE(0);              // unused\n  }\n\n  //---------------------------------------------------------------------------\n  // writeStr()\n  //\n  // Writes the string to the buffer.\n  //---------------------------------------------------------------------------\n  writeStr(s) {\n    this.writeBytes(Buffer.from(s));\n  }\n\n  //---------------------------------------------------------------------------\n  // writeInt32BE()\n  //\n  // Writes a signed 32-bit integer to the buffer in big endian order.\n  //---------------------------------------------------------------------------\n  writeInt32BE(n) {\n    const pos = this.reserveBytes(4);\n    this.buf.writeInt32BE(n, pos);\n  }\n\n  //---------------------------------------------------------------------------\n  // writeUB4()\n  //\n  // Writes an unsigned integer (up to 4 bytes in length) in variable length\n  // format to the buffer.\n  //---------------------------------------------------------------------------\n  writeUB4(value) {\n    if (value === 0) {\n      this.writeUInt8(0);\n    } else if (value <= 0xff) {\n      this.writeUInt8(1);\n      this.writeUInt8(value);\n    } else if (value <= 0xffff) {\n      this.writeUInt8(2);\n      this.writeUInt16BE(value);\n    } else {\n      this.writeUInt8(4);\n      this.writeUInt32BE(value);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // writeUB2()\n  //\n  // Writes an unsigned integer (up to 2 bytes in length) in variable length\n  // format to the buffer.\n  //---------------------------------------------------------------------------\n  writeUB2(value) {\n    if (value === 0) {\n      this.writeUInt8(0);\n    } else if (value <= 0xff) {\n      this.writeUInt8(1);\n      this.writeUInt8(value);\n    } else {\n      this.writeUInt8(2);\n      this.writeUInt16BE(value);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // writeUB8()\n  //\n  // Writes an unsigned integer (up to 8 bytes in length) in variable length\n  // format to the buffer.\n  //---------------------------------------------------------------------------\n  writeUB8(value) {\n    if (value === 0) {\n      this.writeUInt8(0);\n    } else if (value <= 0xff) {\n      this.writeUInt8(1);\n      this.writeUInt8(value);\n    } else if (value <= 0xffff) {\n      this.writeUInt8(2);\n      this.writeUInt16BE(value);\n    } else if (value <= 0xffffffff) {\n      this.writeUInt8(4);\n      this.writeUInt32BE(value);\n    } else {\n      this.writeUInt8(8);\n      this.writeUInt64BE(value);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // writeUInt8()\n  //\n  // Writes an unsigned 8-bit integer to the buffer.\n  //---------------------------------------------------------------------------\n  writeUInt8(n) {\n    const pos = this.reserveBytes(1);\n    this.buf[pos] = n;\n  }\n\n  //---------------------------------------------------------------------------\n  // writeUInt16BE()\n  //\n  // Writes an unsigned 16-bit integer to the buffer in big endian order.\n  //---------------------------------------------------------------------------\n  writeUInt16BE(n) {\n    const pos = this.reserveBytes(2);\n    this.buf.writeUInt16BE(n, pos);\n  }\n\n  //---------------------------------------------------------------------------\n  // writeUInt32BE()\n  //\n  // Writes an unsigned 32-bit integer to the buffer in big endian order.\n  //---------------------------------------------------------------------------\n  writeUInt32BE(n) {\n    const pos = this.reserveBytes(4);\n    this.buf.writeUInt32BE(n, pos);\n  }\n\n  //---------------------------------------------------------------------------\n  // writeUInt64BE()\n  //\n  // Writes an unsigned 64-bit integer to the buffer in big endian order. Since\n  // Node.js doesn't support anything above 32-bits without using BigInt, the\n  // higher order bits are simply written as 0.\n  //---------------------------------------------------------------------------\n  writeUInt64BE(n) {\n    const pos = this.reserveBytes(8);\n    this.buf.writeUInt32BE(0, pos);\n    this.buf.writeUInt32BE(n, pos + 4);\n  }\n\n  //---------------------------------------------------------------------------\n  // writeUInt16LE()\n  //\n  // Writes an unsigned 16-bit integer to the buffer in little endian order.\n  //---------------------------------------------------------------------------\n  writeUInt16LE(n) {\n    const pos = this.reserveBytes(2);\n    this.buf.writeUInt16LE(n, pos);\n  }\n\n}\n\nclass GrowableBuffer extends BaseBuffer {\n\n  //---------------------------------------------------------------------------\n  // constructor()\n  //\n  // Initializes the buffer with an initial fixed chunk size.\n  //---------------------------------------------------------------------------\n  constructor(initializer) {\n    if (initializer) {\n      super(initializer);\n    } else {\n      super(constants.BUFFER_CHUNK_SIZE);\n      this.size = this.maxSize;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _grow()\n  //\n  // Called when the buffer needs to grow. Ensures that sufficient space is\n  // allocated to include the requested number of bytes, rounded to the nearest\n  // chunk size.\n  //---------------------------------------------------------------------------\n  _grow(numBytes) {\n    const remainder = numBytes % constants.BUFFER_CHUNK_SIZE;\n    if (remainder > 0) {\n      numBytes += (constants.BUFFER_CHUNK_SIZE - remainder);\n    }\n    const buf = Buffer.allocUnsafe(numBytes);\n    this.buf.copy(buf);\n    this.buf = buf;\n    this.maxSize = this.size = numBytes;\n  }\n}\n\nmodule.exports = {\n  BaseBuffer,\n  GrowableBuffer\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}