{"ast":null,"code":"// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst {\n  createNVPair,\n  findValue\n} = require(\"./nvStrToNvPair.js\");\nconst fs = require('fs');\nconst process = require('process');\nconst readline = require('readline');\nconst errors = require(\"../../errors.js\");\n\n/**\n * Returns File path of the tnsnames.ora if it exists.\n */\nfunction tnsnamesFilePath(configDir) {\n  let filePathVal = null;\n  const tnsAdminVal = process.env.TNS_ADMIN;\n  if (configDir) {\n    filePathVal = configDir + '/tnsnames.ora';\n    if (fs.existsSync(filePathVal)) {\n      return filePathVal;\n    } else {\n      errors.throwErr(errors.ERR_TNS_NAMES_FILE_MISSING, configDir);\n    }\n  } else {\n    if (!tnsAdminVal) {\n      errors.throwErr(errors.ERR_NO_CONFIG_DIR);\n    } else {\n      filePathVal = tnsAdminVal;\n      filePathVal += '/tnsnames.ora';\n      if (!fs.existsSync(filePathVal)) {\n        errors.throwErr(errors.ERR_TNS_NAMES_FILE_MISSING, tnsAdminVal);\n      }\n    }\n    return filePathVal;\n  }\n}\nlet prevmtime = 0;\nclass NLParamParser {\n  /**\n  * Reads the given file line by line and stores the\n  * network service names mapped to connect descriptors in the hashtable.\n  * @param {string} file_path\n  * @returns {Promise}\n  */\n  async initializeNlpa(file_path) {\n    const stat = fs.statSync(file_path);\n    if (!(stat.mtime - prevmtime)) {\n      /* File has been read */\n      return this.ht;\n    }\n\n    // Creating a readable stream from file\n    // readline module reads line by line\n    // but from a readable stream only.\n    const file = readline.createInterface({\n      input: fs.createReadStream(file_path),\n      output: process.stdout,\n      terminal: false\n    });\n    this.ht = new Map();\n    const start = async () => {\n      let nvElem = \"\";\n      for await (let line of file) {\n        if (line.length == 0) {\n          // ignore empty lines\n          continue;\n        } else if (line[0] == '#') {\n          // comment line\n          continue;\n        } else if (line[0] == ' ' ||\n        // continued input on new line\n        line[0] == '\\t' || line[0] == ')' || line[0] == '(') {\n          line = line.replace(/\\s+/g, '');\n          line = this.checkNLPforComments(line);\n          if (line.length == 0) continue;else {\n            nvElem = nvElem + line;\n          }\n        } else {\n          // new NV Element starting here\n          if (nvElem.length == 0) {\n            line = this.checkNLPforComments(line);\n            nvElem = nvElem + line;\n          } else if (nvElem.length != 0) {\n            this.addNLPListElement(nvElem); // Add Parameter to Hashtable\n            nvElem = \"\"; // Clear first, before storing current line\n\n            line = this.checkNLPforComments(line);\n            nvElem = nvElem + line;\n          }\n        }\n      }\n      if (nvElem.length != 0) {\n        // at eof, still one more parameter to read\n        this.addNLPListElement(nvElem);\n        nvElem = \"\"; // clear nvElem buffer after added\n      }\n      prevmtime = stat.mtime;\n      return this.ht;\n    };\n    return await start();\n  }\n\n  /**\n   * Given a string, this method looks if the '#' character is present.\n   * If true, the line is truncated from that point onwards until the end\n   * of the line; else, the original line is returned unchanged.\n   *\n   * @param  str     The String that is going to be tested for inline comments\n   * @return String  The modified String returned\n   */\n  checkNLPforComments(str) {\n    const str1 = new Array(str.length);\n    for (let i = 0; i < str.length; i++) {\n      const current_char = str[i];\n      if (current_char == '#') {\n        if (i != 0) {\n          break; // No need to continue. Return the line\n        } else {\n          // Entire line is a comment\n          return \"\";\n        }\n      } else str1.push(current_char);\n    }\n    return str1.join('');\n  }\n  /**\n    * adds name value pairs from the input buffer into the hash table.\n    * @param {string} ibuf\n    */\n  addNLPListElement(ibuf) {\n    const res = ibuf.split(/\\r?\\n/).filter(element => element);\n    for (let i = 0; i < res.length; i++) {\n      if (res[i].charAt(0) != '(') {\n        res[i] = '(' + res[i] + ')';\n      }\n      const nvp = createNVPair(res[i]);\n      const name = nvp.name;\n      const uname = name.toUpperCase();\n      nvp.name = uname;\n      const unames = uname.split(\",\"); //multiple aliases (alias1, alias2, alias3)\n      for (let i = 0; i < unames.length; i++) {\n        this.ht.set(unames[i], nvp);\n      }\n    }\n  }\n  toString() {\n    let out = \"\";\n    this.ht.forEach(value => {\n      out = out + value.toString() + \"\\n\";\n    });\n    return out;\n  }\n  /**\n    * if key is address/port then it returns the port value from the\n    * address NVPAIR.\n    * @param {string} key\n    * @returns {string}\n   */\n  findValueOf(key) {\n    const myarr = key.split('/');\n    return findValue(this.ht.get(myarr[0].toUpperCase()), myarr);\n  }\n}\nmodule.exports = {\n  NLParamParser,\n  tnsnamesFilePath\n};","map":{"version":3,"names":["createNVPair","findValue","require","fs","process","readline","errors","tnsnamesFilePath","configDir","filePathVal","tnsAdminVal","env","TNS_ADMIN","existsSync","throwErr","ERR_TNS_NAMES_FILE_MISSING","ERR_NO_CONFIG_DIR","prevmtime","NLParamParser","initializeNlpa","file_path","stat","statSync","mtime","ht","file","createInterface","input","createReadStream","output","stdout","terminal","Map","start","nvElem","line","length","replace","checkNLPforComments","addNLPListElement","str","str1","Array","i","current_char","push","join","ibuf","res","split","filter","element","charAt","nvp","name","uname","toUpperCase","unames","set","toString","out","forEach","value","findValueOf","key","myarr","get","module","exports"],"sources":["C:/Users/user1/Desktop/finalproject_penpick/node_modules/oracledb/lib/thin/sqlnet/paramParser.js"],"sourcesContent":["// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst {createNVPair, findValue} = require(\"./nvStrToNvPair.js\");\nconst fs = require('fs');\nconst process = require('process');\nconst readline = require('readline');\nconst errors = require(\"../../errors.js\");\n\n/**\n * Returns File path of the tnsnames.ora if it exists.\n */\nfunction tnsnamesFilePath(configDir) {\n  let filePathVal = null;\n  const tnsAdminVal = process.env.TNS_ADMIN;\n  if (configDir) {\n    filePathVal = configDir + '/tnsnames.ora';\n    if (fs.existsSync(filePathVal)) {\n      return filePathVal;\n    } else {\n      errors.throwErr(errors.ERR_TNS_NAMES_FILE_MISSING, configDir);\n    }\n  } else {\n    if (!tnsAdminVal) {\n      errors.throwErr(errors.ERR_NO_CONFIG_DIR);\n    } else {\n      filePathVal = tnsAdminVal;\n      filePathVal += '/tnsnames.ora';\n      if (!fs.existsSync(filePathVal)) {\n        errors.throwErr(errors.ERR_TNS_NAMES_FILE_MISSING, tnsAdminVal);\n      }\n    }\n    return filePathVal;\n  }\n}\n\nlet prevmtime = 0;\n\nclass NLParamParser {\n  /**\n * Reads the given file line by line and stores the\n * network service names mapped to connect descriptors in the hashtable.\n * @param {string} file_path\n * @returns {Promise}\n */\n  async initializeNlpa(file_path) {\n    const stat = fs.statSync(file_path);\n\n    if (!(stat.mtime - prevmtime)) {\n      /* File has been read */\n      return this.ht;\n    }\n\n    // Creating a readable stream from file\n    // readline module reads line by line\n    // but from a readable stream only.\n    const file = readline.createInterface({\n      input: fs.createReadStream(file_path),\n      output: process.stdout,\n      terminal: false\n    });\n    this.ht = new Map();\n\n    const start = async () =>{\n      let nvElem = \"\";\n      for await (let line of file) {\n        if (line.length == 0) {   // ignore empty lines\n          continue;\n        } else if (line[0] == '#') {  // comment line\n          continue;\n        } else if ((line[0] == ' ') ||    // continued input on new line\n                    (line[0] == '\\t') ||\n                    (line[0] == ')') ||\n                    (line[0] == '(')) {\n          line = line.replace(/\\s+/g, '');\n          line = this.checkNLPforComments(line);\n          if (line.length == 0)\n            continue;\n          else {\n            nvElem = nvElem + line;\n          }\n\n        } else {  // new NV Element starting here\n          if (nvElem.length == 0) {\n\n            line = this.checkNLPforComments(line);\n            nvElem = nvElem + line;\n\n          } else if (nvElem.length != 0) {\n            this.addNLPListElement(nvElem); // Add Parameter to Hashtable\n            nvElem = \"\"; // Clear first, before storing current line\n\n            line = this.checkNLPforComments(line);\n            nvElem = nvElem + line;\n          }\n        }\n      }\n      if (nvElem.length != 0) { // at eof, still one more parameter to read\n        this.addNLPListElement(nvElem);\n        nvElem = \"\";      // clear nvElem buffer after added\n      }\n      prevmtime = stat.mtime;\n      return this.ht;\n    };\n    return await start();\n  }\n\n  /**\n   * Given a string, this method looks if the '#' character is present.\n   * If true, the line is truncated from that point onwards until the end\n   * of the line; else, the original line is returned unchanged.\n   *\n   * @param  str     The String that is going to be tested for inline comments\n   * @return String  The modified String returned\n   */\n  checkNLPforComments(str) {\n    const str1 = new Array(str.length);\n\n    for (let i = 0; i < str.length; i++) {\n      const current_char = str[i];\n      if (current_char == '#') {\n        if (i != 0) {\n          break; // No need to continue. Return the line\n        } else {\n          // Entire line is a comment\n          return \"\";\n        }\n      } else\n        str1.push(current_char);\n    }\n    return str1.join('');\n  }\n  /**\n    * adds name value pairs from the input buffer into the hash table.\n    * @param {string} ibuf\n    */\n  addNLPListElement(ibuf) {\n    const res = ibuf.split(/\\r?\\n/).filter(element => element);\n    for (let i = 0; i < res.length; i++) {\n      if (res[i].charAt(0) != '(') {\n        res[i] = '(' + res[i] + ')';\n      }\n      const nvp = createNVPair(res[i]);\n      const name = nvp.name;\n      const uname = name.toUpperCase();\n      nvp.name = uname;\n      const unames = uname.split(\",\"); //multiple aliases (alias1, alias2, alias3)\n      for (let i = 0; i < unames.length; i++) {\n        this.ht.set(unames[i], nvp);\n      }\n    }\n  }\n\n\n  toString() {\n    let out = \"\";\n    this.ht.forEach((value) => {\n      out = out + value.toString() + \"\\n\";\n    });\n    return out;\n  }\n  /**\n    * if key is address/port then it returns the port value from the\n    * address NVPAIR.\n    * @param {string} key\n    * @returns {string}\n   */\n  findValueOf(key) {\n    const myarr = key.split('/');\n    return (findValue(this.ht.get(myarr[0].toUpperCase()), myarr));\n  }\n\n}\n\nmodule.exports = {\n  NLParamParser,\n  tnsnamesFilePath\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}