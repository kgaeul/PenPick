{"ast":null,"code":"// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst MessageWithData = require(\"./withData.js\");\nconst constants = require(\"../constants.js\");\nconst errors = require(\"../../../errors.js\");\n\n/**\n *\n * Executes OALL8 RPC function\n *\n * @class ExecuteMessage\n * @extends {MessageWithData}\n */\nclass ExecuteMessage extends MessageWithData {\n  /**\n   *\n   * @param {object} statement\n   * @param {object} options\n   */\n  constructor(connection, statement, options, resultSet) {\n    super(connection, statement, options);\n    if (!resultSet && statement.isQuery) {\n      resultSet = connection._createResultSet(options, statement);\n    }\n    this.resultSet = resultSet;\n    this.functionCode = constants.TNS_FUNC_EXECUTE;\n    this.bindParams = undefined;\n    this.currentRow = 0;\n  }\n\n  //-------------------------------------------------------------------------\n  // writeReExecuteMessage()\n  //\n  // Write the message for a full execute.\n  //-------------------------------------------------------------------------\n  writeExecuteMessage(buf) {\n    let options = 0x0;\n    let dmlOptions = 0;\n    let numParams = 0;\n    let numIters = 1;\n    // Configuring the options field thats send to the server\n    const stmt = this.statement;\n    const params = stmt.bindInfoList;\n    if (!stmt.requiresDefine && !this.parseOnly && params) {\n      numParams = params.length;\n    }\n    if (stmt.requiresDefine) {\n      options |= constants.TNS_EXEC_OPTION_DEFINE;\n    } else if (!this.parseOnly && stmt.sql) {\n      dmlOptions = constants.TNS_EXEC_OPTION_IMPLICIT_RESULTSET;\n      options |= constants.TNS_EXEC_OPTION_EXECUTE;\n    }\n    if (stmt.cursorId === 0 || stmt.isDdl) {\n      options |= constants.TNS_EXEC_OPTION_PARSE;\n    }\n    if (stmt.isQuery) {\n      if (this.parseOnly) {\n        options |= constants.TNS_EXEC_OPTION_DESCRIBE;\n      } else {\n        if (stmt.cursorId === 0 || stmt.requiresDefine) {\n          numIters = this.options.prefetchRows;\n        } else {\n          numIters = this.options.fetchArraySize;\n        }\n        if (numIters > 0 && !stmt.noPrefetch) {\n          options |= constants.TNS_EXEC_OPTION_FETCH;\n        }\n      }\n    }\n    if (!stmt.isPlSql && !this.parseOnly) {\n      options |= constants.TNS_EXEC_OPTION_NOT_PLSQL;\n    } else if (stmt.isPlSql && numParams > 0) {\n      options |= constants.TNS_EXEC_OPTION_PLSQL_BIND;\n    }\n    if (numParams > 0) {\n      options |= constants.TNS_EXEC_OPTION_BIND;\n    }\n    if (this.batchErrors) {\n      options |= constants.TNS_EXEC_OPTION_BATCH_ERRORS;\n    }\n    if (this.arrayDmlRowCounts) {\n      dmlOptions = constants.TNS_EXEC_OPTION_DML_ROWCOUNTS;\n    }\n    if (this.options.autoCommit) {\n      options |= constants.TNS_EXEC_OPTION_COMMIT;\n    }\n    this.writePiggybacks(buf);\n    this.writeFunctionHeader(buf);\n    buf.writeUB4(options); // execute options\n    buf.writeUB4(stmt.cursorId); // cursor id\n    if (stmt.cursorId === 0 || stmt.isDdl) {\n      buf.writeUInt8(1); // pointer (cursor id)\n      buf.writeUB4(stmt.sqlLength);\n    } else {\n      buf.writeUInt8(0); // pointer (cursor id)\n      buf.writeUB4(0);\n    }\n    buf.writeUInt8(1); // pointer (vector)\n    buf.writeUB4(13); // al8i4 array length\n    buf.writeUInt8(0); // pointer (al8o4)\n    buf.writeUInt8(0); // pointer (al8o4l)\n    buf.writeUInt8(0); // prefetc buffer size\n    buf.writeUB4(numIters); // prefetch num rows\n    buf.writeUB4(constants.TNS_MAX_LONG_LENGTH); // maximum long size\n    if (numParams === 0) {\n      buf.writeUInt8(0); // pointer (binds)\n      buf.writeUB4(0); // number of binds\n    } else {\n      buf.writeUInt8(1); // pointer (binds)\n      buf.writeUB4(numParams); // number of binds\n    }\n    buf.writeUInt8(0); // pointer (al8pp)\n    buf.writeUInt8(0); // pointer (al8txn)\n    buf.writeUInt8(0); // pointer (al8txl)\n    buf.writeUInt8(0); // pointer (al8kv)\n    buf.writeUInt8(0); // pointer (al8kvl)\n    if (stmt.requiresDefine) {\n      buf.writeUInt8(1); // pointer (al8doac)\n      buf.writeUB4(this.statement.queryVars.length); // number of defines\n    } else {\n      buf.writeUInt8(0);\n      buf.writeUB4(0);\n    }\n    buf.writeUB4(0); // registration id\n    buf.writeUInt8(0); // pointer (al8objlist)\n    buf.writeUInt8(1); // pointer (al8objlen)\n    buf.writeUInt8(0); // pointer (al8blv)\n    buf.writeUB4(0); // al8blv\n    buf.writeUInt8(0); // pointer (al8dnam)\n    buf.writeUB4(0); // al8dnaml\n    buf.writeUB4(0); // al8regid_msb\n    if (this.arrayDmlRowCounts) {\n      buf.writeUInt8(1); // pointer (al8pidmlrc)\n      buf.writeUB4(this.numExecs); // al8pidmlrcbl\n      buf.writeUInt8(1); // pointer (al8pidmlrcl)\n    } else {\n      buf.writeUInt8(0); // pointer (al8pidmlrc)\n      buf.writeUB4(0); // al8pidmlrcbl\n      buf.writeUInt8(0); // pointer (al8pidmlrcl)\n    }\n    if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_12_2) {\n      buf.writeUInt8(0); // pointer (al8sqlsig)\n      buf.writeUB4(0); // SQL signature length\n      buf.writeUInt8(0); // pointer (SQL ID)\n      buf.writeUB4(0); // allocated size of SQL ID\n      buf.writeUInt8(0); // pointer (length of SQL ID)\n      if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_12_2_EXT1) {\n        buf.writeUInt8(0); // pointer (chunk ids)\n        buf.writeUB4(0); // number of chunk ids\n      }\n    }\n    if (stmt.cursorId === 0 || stmt.isDdl) {\n      if (stmt.sql) {\n        buf.writeBytesWithLength(stmt.sqlBytes);\n        buf.writeUB4(1); // al8i4[0] parse\n      } else {\n        errors.throwErr(errors.ERR_INVALID_REF_CURSOR);\n      }\n    } else {\n      buf.writeUB4(0); // al8i4[0] parse\n    }\n    if (stmt.isQuery) {\n      if (stmt.cursorId === 0) {\n        buf.writeUB4(0); // al8i4[1] execution count\n      } else {\n        buf.writeUB4(numIters);\n      }\n    } else {\n      buf.writeUB4(this.numExecs); // al8i4[1] execution count\n    }\n    buf.writeUB4(0); // al8i4[2]\n    buf.writeUB4(0); // al8i4[3]\n    buf.writeUB4(0); // al8i4[4]\n    buf.writeUB4(0); // al8i4[5] SCN (part 1)\n    buf.writeUB4(0); // al8i4[6] SCN (part 2)\n    buf.writeUB4(stmt.isQuery ? 1 : 0); // al8i4[7] is query\n    buf.writeUB4(0); // al8i4[8]\n    buf.writeUB4(dmlOptions); // al8i4[9] DML row counts/implicit\n    buf.writeUB4(0); // al8i4[10]\n    buf.writeUB4(0); // al8i4[11]\n    buf.writeUB4(0); // al8i4[12]\n\n    /*\n     * write column metadata and bind params\n     */\n    if (stmt.requiresDefine) {\n      this.writeColumnMetadata(buf, this.statement.queryVars);\n    } else if (numParams > 0) {\n      return this.processBindParams(buf, params);\n    }\n  }\n\n  //-------------------------------------------------------------------------\n  // writeReExecuteMessage()\n  //\n  // Write the message header for a re-execute and return the bind parameters.\n  //-------------------------------------------------------------------------\n  writeReExecuteMessage(buf) {\n    const stmt = this.statement;\n    let params = stmt.bindInfoList;\n    let execFlag1 = 0,\n      execFlag2 = 0,\n      numIters;\n    if (params !== undefined) {\n      if (!stmt.isQuery) {\n        this.outVariables = [];\n        params.forEach(info => {\n          if (info.bindDir !== constants.TNS_BIND_DIR_INPUT) {\n            this.outVariables.push(info.bindVar);\n          }\n        });\n      }\n      const tmpparams = [];\n      params.forEach(info => {\n        if (info.bindDir !== constants.TNS_BIND_DIR_OUTPUT && !info.isReturnBind) {\n          tmpparams.push(info);\n        }\n      });\n      params = tmpparams;\n    }\n    if (this.functionCode === constants.TNS_FUNC_REEXECUTE_AND_FETCH) {\n      execFlag1 |= constants.TNS_EXEC_OPTION_EXECUTE;\n      numIters = this.options.prefetchRows;\n    } else {\n      if (this.options.autoCommit) {\n        execFlag2 |= constants.TNS_EXEC_OPTION_COMMIT_REEXECUTE;\n      }\n      numIters = this.numExecs;\n    }\n    this.writePiggybacks(buf);\n    this.writeFunctionHeader(buf);\n    buf.writeUB4(stmt.cursorId);\n    buf.writeUB4(numIters);\n    buf.writeUB4(execFlag1);\n    buf.writeUB4(execFlag2);\n    return params;\n  }\n\n  //-------------------------------------------------------------------------\n  // encode()\n  //\n  // Write the execute message to the buffer. Two types of execute messages\n  // are possible: one for a full execute and the second, simpler message,\n  // for when an existing cursor is being re-executed.\n  //-------------------------------------------------------------------------\n  encode(buf) {\n    // no rows have yet been sent so the header information needs to be sent\n    if (this.currentRow === 0) {\n      const stmt = this.statement;\n      if (stmt.cursorId !== 0 && !stmt.requiresFullExecute && !this.parseOnly && !stmt.requiresDefine && !stmt.noPrefetch && !stmt.isDdl && !this.batchErrors) {\n        if (stmt.isQuery && this.options.prefetchRows > 0) {\n          this.functionCode = constants.TNS_FUNC_REEXECUTE_AND_FETCH;\n        } else {\n          this.functionCode = constants.TNS_FUNC_REEXECUTE;\n        }\n        this.bindParams = this.writeReExecuteMessage(buf);\n      } else {\n        this.functionCode = constants.TNS_FUNC_EXECUTE;\n        this.bindParams = this.writeExecuteMessage(buf);\n      }\n    }\n\n    // if any bind parameters need to be sent, do that\n    // after each row is sent, check to see whether a pause should be performed\n    if (this.bindParams && this.bindParams.length > 0) {\n      const adapter = buf.nsi.ntAdapter;\n      while (this.currentRow < this.numExecs) {\n        buf.writeUInt8(constants.TNS_MSG_TYPE_ROW_DATA);\n        this.writeBindParamsRow(buf, this.bindParams, this.currentRow);\n        this.currentRow++;\n        if (this.currentRow < this.numExecs && adapter.shouldPauseWrite()) return true;\n      }\n    }\n\n    // reset state in case message is resent\n    this.currentRow = 0;\n    this.bindParams = undefined;\n  }\n}\nmodule.exports = ExecuteMessage;","map":{"version":3,"names":["MessageWithData","require","constants","errors","ExecuteMessage","constructor","connection","statement","options","resultSet","isQuery","_createResultSet","functionCode","TNS_FUNC_EXECUTE","bindParams","undefined","currentRow","writeExecuteMessage","buf","dmlOptions","numParams","numIters","stmt","params","bindInfoList","requiresDefine","parseOnly","length","TNS_EXEC_OPTION_DEFINE","sql","TNS_EXEC_OPTION_IMPLICIT_RESULTSET","TNS_EXEC_OPTION_EXECUTE","cursorId","isDdl","TNS_EXEC_OPTION_PARSE","TNS_EXEC_OPTION_DESCRIBE","prefetchRows","fetchArraySize","noPrefetch","TNS_EXEC_OPTION_FETCH","isPlSql","TNS_EXEC_OPTION_NOT_PLSQL","TNS_EXEC_OPTION_PLSQL_BIND","TNS_EXEC_OPTION_BIND","batchErrors","TNS_EXEC_OPTION_BATCH_ERRORS","arrayDmlRowCounts","TNS_EXEC_OPTION_DML_ROWCOUNTS","autoCommit","TNS_EXEC_OPTION_COMMIT","writePiggybacks","writeFunctionHeader","writeUB4","writeUInt8","sqlLength","TNS_MAX_LONG_LENGTH","queryVars","numExecs","caps","ttcFieldVersion","TNS_CCAP_FIELD_VERSION_12_2","TNS_CCAP_FIELD_VERSION_12_2_EXT1","writeBytesWithLength","sqlBytes","throwErr","ERR_INVALID_REF_CURSOR","writeColumnMetadata","processBindParams","writeReExecuteMessage","execFlag1","execFlag2","outVariables","forEach","info","bindDir","TNS_BIND_DIR_INPUT","push","bindVar","tmpparams","TNS_BIND_DIR_OUTPUT","isReturnBind","TNS_FUNC_REEXECUTE_AND_FETCH","TNS_EXEC_OPTION_COMMIT_REEXECUTE","encode","requiresFullExecute","TNS_FUNC_REEXECUTE","adapter","nsi","ntAdapter","TNS_MSG_TYPE_ROW_DATA","writeBindParamsRow","shouldPauseWrite","module","exports"],"sources":["C:/Users/user1/Desktop/finalproject_penpick/node_modules/oracledb/lib/thin/protocol/messages/execute.js"],"sourcesContent":["// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst MessageWithData = require(\"./withData.js\");\nconst constants = require(\"../constants.js\");\nconst errors = require(\"../../../errors.js\");\n\n/**\n *\n * Executes OALL8 RPC function\n *\n * @class ExecuteMessage\n * @extends {MessageWithData}\n */\nclass ExecuteMessage extends MessageWithData {\n  /**\n   *\n   * @param {object} statement\n   * @param {object} options\n   */\n  constructor(connection, statement, options, resultSet) {\n    super(connection, statement, options);\n    if (!resultSet && statement.isQuery) {\n      resultSet = connection._createResultSet(options, statement);\n    }\n    this.resultSet = resultSet;\n    this.functionCode = constants.TNS_FUNC_EXECUTE;\n    this.bindParams = undefined;\n    this.currentRow = 0;\n  }\n\n  //-------------------------------------------------------------------------\n  // writeReExecuteMessage()\n  //\n  // Write the message for a full execute.\n  //-------------------------------------------------------------------------\n  writeExecuteMessage(buf) {\n    let options = 0x0;\n    let dmlOptions = 0;\n    let numParams = 0;\n    let numIters = 1;\n    // Configuring the options field thats send to the server\n    const stmt = this.statement;\n    const params = stmt.bindInfoList;\n\n    if (!stmt.requiresDefine && !this.parseOnly && params) {\n      numParams = params.length;\n    }\n    if (stmt.requiresDefine) {\n      options |= constants.TNS_EXEC_OPTION_DEFINE;\n    } else if (!this.parseOnly && stmt.sql) {\n      dmlOptions = constants.TNS_EXEC_OPTION_IMPLICIT_RESULTSET;\n      options |= constants.TNS_EXEC_OPTION_EXECUTE;\n    }\n    if (stmt.cursorId === 0 || stmt.isDdl) {\n      options |= constants.TNS_EXEC_OPTION_PARSE;\n    }\n    if (stmt.isQuery) {\n      if (this.parseOnly) {\n        options |= constants.TNS_EXEC_OPTION_DESCRIBE;\n      } else {\n        if (stmt.cursorId === 0 || stmt.requiresDefine) {\n          numIters = this.options.prefetchRows;\n        } else {\n          numIters = this.options.fetchArraySize;\n        }\n        if (numIters > 0 && !stmt.noPrefetch) {\n          options |= constants.TNS_EXEC_OPTION_FETCH;\n        }\n      }\n    }\n    if (!stmt.isPlSql && !this.parseOnly) {\n      options |= constants.TNS_EXEC_OPTION_NOT_PLSQL;\n    } else if (stmt.isPlSql && numParams > 0) {\n      options |= constants.TNS_EXEC_OPTION_PLSQL_BIND;\n    }\n    if (numParams > 0) {\n      options |= constants.TNS_EXEC_OPTION_BIND;\n    }\n    if (this.batchErrors) {\n      options |= constants.TNS_EXEC_OPTION_BATCH_ERRORS;\n    }\n    if (this.arrayDmlRowCounts) {\n      dmlOptions = constants.TNS_EXEC_OPTION_DML_ROWCOUNTS;\n    }\n    if (this.options.autoCommit) {\n      options |= constants.TNS_EXEC_OPTION_COMMIT;\n    }\n    this.writePiggybacks(buf);\n    this.writeFunctionHeader(buf);\n    buf.writeUB4(options);                           // execute options\n    buf.writeUB4(stmt.cursorId);                     // cursor id\n    if (stmt.cursorId === 0 || stmt.isDdl) {\n      buf.writeUInt8(1);                             // pointer (cursor id)\n      buf.writeUB4(stmt.sqlLength);\n    } else {\n      buf.writeUInt8(0);                             // pointer (cursor id)\n      buf.writeUB4(0);\n    }\n    buf.writeUInt8(1);                               // pointer (vector)\n    buf.writeUB4(13);                                // al8i4 array length\n    buf.writeUInt8(0);                               // pointer (al8o4)\n    buf.writeUInt8(0);                               // pointer (al8o4l)\n    buf.writeUInt8(0);                               // prefetc buffer size\n    buf.writeUB4(numIters);                          // prefetch num rows\n    buf.writeUB4(constants.TNS_MAX_LONG_LENGTH);     // maximum long size\n    if (numParams === 0) {\n      buf.writeUInt8(0);                             // pointer (binds)\n      buf.writeUB4(0);                               // number of binds\n    } else {\n      buf.writeUInt8(1);                             // pointer (binds)\n      buf.writeUB4(numParams);                       // number of binds\n    }\n    buf.writeUInt8(0);                               // pointer (al8pp)\n    buf.writeUInt8(0);                               // pointer (al8txn)\n    buf.writeUInt8(0);                               // pointer (al8txl)\n    buf.writeUInt8(0);                               // pointer (al8kv)\n    buf.writeUInt8(0);                               // pointer (al8kvl)\n    if (stmt.requiresDefine) {\n      buf.writeUInt8(1);                             // pointer (al8doac)\n      buf.writeUB4(this.statement.queryVars.length);     // number of defines\n    } else {\n      buf.writeUInt8(0);\n      buf.writeUB4(0);\n    }\n    buf.writeUB4(0);                                 // registration id\n    buf.writeUInt8(0);                               // pointer (al8objlist)\n    buf.writeUInt8(1);                               // pointer (al8objlen)\n    buf.writeUInt8(0);                               // pointer (al8blv)\n    buf.writeUB4(0);                                 // al8blv\n    buf.writeUInt8(0);                               // pointer (al8dnam)\n    buf.writeUB4(0);                                 // al8dnaml\n    buf.writeUB4(0);                                 // al8regid_msb\n    if (this.arrayDmlRowCounts) {\n      buf.writeUInt8(1);                             // pointer (al8pidmlrc)\n      buf.writeUB4(this.numExecs);                   // al8pidmlrcbl\n      buf.writeUInt8(1);                             // pointer (al8pidmlrcl)\n    } else {\n      buf.writeUInt8(0);                             // pointer (al8pidmlrc)\n      buf.writeUB4(0);                               // al8pidmlrcbl\n      buf.writeUInt8(0);                             // pointer (al8pidmlrcl)\n    }\n    if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_12_2) {\n      buf.writeUInt8(0);                             // pointer (al8sqlsig)\n      buf.writeUB4(0);                               // SQL signature length\n      buf.writeUInt8(0);                             // pointer (SQL ID)\n      buf.writeUB4(0);                               // allocated size of SQL ID\n      buf.writeUInt8(0);                             // pointer (length of SQL ID)\n      if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_12_2_EXT1) {\n        buf.writeUInt8(0);                           // pointer (chunk ids)\n        buf.writeUB4(0);                             // number of chunk ids\n      }\n    }\n    if (stmt.cursorId === 0 || stmt.isDdl) {\n      if (stmt.sql) {\n        buf.writeBytesWithLength(stmt.sqlBytes);\n        buf.writeUB4(1);                             // al8i4[0] parse\n      } else {\n        errors.throwErr(errors.ERR_INVALID_REF_CURSOR);\n      }\n    } else {\n      buf.writeUB4(0);                               // al8i4[0] parse\n    }\n    if (stmt.isQuery) {\n      if (stmt.cursorId === 0) {\n        buf.writeUB4(0);                             // al8i4[1] execution count\n      } else {\n        buf.writeUB4(numIters);\n      }\n    } else {\n      buf.writeUB4(this.numExecs);                   // al8i4[1] execution count\n    }\n    buf.writeUB4(0);                                 // al8i4[2]\n    buf.writeUB4(0);                                 // al8i4[3]\n    buf.writeUB4(0);                                 // al8i4[4]\n    buf.writeUB4(0);                                 // al8i4[5] SCN (part 1)\n    buf.writeUB4(0);                                 // al8i4[6] SCN (part 2)\n    buf.writeUB4((stmt.isQuery) ? 1 : 0);            // al8i4[7] is query\n    buf.writeUB4(0);                                 // al8i4[8]\n    buf.writeUB4(dmlOptions);                        // al8i4[9] DML row counts/implicit\n    buf.writeUB4(0);                                 // al8i4[10]\n    buf.writeUB4(0);                                 // al8i4[11]\n    buf.writeUB4(0);                                 // al8i4[12]\n\n    /*\n     * write column metadata and bind params\n     */\n    if (stmt.requiresDefine) {\n      this.writeColumnMetadata(buf, this.statement.queryVars);\n    } else if (numParams > 0) {\n      return this.processBindParams(buf, params);\n    }\n  }\n\n  //-------------------------------------------------------------------------\n  // writeReExecuteMessage()\n  //\n  // Write the message header for a re-execute and return the bind parameters.\n  //-------------------------------------------------------------------------\n  writeReExecuteMessage(buf) {\n    const stmt = this.statement;\n    let params = stmt.bindInfoList;\n    let execFlag1 = 0, execFlag2 = 0, numIters;\n    if (params !== undefined) {\n      if (!stmt.isQuery) {\n        this.outVariables = [];\n        params.forEach(info => {\n          if (info.bindDir !== constants.TNS_BIND_DIR_INPUT) {\n            this.outVariables.push(info.bindVar);\n          }\n        });\n      }\n\n      const tmpparams = [];\n      params.forEach(info => {\n        if (info.bindDir !== constants.TNS_BIND_DIR_OUTPUT && !info.isReturnBind) {\n          tmpparams.push(info);\n        }\n      });\n      params = tmpparams;\n    }\n\n    if (this.functionCode === constants.TNS_FUNC_REEXECUTE_AND_FETCH) {\n      execFlag1 |= constants.TNS_EXEC_OPTION_EXECUTE;\n      numIters = this.options.prefetchRows;\n    } else {\n      if (this.options.autoCommit) {\n        execFlag2 |= constants.TNS_EXEC_OPTION_COMMIT_REEXECUTE;\n      }\n      numIters = this.numExecs;\n    }\n    this.writePiggybacks(buf);\n    this.writeFunctionHeader(buf);\n    buf.writeUB4(stmt.cursorId);\n    buf.writeUB4(numIters);\n    buf.writeUB4(execFlag1);\n    buf.writeUB4(execFlag2);\n    return params;\n  }\n\n  //-------------------------------------------------------------------------\n  // encode()\n  //\n  // Write the execute message to the buffer. Two types of execute messages\n  // are possible: one for a full execute and the second, simpler message,\n  // for when an existing cursor is being re-executed.\n  //-------------------------------------------------------------------------\n  encode(buf) {\n\n    // no rows have yet been sent so the header information needs to be sent\n    if (this.currentRow === 0) {\n      const stmt = this.statement;\n      if (stmt.cursorId !== 0 && !stmt.requiresFullExecute && !this.parseOnly && !stmt.requiresDefine && !stmt.noPrefetch && !stmt.isDdl && !this.batchErrors) {\n        if (stmt.isQuery && this.options.prefetchRows > 0) {\n          this.functionCode = constants.TNS_FUNC_REEXECUTE_AND_FETCH;\n        } else {\n          this.functionCode = constants.TNS_FUNC_REEXECUTE;\n        }\n        this.bindParams = this.writeReExecuteMessage(buf);\n      } else {\n        this.functionCode = constants.TNS_FUNC_EXECUTE;\n        this.bindParams = this.writeExecuteMessage(buf);\n      }\n    }\n\n    // if any bind parameters need to be sent, do that\n    // after each row is sent, check to see whether a pause should be performed\n    if (this.bindParams && this.bindParams.length > 0) {\n      const adapter = buf.nsi.ntAdapter;\n      while (this.currentRow < this.numExecs) {\n        buf.writeUInt8(constants.TNS_MSG_TYPE_ROW_DATA);\n        this.writeBindParamsRow(buf, this.bindParams, this.currentRow);\n        this.currentRow++;\n        if (this.currentRow < this.numExecs && adapter.shouldPauseWrite())\n          return true;\n      }\n    }\n\n    // reset state in case message is resent\n    this.currentRow = 0;\n    this.bindParams = undefined;\n\n  }\n\n}\n\nmodule.exports = ExecuteMessage;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}