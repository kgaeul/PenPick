{"ast":null,"code":"// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst errors = require(\"../../errors.js\");\n\n/**\n  * Constant which implies that the VALUE has not been set to ATOM or LIST.\n*/\nconst RHS_NONE = 0;\n/**\n  * Constant which implies that the VALUE of an NVPair is an ATOM.\n*/\nconst RHS_ATOM = 1;\n/**\n  * Constant which indicates that the VALUE of an NVPair is a list of NVPairs.\n*/\nconst RHS_LIST = 2;\n/**\n  * The List is in a regular format, i.e. (Name = Value) or (Name =\n  * (Name = Value)), and so on ..\n*/\nconst LIST_REGULAR = 3;\n/**\n  * The List is comma separated and looks like ( Name = Value, Value, Value )\n*/\nconst LIST_COMMASEP = 4;\n\n/**\n * An NVPair, or Name-Value Pair, is the structure used by SQL*Net to store\n * address information. An example of an NV-Pair is:\n *\n * CID = (ADDRESS = (PROTOCOL = TCP)(HOST = XYZ)(PORT = 1521))\n *\n * Here is a (brief) description of the syntax:\n *\n *  NVPair -> ( name = value ) value = atom | NVList\n*/\n\nclass NVPair {\n  constructor(name) {\n    this.name = name;\n    this.listType = LIST_REGULAR;\n    this.rhsType = RHS_NONE;\n  }\n  set setAtom(atom) {\n    if (this._containsComment(atom)) {\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n    }\n    this.rhsType = RHS_ATOM;\n    this.list = null;\n    this.atom = atom;\n  }\n  /**\n    * Checks if the input string contains comment.\n    * @param {string} str - input string\n    * @returns {boolean}\n    */\n  _containsComment(str) {\n    for (let i = 0; i < str.length; i++) {\n      if (str.charAt(i) == '#') {\n        if (i != 0) {\n          // Check if this character is escaped\n          if (str.charAt(i - 1) == '\\\\') continue;else return true;\n        } else {\n          // Entire line is a comment\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n     * gets the size of the list.\n     * @returns {integer}\n     */\n  getListSize() {\n    if (this.list == null) return 0;else return this.list.length;\n  }\n  /**\n     * gets the element at a given position in the list.\n     * @param {integer} pos\n     * @returns {string}\n     */\n  getListElement(pos) {\n    if (this.list == null) return null;else return this.list[pos];\n  }\n  /**\n     * adds a nvpair to the existing one.\n     * @param {nvpair} pair\n     */\n  addListElement(pair) {\n    if (this.list == null) {\n      this.rhsType = RHS_LIST;\n      this.list = new Array();\n      this.atom = null;\n    }\n    this.list.push(pair);\n    pair.parent = this;\n  }\n  /**\n     * removes an element at a given position.\n     * @param {integer} pos\n     */\n  removeListElement(pos) {\n    if (this.list != null) {\n      this.list.splice(pos, 1);\n      if (this.getListSize == 0) {\n        this.list = null;\n        this.rhsType = RHS_NONE;\n      }\n    }\n  }\n  /**\n    * Returns an empty string with the number specified in the argument. Used for\n     * indentation of multi-level NVPairs as they are stored\n     *\n     * @param count\n     *          Number of spaces required in the blank string.\n    */\n  _space(count) {\n    var blank_str = \"\";\n    for (let i = 0; i < count; i++) {\n      blank_str += \" \";\n    }\n    return blank_str;\n  }\n\n  /**\n  * Returns the value of an NVPair (and all child NVPairs) as a readable\n  * String.\n    */\n  valueToString() {\n    let out = \"\";\n    if (this.rhsType == RHS_ATOM) {\n      out = out + this.atom;\n    } else if (this.rhsType == RHS_LIST) {\n      if (this.listType == LIST_REGULAR) {\n        for (let i = 0; i < this.getListSize(); i++) {\n          out = out + this.getListElement(i).toString();\n        }\n      } else if (this.listType == LIST_COMMASEP) {\n        for (let i = 0; i < this.getListSize(); i++) {\n          const listElem = this.getListElement(i);\n          out = out + listElem.name;\n          if (i != this.getListSize() - 1) out = out + \", \";\n        }\n      }\n    }\n    return out;\n  }\n\n  /**\n    *\n    * @returns string representation of the nvpair\n    */\n  toString() {\n    let out = \"(\" + this.name + \"=\";\n    if (this.rhsType == RHS_ATOM) {\n      out = out + this.atom;\n    } else if (this.rhsType == RHS_LIST) {\n      if (this.listType == LIST_REGULAR) {\n        for (let i = 0; i < this.getListSize(); i++) {\n          out = out + this.getListElement(i).toString();\n        }\n      } else if (this.listType == LIST_COMMASEP) {\n        out = out + \" (\";\n        for (let i = 0; i < this.getListSize(); i++) {\n          const listElem = this.getListElement(i);\n          out = out + listElem.name;\n          if (i != this.getListSize() - 1) out = out + \", \";\n        }\n        out = out + \")\";\n      }\n    }\n    out = out + \")\";\n    return out;\n  }\n}\n/**\n   * Constant which indicates that there are no more tokens left.\n   */\nconst TKN_NONE = 0;\n\n/**\n   * Constant for left parenthesis '(' token.\n   */\nconst TKN_LPAREN = 1;\n\n/**\n   * Constant for right parenthesis ')' token.\n   */\nconst TKN_RPAREN = 2;\n\n/**\n   * Constant for comma token ',' token.\n   */\nconst TKN_COMMA = 3;\n\n/**\n   * Constant for equal sign '=' token.\n   */\nconst TKN_EQUAL = 4;\n\n/**\n   * Constant for literal token.\n   */\nconst TKN_LITERAL = 8;\n\n/**\n   * Constant marking end of NVString.\n   */\nconst TKN_EOS = 9;\n\n/*\n   * Characters used for comparison for tokens. When the analyzer hits and\n   * unescaped TKN_LPAREN_VALUE it interprets it as a TKN_LPAREN token.\n   */\nconst TKN_LPAREN_VALUE = '(';\nconst TKN_RPAREN_VALUE = ')';\nconst TKN_COMMA_VALUE = ',';\nconst TKN_EQUAL_VALUE = '=';\nconst TKN_BKSLASH_VALUE = '\\\\';\nconst TKN_DQUOTE_VALUE = \"\\\"\";\nconst TKN_SQUOTE_VALUE = '\\'';\nconst TKN_EOS_VALUE = '%';\n\n/*\n   * Characters which are considered whitespace.\n   */\nconst TKN_SPC_VALUE = ' ';\nconst TKN_TAB_VALUE = '\\t';\nconst TKN_LF_VALUE = '\\n';\nconst TKN_CR_VALUE = '\\r';\n\n/**\n * The NVTokens class is used to help break NVStrings apart into tokens, such as\n * TKN_LPAREN or TKN_LITERAL - this helps simplify the task of building NVPairs\n * from an NVString.\n*/\nclass NVTokens {\n  /**\n   * Constructs NVTokens object for use.\n   */\n  constructor() {\n    this.tkType = null;\n    this.tkValue = null;\n    this.numTokens = 0;\n    this.tkPos = 0;\n  }\n\n  /*\n   * function to determine if a given character is whitespace. The\n   * following constitute whitespace: ' ' (SPACE), '\\t' (TAB), '\\n' (NEWLINE),\n   * '\\r' (LINEFEED),\n   */\n  _isWhiteSpace(it) {\n    if (it == TKN_SPC_VALUE || it == TKN_TAB_VALUE || it == TKN_LF_VALUE || it == TKN_CR_VALUE) {\n      return true;\n    }\n    return false;\n  }\n\n  /*\n   * function to trim leading and trailing spaces from a literal.\n   */\n  _trimWhiteSpace(it) {\n    const length = it.length;\n    let start = 0;\n    let end = length;\n\n    // Find first non-whitespace character\n    while (start < length && this._isWhiteSpace(it.charAt(start))) {\n      start++;\n    }\n    // From the back, find last non-whitespace character\n    while (start < end && this._isWhiteSpace(it.charAt(end - 1))) {\n      end--;\n    }\n    return it.substring(start, end);\n  }\n\n  /**\n   * Parses an NVString into a list of tokens which can be more easily\n   * interpreted. The list of tokens is stored within the class and must be\n   * accessed through getToken()/getLiteral() and eatToken().\n   *\n   * @param nvString\n   *          NVString to be parsed.\n   */\n  parseTokens(nvString) {\n    this.numTokens = 0;\n    this.tkPos = 0;\n    this.tkType = new Array();\n    this.tkValue = new Array();\n    const len = nvString.length;\n    let eql_seen = false;\n    // convert NVString to character array for easier access\n    let input = new Array();\n    input = Array.from(nvString);\n    let pos = 0; // position in NVString\n\n    while (pos < len) {\n      // eat leading whitespace\n      while (pos < len && this._isWhiteSpace(input[pos])) {\n        pos++;\n      }\n      if (pos < len) {\n        switch (input[pos]) {\n          // For metacharacters (, ), and =, add to the token list, and\n          // advance the NVString position. (Save token, eat character)\n          case TKN_LPAREN_VALUE:\n            eql_seen = false;\n            this._addToken(TKN_LPAREN, TKN_LPAREN_VALUE);\n            pos++;\n            break;\n          case TKN_EQUAL_VALUE:\n            eql_seen = true;\n            this._addToken(TKN_EQUAL, TKN_EQUAL_VALUE);\n            pos++;\n            break;\n          case TKN_RPAREN_VALUE:\n            eql_seen = false;\n            this._addToken(TKN_RPAREN, TKN_RPAREN_VALUE);\n            pos++;\n            break;\n          case TKN_COMMA_VALUE:\n            eql_seen = false;\n            this._addToken(TKN_COMMA, TKN_COMMA_VALUE);\n            pos++;\n            break;\n          default:\n            // Otherwise, treat it as a literal\n            {\n              let startPos = pos;\n              let endPos = -1; // substring position in input\n              let quoted_str = false; // is literal wrapped with quotes?\n              let quote_char = TKN_DQUOTE_VALUE;\n\n              // does it begin with a single or double quote?\n              if (input[pos] == TKN_SQUOTE_VALUE || input[pos] == TKN_DQUOTE_VALUE) {\n                quoted_str = true;\n                quote_char = input[pos];\n                pos++;\n                startPos = pos;\n              }\n              while (pos < len) {\n                // On a backslash (escaped character), save the backslash and\n                // following character into the literal.\n                if (input[pos] == TKN_BKSLASH_VALUE) {\n                  pos += 2;\n                  continue;\n                }\n                if (quoted_str) {\n                  // literal wrapped with quotes\n                  if (input[pos] == quote_char) {\n                    // quote terminator found\n                    pos++;\n                    endPos = pos - 1; // exclusive\n                    break;\n                  }\n                } else {\n                  // did we hit unescaped meta character ( ) or =\n                  if (input[pos] == TKN_LPAREN_VALUE || input[pos] == TKN_RPAREN_VALUE || input[pos] == TKN_COMMA_VALUE && !eql_seen || input[pos] == TKN_EQUAL_VALUE && !eql_seen) {\n                    // terminate string - do NOT increment POS, or it will\n                    // swallow the metacharacter into the literal\n                    endPos = pos; // exclusive\n                    break;\n                  }\n                }\n                pos++; // accept character into literal\n              }\n              if (endPos == -1) {\n                // reached end of NVString without terminator\n                endPos = pos; // exclusive\n              }\n              this._addToken(TKN_LITERAL, nvString.substring(startPos, endPos).trim());\n              break;\n            }\n        }\n      }\n    }\n    // Add TKN_EOS as the last token in token list.\n    this._addToken(TKN_EOS, TKN_EOS_VALUE);\n    return true;\n  }\n  /**\n   * Returns current token. Throws Error if no string has\n   * been parsed, or if there are no tokens left. Does NOT advance\n   * the token position.\n   */\n  getToken() {\n    if (this.tkType == null) {\n      // nothing parsed\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n    }\n    if (this.tkPos < this.numTokens) {\n      // are there tokens left?\n      return Number(this.tkType[this.tkPos]);\n    } else {\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n    }\n  }\n\n  /**\n   * Returns current token. Throws Error if no string has\n   * been parsed, or if there are no tokens left. DOES advance the\n   * token position.\n   */\n  popToken() {\n    let token = TKN_NONE;\n    if (this.tkType == null) {\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n    }\n    if (this.tkPos < this.numTokens) {\n      // if parsed and tokens left\n      token = Number(this.tkType[this.tkPos++]);\n    } else {\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n    }\n    return token;\n  }\n  /**\n   * Returns literal for current token. If current token is NOT a TKN_LITERAL,\n   * it returns a string representation of the current token. Throws\n   * Error if no string has been parsed, or\n   * if there are no tokens left.\n   *\n   * DOES NOT advance the token position.\n   */\n  getLiteral() {\n    let theLiteral = null;\n    if (this.tkValue == null) {\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n    }\n    // If we have parsed an NV string AND we have tokens left\n    if (this.tkPos < this.numTokens) {\n      theLiteral = String(this.tkValue[this.tkPos]);\n    } else {\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n    }\n    return theLiteral;\n  }\n\n  /**\n   * Returns literal for current token. If current token is NOT a TKN_LITERAL,\n   * it returns a string representation of the current token. Throws\n   * Error if no string has been parsed, or\n   * if there are no tokens left.\n   *\n   * DOES advance the token position.\n   */\n  popLiteral() {\n    let theLiteral = null;\n    if (this.tkValue == null) {\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n    }\n    // If we have parsed an NV string AND we have tokens left.\n    if (this.tkPos < this.numTokens) {\n      theLiteral = String(this.tkValue[this.tkPos++]);\n    } else {\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n    }\n    return theLiteral;\n  }\n\n  /**\n   * Advances the token position by one.\n   */\n  eatToken() {\n    if (this.tkPos < this.numTokens) {\n      this.tkPos++;\n    }\n  }\n\n  /**\n   * Returns NVTokens list as a readable String.\n   */\n  toString() {\n    if (this.tkType == null) {\n      return \"*NO TOKENS*\";\n    }\n    let out = \"Tokens\";\n    for (let i = 0; i < this.numTokens; i++) {\n      out = out + \" : \" + this.tkValue[i];\n    }\n    return out;\n  }\n  /*\n   * function to add a token and corresponding printable version (i.e.,\n   * TKN_LPAREN and TKN_LPAREN_VALUE) into the token list.\n   */\n  _addToken(tk, tk_val) {\n    this.tkType.push(Number(tk));\n    this.tkValue.push(String(tk_val));\n    this.numTokens++;\n  }\n}\n\n/**\n * The NVFactory class is used to help interpret the tokens generated by\n * NVTokens from an NVString.\n */\n\n/**\n  * Returns an NVPair which contains the broken-down form of nvString\n  * @param  nvString  the nvString to parse\n  */\nfunction createNVPair(nvString) {\n  const nvt = new NVTokens();\n  nvt.parseTokens(nvString);\n  return readTopLevelNVPair(nvt);\n}\n\n/*\n  * function which returns a top-level NVPair from NVTokens.\n  * NVPair: (name=value)\n  * value: atom | NVList\n  */\nfunction readTopLevelNVPair(nvt) {\n  //check for opening (\n  let tk = nvt.getToken();\n  nvt.eatToken();\n  if (tk != TKN_LPAREN) {\n    errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n  }\n  let name = readNVLiteral(nvt);\n  const nvp = new NVPair(name);\n  if ((tk = nvt.getToken()) == TKN_COMMA) {\n    // read comma'ed names as one name\n    while (tk == TKN_LITERAL || tk == TKN_COMMA) {\n      name += nvt.popLiteral();\n      tk = nvt.getToken();\n    }\n    nvp.name = name;\n    return readRightHandSide(nvp, nvt);\n  }\n  return readRightHandSide(nvp, nvt);\n}\n/*\n * function which returns the next NVPair from NVTokens.\n *   NVPair: (name=value) | (name, | ,name) | ,name,\n *   value: atom | NVList\n */\nfunction readNVPair(nvt) {\n  // Opening ( or , for NVPair\n  const tk = nvt.getToken();\n  nvt.eatToken();\n  if (!(tk == TKN_LPAREN || tk == TKN_COMMA)) {\n    errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n  }\n  const name = readNVLiteral(nvt);\n  const nvp = new NVPair(name);\n  return readRightHandSide(nvp, nvt);\n}\n\n/*\n* function which reads rhs and returns NVPair from NVTokens.\n * NVPair: (name=value)\n * value: atom | NVList\n*/\nfunction readRightHandSide(nvp, nvt) {\n  let tk = nvt.getToken();\n  switch (tk) {\n    case TKN_EQUAL:\n      nvt.eatToken();\n\n      // If the next token after \"=\" is a LITERAL, then read an atom,\n      // otherwise read an NVList.\n      tk = nvt.getToken();\n      if (tk == TKN_LITERAL) {\n        const value = readNVLiteral(nvt);\n        nvp.setAtom = value;\n      } else {\n        // NVList is responsible for adding child NVPairs to this parent\n        // NVPair.\n        readNVList(nvt, nvp);\n      }\n      break;\n    case TKN_COMMA:\n    case TKN_RPAREN:\n      // If we get a \"comma\" or \")\", then we need to parse a list of values.\n      // eg, \"(x=(value1, value2,...))\" or \"(x=(value))\"\n      nvp.setAtom = nvp.name;\n      break;\n    default:\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n  }\n\n  // terminating \")\" or \",\" for NVPair\n  tk = nvt.getToken();\n  if (tk == TKN_RPAREN) {\n    nvt.eatToken();\n  } else if (tk != TKN_COMMA) {\n    errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n  }\n  return nvp;\n}\n/*\n * function which returns the next literal from NVTokens.\n */\nfunction readNVLiteral(nvt) {\n  const tk = nvt.getToken();\n  if (tk != TKN_LITERAL) {\n    errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n  }\n  return nvt.popLiteral();\n}\n\n/*\n * function which adds a list of NVPairs to a parent NVPair.\n *   NVList:  NVPair NVList | epsilon\n */\nfunction readNVList(nvt, parent) {\n  // if next token is \"(\" or \",\", then read an NVPair\n  // otherwise, assume epsilon\n  const tk = nvt.getToken();\n  if (!(tk == TKN_LPAREN || tk == TKN_COMMA)) {\n    return; // didn't read an nvpair\n  }\n  const child = readNVPair(nvt);\n\n  // read a good NVPair\n  parent.addListElement(child);\n  if (tk == TKN_COMMA || child.name == child.atom) {\n    if (parent.getListType != LIST_COMMASEP)\n      // if not already set\n      parent.setListType = LIST_COMMASEP; // set it\n  }\n  readNVList(nvt, parent); // next iteration of NVList()\n}\n\n/**\n  * Returns a NVPair whose name matches (ignoring case) the specified\n  * name.  This function does search recursively through all descendents\n  * of the specified NVPair.\n  * @param  nvp  NVPair to search through\n  * @param  name  name to match (ignoring case)\n  */\nfunction findNVPairRecurse(nvp, name) {\n  /* Is the base NV Pair the name we are looking for?                    */\n  if (!nvp) {\n    return null;\n  }\n  if (name.toUpperCase() == nvp.name.toUpperCase()) return nvp;\n\n  /* Do we have anywhere else to search (ie, is nvp a list)?               */\n  if (nvp.getRHSType == RHS_ATOM) return null;\n\n  /* Loop thru the list of children and searching each child for name.     */\n  for (let i = 0; i < nvp.getListSize(); i++) {\n    const child = findNVPairRecurse(nvp.getListElement(i), name);\n\n    /* Did we find \"name\"?                                                 */\n    if (child !== null) return child;\n  }\n  return null;\n}\n\n/**\n  * Returns a NVPair whose name matches (ignoring case) the specified\n  * name. This functions only searches the direct descendants of specified NVPair\n  * @param  nvp  NVPair to search through\n  * @param  name  name to match (ignoring case)\n  */\nfunction findNVPair(nvp, name) {\n  if (!nvp) {\n    return null;\n  }\n\n  /* Do we have anywhere else to search (ie, is nvp a list)?               */\n  if (nvp.getRHSType == RHS_ATOM) return null;\n\n  /* Loop thru the list of children and searching each child for name.     */\n  for (let i = 0; i < nvp.getListSize(); i++) {\n    const child = nvp.getListElement(i);\n    if (name.toUpperCase() == child.name.toUpperCase()) return child;\n  }\n  return null;\n}\n\n/**\n  * Returns a value which matches the specified path\n  * @param  nvp  NVPair to search through\n  * @param  name  array of names to match (ignoring case)\n  */\nfunction findValue(nvp, names) {\n  if (!nvp) {\n    return null;\n  }\n\n  /* Is the base NV Pair the first name in path */\n  if (names[0].toUpperCase() != nvp.name.toUpperCase()) return null;\n  let output = nvp;\n  const sze = names.length;\n  for (let i = 1; i < sze; i++) {\n    output = findNVPair(output, names[i]);\n    if (!output) return null;\n  }\n  if (output.atom == null) {\n    if (output.list == null) return null;else return output.list.toString();\n  } else {\n    return output.atom.toString();\n  }\n}\nmodule.exports = {\n  findNVPairRecurse,\n  createNVPair,\n  findNVPair,\n  findValue\n};","map":{"version":3,"names":["errors","require","RHS_NONE","RHS_ATOM","RHS_LIST","LIST_REGULAR","LIST_COMMASEP","NVPair","constructor","name","listType","rhsType","setAtom","atom","_containsComment","throwErr","ERR_INVALID_CONNECT_STRING_SYNTAX","list","str","i","length","charAt","getListSize","getListElement","pos","addListElement","pair","Array","push","parent","removeListElement","splice","_space","count","blank_str","valueToString","out","toString","listElem","TKN_NONE","TKN_LPAREN","TKN_RPAREN","TKN_COMMA","TKN_EQUAL","TKN_LITERAL","TKN_EOS","TKN_LPAREN_VALUE","TKN_RPAREN_VALUE","TKN_COMMA_VALUE","TKN_EQUAL_VALUE","TKN_BKSLASH_VALUE","TKN_DQUOTE_VALUE","TKN_SQUOTE_VALUE","TKN_EOS_VALUE","TKN_SPC_VALUE","TKN_TAB_VALUE","TKN_LF_VALUE","TKN_CR_VALUE","NVTokens","tkType","tkValue","numTokens","tkPos","_isWhiteSpace","it","_trimWhiteSpace","start","end","substring","parseTokens","nvString","len","eql_seen","input","from","_addToken","startPos","endPos","quoted_str","quote_char","trim","getToken","Number","popToken","token","getLiteral","theLiteral","String","popLiteral","eatToken","tk","tk_val","createNVPair","nvt","readTopLevelNVPair","readNVLiteral","nvp","readRightHandSide","readNVPair","value","readNVList","child","getListType","setListType","findNVPairRecurse","toUpperCase","getRHSType","findNVPair","findValue","names","output","sze","module","exports"],"sources":["C:/Users/user1/Desktop/finalproject_penpick/node_modules/oracledb/lib/thin/sqlnet/nvStrToNvPair.js"],"sourcesContent":["// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst errors = require(\"../../errors.js\");\n\n\n/**\n  * Constant which implies that the VALUE has not been set to ATOM or LIST.\n*/\nconst RHS_NONE = 0;\n/**\n  * Constant which implies that the VALUE of an NVPair is an ATOM.\n*/\nconst  RHS_ATOM = 1;\n/**\n  * Constant which indicates that the VALUE of an NVPair is a list of NVPairs.\n*/\nconst RHS_LIST = 2;\n/**\n  * The List is in a regular format, i.e. (Name = Value) or (Name =\n  * (Name = Value)), and so on ..\n*/\nconst LIST_REGULAR = 3;\n/**\n  * The List is comma separated and looks like ( Name = Value, Value, Value )\n*/\nconst LIST_COMMASEP = 4;\n\n/**\n * An NVPair, or Name-Value Pair, is the structure used by SQL*Net to store\n * address information. An example of an NV-Pair is:\n *\n * CID = (ADDRESS = (PROTOCOL = TCP)(HOST = XYZ)(PORT = 1521))\n *\n * Here is a (brief) description of the syntax:\n *\n *  NVPair -> ( name = value ) value = atom | NVList\n*/\n\nclass NVPair {\n  constructor(name) {\n    this.name = name;\n    this.listType = LIST_REGULAR;\n    this.rhsType = RHS_NONE;\n  }\n  set setAtom(atom) {\n    if (this._containsComment(atom)) {\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n    }\n    this.rhsType = RHS_ATOM;\n    this.list = null;\n    this.atom = atom;\n  }\n  /**\n    * Checks if the input string contains comment.\n    * @param {string} str - input string\n    * @returns {boolean}\n    */\n  _containsComment(str) {\n    for (let i = 0; i < str.length; i++) {\n      if (str.charAt(i) == '#') {\n        if (i != 0) {\n          // Check if this character is escaped\n          if (str.charAt(i - 1) == '\\\\')\n            continue;\n          else\n            return true;\n        } else {\n          // Entire line is a comment\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n     * gets the size of the list.\n     * @returns {integer}\n     */\n  getListSize() {\n    if (this.list == null)\n      return 0;\n    else\n      return this.list.length;\n  }\n  /**\n     * gets the element at a given position in the list.\n     * @param {integer} pos\n     * @returns {string}\n     */\n  getListElement(pos) {\n    if (this.list == null)\n      return null;\n    else\n      return this.list[pos];\n  }\n  /**\n     * adds a nvpair to the existing one.\n     * @param {nvpair} pair\n     */\n  addListElement(pair) {\n    if (this.list == null) {\n      this.rhsType = RHS_LIST;\n      this.list = new Array();\n      this.atom = null;\n    }\n    this.list.push(pair);\n    pair.parent = this;\n  }\n  /**\n     * removes an element at a given position.\n     * @param {integer} pos\n     */\n  removeListElement(pos) {\n    if (this.list != null) {\n      this.list.splice(pos, 1);\n      if (this.getListSize == 0) {\n        this.list = null;\n        this.rhsType = RHS_NONE;\n      }\n    }\n  }\n  /**\n    * Returns an empty string with the number specified in the argument. Used for\n     * indentation of multi-level NVPairs as they are stored\n     *\n     * @param count\n     *          Number of spaces required in the blank string.\n    */\n  _space(count) {\n    var blank_str = \"\";\n    for (let i = 0;i < count;i++) {\n      blank_str += \" \";\n    }\n    return blank_str;\n  }\n\n  /**\n  * Returns the value of an NVPair (and all child NVPairs) as a readable\n  * String.\n    */\n  valueToString() {\n    let out = \"\";\n    if (this.rhsType == RHS_ATOM) {\n      out = out + this.atom;\n    } else if (this.rhsType == RHS_LIST) {\n      if (this.listType == LIST_REGULAR) {\n        for (let i = 0; i < this.getListSize(); i++) {\n          out = out + this.getListElement(i).toString();\n        }\n      } else if (this.listType == LIST_COMMASEP) {\n        for (let i = 0; i < this.getListSize(); i++) {\n          const listElem = this.getListElement(i);\n          out = out + listElem.name;\n          if (i != this.getListSize() - 1)\n            out = out + \", \";\n        }\n      }\n    }\n    return out;\n  }\n\n  /**\n    *\n    * @returns string representation of the nvpair\n    */\n  toString() {\n    let out = \"(\" + this.name + \"=\";\n    if (this.rhsType == RHS_ATOM) {\n      out = out + this.atom;\n    } else if (this.rhsType == RHS_LIST) {\n      if (this.listType == LIST_REGULAR) {\n        for (let i = 0; i < this.getListSize(); i++) {\n          out = out + this.getListElement(i).toString();\n        }\n      } else if (this.listType == LIST_COMMASEP) {\n        out = out + \" (\";\n        for (let i = 0; i < this.getListSize(); i++) {\n          const listElem = this.getListElement(i);\n          out = out + listElem.name;\n\n          if (i != this.getListSize() - 1)\n            out = out + \", \";\n        }\n        out = out + \")\";\n      }\n    }\n    out = out + \")\";\n    return out;\n  }\n\n\n}\n/**\n   * Constant which indicates that there are no more tokens left.\n   */\nconst  TKN_NONE = 0;\n\n/**\n   * Constant for left parenthesis '(' token.\n   */\nconst TKN_LPAREN = 1;\n\n/**\n   * Constant for right parenthesis ')' token.\n   */\nconst TKN_RPAREN = 2;\n\n/**\n   * Constant for comma token ',' token.\n   */\nconst TKN_COMMA = 3;\n\n/**\n   * Constant for equal sign '=' token.\n   */\nconst TKN_EQUAL = 4;\n\n/**\n   * Constant for literal token.\n   */\nconst TKN_LITERAL = 8;\n\n/**\n   * Constant marking end of NVString.\n   */\nconst TKN_EOS = 9;\n\n/*\n   * Characters used for comparison for tokens. When the analyzer hits and\n   * unescaped TKN_LPAREN_VALUE it interprets it as a TKN_LPAREN token.\n   */\nconst TKN_LPAREN_VALUE = '(';\nconst TKN_RPAREN_VALUE = ')';\nconst TKN_COMMA_VALUE = ',';\nconst TKN_EQUAL_VALUE = '=';\nconst TKN_BKSLASH_VALUE = '\\\\';\nconst TKN_DQUOTE_VALUE = \"\\\"\";\nconst TKN_SQUOTE_VALUE = '\\'';\nconst TKN_EOS_VALUE = '%';\n\n/*\n   * Characters which are considered whitespace.\n   */\nconst TKN_SPC_VALUE = ' ';\nconst TKN_TAB_VALUE = '\\t';\nconst TKN_LF_VALUE = '\\n';\nconst TKN_CR_VALUE = '\\r';\n\n/**\n * The NVTokens class is used to help break NVStrings apart into tokens, such as\n * TKN_LPAREN or TKN_LITERAL - this helps simplify the task of building NVPairs\n * from an NVString.\n*/\nclass NVTokens {\n\n\n  /**\n   * Constructs NVTokens object for use.\n   */\n  constructor() {\n    this.tkType = null;\n    this.tkValue = null;\n    this.numTokens = 0;\n    this.tkPos = 0;\n  }\n\n  /*\n   * function to determine if a given character is whitespace. The\n   * following constitute whitespace: ' ' (SPACE), '\\t' (TAB), '\\n' (NEWLINE),\n   * '\\r' (LINEFEED),\n   */\n  _isWhiteSpace(it) {\n    if ((it == TKN_SPC_VALUE) || (it == TKN_TAB_VALUE) || (it == TKN_LF_VALUE)\n        || (it == TKN_CR_VALUE)) {\n      return true;\n    }\n    return false;\n  }\n\n  /*\n   * function to trim leading and trailing spaces from a literal.\n   */\n  _trimWhiteSpace(it) {\n    const length = it.length;\n    let start = 0;\n    let end = length;\n\n    // Find first non-whitespace character\n    while ((start < length) && (this._isWhiteSpace(it.charAt(start)))) {\n      start++;\n    }\n    // From the back, find last non-whitespace character\n    while ((start < end) && (this._isWhiteSpace(it.charAt(end - 1)))) {\n      end--;\n    }\n    return it.substring(start, end);\n  }\n\n  /**\n   * Parses an NVString into a list of tokens which can be more easily\n   * interpreted. The list of tokens is stored within the class and must be\n   * accessed through getToken()/getLiteral() and eatToken().\n   *\n   * @param nvString\n   *          NVString to be parsed.\n   */\n  parseTokens(nvString) {\n    this.numTokens = 0;\n    this.tkPos = 0;\n    this.tkType = new Array();\n    this.tkValue = new Array();\n\n    const len = nvString.length;\n    let eql_seen = false;\n    // convert NVString to character array for easier access\n    let input = new Array();\n    input = Array.from(nvString);\n    let pos = 0; // position in NVString\n\n    while (pos < len) {\n      // eat leading whitespace\n      while ((pos < len) && (this._isWhiteSpace(input[pos]))) {\n        pos++;\n      }\n      if (pos < len) {\n        switch (input[pos]) {\n        // For metacharacters (, ), and =, add to the token list, and\n        // advance the NVString position. (Save token, eat character)\n          case TKN_LPAREN_VALUE:\n            eql_seen = false;\n            this._addToken(TKN_LPAREN, TKN_LPAREN_VALUE);\n            pos++;\n            break;\n\n          case TKN_EQUAL_VALUE:\n            eql_seen = true;\n            this._addToken(TKN_EQUAL, TKN_EQUAL_VALUE);\n            pos++;\n            break;\n\n          case TKN_RPAREN_VALUE:\n            eql_seen = false;\n            this._addToken(TKN_RPAREN, TKN_RPAREN_VALUE);\n            pos++;\n            break;\n          case TKN_COMMA_VALUE:\n            eql_seen = false;\n            this._addToken(TKN_COMMA, TKN_COMMA_VALUE);\n            pos++;\n            break;\n\n          default: // Otherwise, treat it as a literal\n          {\n            let startPos = pos;\n            let endPos = -1; // substring position in input\n            let quoted_str = false; // is literal wrapped with quotes?\n            let quote_char = TKN_DQUOTE_VALUE;\n\n            // does it begin with a single or double quote?\n            if ((input[pos] == TKN_SQUOTE_VALUE)\n              || (input[pos] == TKN_DQUOTE_VALUE)) {\n              quoted_str = true;\n              quote_char = input[pos];\n              pos++;\n              startPos = pos;\n            }\n\n            while (pos < len) {\n            // On a backslash (escaped character), save the backslash and\n            // following character into the literal.\n              if (input[pos] == TKN_BKSLASH_VALUE) {\n                pos += 2;\n                continue;\n              }\n\n              if (quoted_str) { // literal wrapped with quotes\n                if (input[pos] == quote_char) {// quote terminator found\n                  pos++;\n                  endPos = pos - 1; // exclusive\n                  break;\n                }\n              } else { // did we hit unescaped meta character ( ) or =\n                if ((input[pos] == TKN_LPAREN_VALUE)\n                  || (input[pos] == TKN_RPAREN_VALUE)\n                  || ((input[pos] == TKN_COMMA_VALUE) && !eql_seen)\n                  || ((input[pos] == TKN_EQUAL_VALUE) && !eql_seen)) {\n                // terminate string - do NOT increment POS, or it will\n                // swallow the metacharacter into the literal\n                  endPos = pos; // exclusive\n                  break;\n                }\n              }\n              pos++; // accept character into literal\n            }\n\n            if (endPos == -1) { // reached end of NVString without terminator\n              endPos = pos; // exclusive\n            }\n            this._addToken(TKN_LITERAL,\n              nvString.substring(startPos, endPos).trim());\n            break;\n          }\n        }\n      }\n    }\n    // Add TKN_EOS as the last token in token list.\n    this._addToken(TKN_EOS, TKN_EOS_VALUE);\n    return true;\n  }\n  /**\n   * Returns current token. Throws Error if no string has\n   * been parsed, or if there are no tokens left. Does NOT advance\n   * the token position.\n   */\n  getToken() {\n    if (this.tkType == null) { // nothing parsed\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n    }\n    if (this.tkPos < this.numTokens) {// are there tokens left?\n      return Number(this.tkType[this.tkPos]);\n    } else {\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n    }\n  }\n\n  /**\n   * Returns current token. Throws Error if no string has\n   * been parsed, or if there are no tokens left. DOES advance the\n   * token position.\n   */\n  popToken() {\n    let token = TKN_NONE;\n\n    if (this.tkType == null) {\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n    }\n    if (this.tkPos < this.numTokens) { // if parsed and tokens left\n      token = Number(this.tkType[this.tkPos++]);\n    } else {\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n    }\n    return token;\n  }\n  /**\n   * Returns literal for current token. If current token is NOT a TKN_LITERAL,\n   * it returns a string representation of the current token. Throws\n   * Error if no string has been parsed, or\n   * if there are no tokens left.\n   *\n   * DOES NOT advance the token position.\n   */\n  getLiteral() {\n    let theLiteral = null;\n    if (this.tkValue == null) {\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n    }\n    // If we have parsed an NV string AND we have tokens left\n    if (this.tkPos < this.numTokens) {\n      theLiteral = String(this.tkValue[this.tkPos]);\n    } else {\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n    }\n    return theLiteral;\n  }\n\n  /**\n   * Returns literal for current token. If current token is NOT a TKN_LITERAL,\n   * it returns a string representation of the current token. Throws\n   * Error if no string has been parsed, or\n   * if there are no tokens left.\n   *\n   * DOES advance the token position.\n   */\n  popLiteral() {\n    let theLiteral = null;\n\n    if (this.tkValue == null) {\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n    }\n    // If we have parsed an NV string AND we have tokens left.\n    if (this.tkPos < this.numTokens) {\n      theLiteral = String(this.tkValue[this.tkPos++]);\n    } else {\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n    }\n    return theLiteral;\n  }\n\n  /**\n   * Advances the token position by one.\n   */\n  eatToken() {\n    if (this.tkPos < this.numTokens) {\n      this.tkPos++;\n    }\n  }\n\n  /**\n   * Returns NVTokens list as a readable String.\n   */\n  toString() {\n    if (this.tkType == null) {\n      return \"*NO TOKENS*\";\n    }\n    let out = \"Tokens\";\n    for (let i = 0; i < this.numTokens; i++) {\n      out = out + \" : \" + this.tkValue[i];\n    }\n    return out;\n  }\n  /*\n   * function to add a token and corresponding printable version (i.e.,\n   * TKN_LPAREN and TKN_LPAREN_VALUE) into the token list.\n   */\n  _addToken(tk, tk_val) {\n    this.tkType.push(Number(tk));\n    this.tkValue.push(String(tk_val));\n    this.numTokens++;\n  }\n}\n\n\n\n\n/**\n * The NVFactory class is used to help interpret the tokens generated by\n * NVTokens from an NVString.\n */\n\n\n/**\n  * Returns an NVPair which contains the broken-down form of nvString\n  * @param  nvString  the nvString to parse\n  */\nfunction createNVPair(nvString) {\n  const nvt = new NVTokens();\n  nvt.parseTokens(nvString);\n  return readTopLevelNVPair(nvt);\n}\n\n/*\n  * function which returns a top-level NVPair from NVTokens.\n  * NVPair: (name=value)\n  * value: atom | NVList\n  */\nfunction readTopLevelNVPair(nvt) {\n  //check for opening (\n  let tk = nvt.getToken();\n  nvt.eatToken();\n  if (tk != TKN_LPAREN) {\n    errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n  }\n\n  let name = readNVLiteral(nvt);\n  const nvp = new NVPair(name);\n\n  if ((tk = nvt.getToken()) == TKN_COMMA) {\n    // read comma'ed names as one name\n    while (tk == TKN_LITERAL || tk == TKN_COMMA) {\n      name += nvt.popLiteral();\n      tk = nvt.getToken();\n    }\n    nvp.name = name;\n\n    return readRightHandSide(nvp, nvt);\n  }\n\n  return readRightHandSide(nvp, nvt);\n}\n/*\n * function which returns the next NVPair from NVTokens.\n *   NVPair: (name=value) | (name, | ,name) | ,name,\n *   value: atom | NVList\n */\nfunction readNVPair(nvt) {\n  // Opening ( or , for NVPair\n  const tk = nvt.getToken();\n  nvt.eatToken();\n  if (!((tk == TKN_LPAREN) || (tk == TKN_COMMA))) {\n    errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n  }\n\n  const name = readNVLiteral(nvt);\n  const nvp = new NVPair(name);\n\n  return readRightHandSide(nvp, nvt);\n}\n\n/*\n* function which reads rhs and returns NVPair from NVTokens.\n * NVPair: (name=value)\n * value: atom | NVList\n*/\nfunction readRightHandSide(nvp, nvt) {\n  let tk = nvt.getToken();\n  switch (tk) {\n    case TKN_EQUAL:\n      nvt.eatToken();\n\n      // If the next token after \"=\" is a LITERAL, then read an atom,\n      // otherwise read an NVList.\n      tk = nvt.getToken();\n      if (tk == TKN_LITERAL) {\n        const value = readNVLiteral(nvt);\n        nvp.setAtom = value;\n      } else {\n        // NVList is responsible for adding child NVPairs to this parent\n        // NVPair.\n        readNVList(nvt, nvp);\n      }\n      break;\n\n    case TKN_COMMA:\n    case TKN_RPAREN:\n\n      // If we get a \"comma\" or \")\", then we need to parse a list of values.\n      // eg, \"(x=(value1, value2,...))\" or \"(x=(value))\"\n      nvp.setAtom = nvp.name;\n      break;\n\n    default:\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n  }\n\n  // terminating \")\" or \",\" for NVPair\n  tk = nvt.getToken();\n  if (tk == TKN_RPAREN) {\n    nvt.eatToken();\n  } else if (tk != TKN_COMMA) {\n    errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n  }\n\n  return nvp;\n}\n/*\n * function which returns the next literal from NVTokens.\n */\nfunction readNVLiteral(nvt) {\n  const tk = nvt.getToken();\n  if (tk != TKN_LITERAL) {\n    errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_SYNTAX);\n  }\n  return nvt.popLiteral();\n}\n\n/*\n * function which adds a list of NVPairs to a parent NVPair.\n *   NVList:  NVPair NVList | epsilon\n */\nfunction readNVList(nvt, parent) {\n  // if next token is \"(\" or \",\", then read an NVPair\n  // otherwise, assume epsilon\n  const tk = nvt.getToken();\n  if (!(tk == TKN_LPAREN || tk == TKN_COMMA)) {\n    return; // didn't read an nvpair\n  }\n\n  const child = readNVPair(nvt);\n\n  // read a good NVPair\n  parent.addListElement(child);\n  if ((tk == TKN_COMMA) || (child.name == child.atom)) {\n    if (parent.getListType != LIST_COMMASEP) // if not already set\n      parent.setListType = LIST_COMMASEP;    // set it\n  }\n\n  readNVList(nvt, parent);  // next iteration of NVList()\n}\n\n/**\n  * Returns a NVPair whose name matches (ignoring case) the specified\n  * name.  This function does search recursively through all descendents\n  * of the specified NVPair.\n  * @param  nvp  NVPair to search through\n  * @param  name  name to match (ignoring case)\n  */\nfunction findNVPairRecurse(nvp, name) {\n  /* Is the base NV Pair the name we are looking for?                    */\n  if (!nvp) {\n    return null;\n  }\n  if ((name.toUpperCase() == (nvp.name).toUpperCase()))\n    return nvp;\n\n  /* Do we have anywhere else to search (ie, is nvp a list)?               */\n  if (nvp.getRHSType == RHS_ATOM)\n    return null;\n\n  /* Loop thru the list of children and searching each child for name.     */\n  for (let i = 0; i < nvp.getListSize(); i++) {\n    const child = findNVPairRecurse(nvp.getListElement(i), name);\n\n    /* Did we find \"name\"?                                                 */\n    if (child !== null)\n      return child;\n  }\n\n  return null;\n}\n\n/**\n  * Returns a NVPair whose name matches (ignoring case) the specified\n  * name. This functions only searches the direct descendants of specified NVPair\n  * @param  nvp  NVPair to search through\n  * @param  name  name to match (ignoring case)\n  */\nfunction findNVPair(nvp, name) {\n  if (!nvp) {\n    return null;\n  }\n\n  /* Do we have anywhere else to search (ie, is nvp a list)?               */\n  if (nvp.getRHSType == RHS_ATOM)\n    return null;\n\n  /* Loop thru the list of children and searching each child for name.     */\n  for (let i = 0; i < nvp.getListSize(); i++) {\n    const child = nvp.getListElement(i);\n    if (name.toUpperCase() == (child.name).toUpperCase())\n      return child;\n  }\n  return null;\n}\n\n/**\n  * Returns a value which matches the specified path\n  * @param  nvp  NVPair to search through\n  * @param  name  array of names to match (ignoring case)\n  */\nfunction findValue(nvp, names) {\n  if (!nvp) {\n    return null;\n  }\n\n  /* Is the base NV Pair the first name in path */\n  if ((names[0].toUpperCase() != (nvp.name).toUpperCase()))\n    return null;\n\n  let output = nvp;\n  const sze = names.length;\n\n  for (let i = 1; i < sze; i++) {\n    output = findNVPair(output, names[i]);\n    if (!output)\n      return null;\n  }\n  if (output.atom == null) {\n    if (output.list == null)\n      return null;\n    else\n      return (output.list).toString();\n  } else {\n    return (output.atom).toString();\n  }\n}\nmodule.exports = {findNVPairRecurse, createNVPair, findNVPair, findValue};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}