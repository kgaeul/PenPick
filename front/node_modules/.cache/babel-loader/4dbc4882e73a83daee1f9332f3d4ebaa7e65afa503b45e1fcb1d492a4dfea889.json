{"ast":null,"code":"// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\nconst ConnectionImpl = require('../impl/connection.js');\nconst ThinResultSetImpl = require('./resultSet.js');\nconst ThinLobImpl = require(\"./lob.js\");\nconst Protocol = require(\"./protocol/protocol.js\");\nconst {\n  BaseBuffer\n} = require('./protocol/buffer.js');\nconst {\n  NetworkSession: nsi\n} = require(\"./sqlnet/networkSession.js\");\nconst {\n  Statement\n} = require(\"./statement\");\nconst thinUtil = require('./util');\nconst sqlNetConstants = require('./sqlnet/constants.js');\nconst constants = require('./protocol/constants.js');\nconst process = require('process');\nconst types = require('../types.js');\nconst errors = require(\"../errors.js\");\nconst messages = require('./protocol/messages');\nconst finalizationRegistry = new global.FinalizationRegistry(heldValue => {\n  heldValue.disconnect();\n});\nclass TDSBuffer extends BaseBuffer {}\nconst connectionCookies = new Map();\nclass ThinConnectionImpl extends ConnectionImpl {\n  /**\n   * Terminates the connection\n   *\n   * @return {Promise}\n   */\n  async close() {\n    try {\n      if (this._protocol.txnInProgress) {\n        await this.rollback();\n      }\n      this._protocol.callTimeout = 0; // not applicable for close\n      if (this._drcpEnabled) {\n        await this._sessRelease();\n        this._drcpEstablishSession = true;\n      }\n      if (this._pool && !this._dropSess) {\n        await this._pool.release(this);\n      } else {\n        if (!this._drcpEnabled) {\n          const message = new messages.LogOffMessage(this);\n          await this._protocol._processMessage(message);\n        }\n        this.nscon.disconnect();\n      }\n    } catch (err) {\n      // immediate close of open socket on failure\n      // exception won't be thrown to user\n      this.nscon.disconnect(sqlNetConstants.NSFIMM);\n    }\n  }\n  async _sessRelease() {\n    const message = new messages.SessionReleaseMessage(this);\n    if (!this.isPooled()) {\n      message.sessReleaseMode = constants.DRCP_DEAUTHENTICATE;\n    }\n    await this._protocol._processMessage(message);\n  }\n\n  //---------------------------------------------------------------------------\n  // _determineElementObjType()\n  //\n  // Determine the element type's object type. This is needed when processing\n  // collections with an object as the element type since this information is\n  // not available in the TDS.\n  //---------------------------------------------------------------------------\n  async _determineElementObjType(info) {\n    const binds = [{\n      name: \"owner\",\n      type: types.DB_TYPE_VARCHAR,\n      dir: constants.BIND_IN,\n      maxSize: 128,\n      values: [info.schema]\n    }, {\n      name: \"name\",\n      type: types.DB_TYPE_VARCHAR,\n      dir: constants.BIND_IN,\n      maxSize: 128,\n      values: [info.name]\n    }, {\n      name: \"package_name\",\n      type: types.DB_TYPE_VARCHAR,\n      dir: constants.BIND_IN,\n      maxSize: 128,\n      values: [info.packageName]\n    }];\n    let sql;\n    if (info.packageName) {\n      sql = `\n        select\n            elem_type_owner,\n            elem_type_name,\n            elem_type_package\n        from all_plsql_coll_types\n        where owner = :owner\n          and type_name = :name\n          and package_name = :package_name`;\n    } else {\n      binds.pop();\n      sql = `\n        select\n            elem_type_owner,\n            elem_type_name\n        from all_coll_types\n        where owner = :owner\n          and type_name = :name`;\n    }\n    const options = {\n      connection: {\n        _impl: this\n      },\n      prefetchRows: 2\n    };\n    const result = await this.execute(sql, 1, binds, options, false);\n    const rows = await result.resultSet.getRows(1, options);\n    await result.resultSet.close();\n    const row = rows[0];\n    info.elementTypeClass = this._getDbObjectType(row[0], row[1], row[2]);\n    if (info.elementTypeClass.partial) {\n      this._partialDbObjectTypes.push(info.elementTypeClass);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _execute()\n  //\n  // Calls the RPC that executes a SQL statement and returns the results.\n  //---------------------------------------------------------------------------\n  async _execute(statement, numIters, binds, options, executeManyFlag) {\n    // perform binds\n    const numBinds = statement.bindInfoList.length;\n    const numVars = binds.length;\n    if (numBinds !== numVars && (numVars === 0 || !binds[0].name)) {\n      errors.throwErr(errors.ERR_WRONG_NUMBER_OF_POSITIONAL_BINDS, numBinds, numVars);\n    }\n    for (let i = 0; i < binds.length; i++) {\n      await this._bind(statement, binds[i], i + 1);\n    }\n    if (statement.isPlSql && (options.batchErrors || options.dmlRowCounts)) {\n      errors.throwErr(errors.ERR_EXEC_MODE_ONLY_FOR_DML);\n    }\n\n    // send database request\n    const message = new messages.ExecuteMessage(this, statement, options);\n    message.numExecs = numIters;\n    message.arrayDmlRowCounts = options.dmlRowCounts;\n    message.batchErrors = options.batchErrors;\n    if (statement.isPlSql && statement.requiresFullExecute) {\n      message.numExecs = 1;\n      await this._protocol._processMessage(message);\n      statement.requiresFullExecute = false;\n      message.numExecs = numIters - 1;\n      message.offset = 1;\n    }\n    if (message.numExecs > 0) {\n      await this._protocol._processMessage(message);\n      statement.requiresFullExecute = false;\n    }\n\n    // if a define is required, send an additional request to the database\n    if (statement.requiresDefine && statement.sql) {\n      statement.requiresFullExecute = true;\n      await this._protocol._processMessage(message);\n      statement.requiresFullExecute = false;\n      statement.requiresDefine = false;\n    }\n\n    // process results\n    const result = {};\n    if (message.warning) {\n      result.warning = message.warning;\n    }\n    if (statement.numQueryVars > 0) {\n      result.resultSet = message.resultSet;\n    } else {\n      statement.bufferRowIndex = 0;\n      const outBinds = thinUtil.getOutBinds(statement, numIters, executeManyFlag);\n      if (outBinds) {\n        result.outBinds = outBinds;\n      }\n      if (executeManyFlag) {\n        if (!statement.isPlSql) {\n          result.rowsAffected = statement.rowCount;\n          delete statement.rowCount;\n        }\n        if (options.dmlRowCounts) {\n          result.dmlRowCounts = options.dmlRowCounts;\n        }\n        if (options.batchErrors) {\n          result.batchErrors = options.batchErrors;\n        }\n      } else {\n        if (statement.isPlSql && options.implicitResultSet) {\n          result.implicitResults = options.implicitResultSet;\n        }\n        if (statement.lastRowid) {\n          result.lastRowid = statement.lastRowid;\n          delete statement.lastRowid;\n        }\n        if (statement.isPlSql) {\n          if (statement.rowCount) {\n            result.rowsAffected = statement.rowCount;\n          }\n        } else {\n          result.rowsAffected = statement.rowCount || 0;\n        }\n        if (statement.rowCount) {\n          delete statement.rowCount;\n        }\n      }\n      this._returnStatement(statement);\n    }\n    return result;\n  }\n\n  //---------------------------------------------------------------------------\n  // _parseElementType()\n  //\n  // Parses the element type from the TDS buffer.\n  //---------------------------------------------------------------------------\n  async _parseElementType(buf, info) {\n    let oraTypeNum, csfrm;\n    const attrType = buf.readUInt8();\n    switch (attrType) {\n      case constants.TNS_OBJ_TDS_TYPE_NUMBER:\n      case constants.TNS_OBJ_TDS_TYPE_FLOAT:\n        info.elementType = types.DB_TYPE_NUMBER;\n        break;\n      case constants.TNS_OBJ_TDS_TYPE_VARCHAR:\n      case constants.TNS_OBJ_TDS_TYPE_CHAR:\n        info.maxSize = buf.readUInt16BE();\n        oraTypeNum = attrType === constants.TNS_OBJ_TDS_TYPE_VARCHAR ? constants.TNS_DATA_TYPE_VARCHAR : constants.TNS_DATA_TYPE_CHAR;\n        csfrm = buf.readUInt8();\n        info.elementType = types.getTypeByOraTypeNum(oraTypeNum, csfrm);\n        break;\n      case constants.TNS_OBJ_TDS_TYPE_RAW:\n        info.elementType = types.DB_TYPE_RAW;\n        break;\n      case constants.TNS_OBJ_TDS_TYPE_BINARY_FLOAT:\n        info.elementType = types.DB_TYPE_BINARY_FLOAT;\n        break;\n      case constants.TNS_OBJ_TDS_TYPE_BINARY_DOUBLE:\n        info.elementType = types.DB_TYPE_BINARY_DOUBLE;\n        break;\n      case constants.TNS_OBJ_TDS_TYPE_DATE:\n        info.elementType = types.DB_TYPE_DATE;\n        break;\n      case constants.TNS_OBJ_TDS_TYPE_TIMESTAMP:\n        info.elementType = types.DB_TYPE_TIMESTAMP;\n        break;\n      case constants.TNS_OBJ_TDS_TYPE_TIMESTAMP_LTZ:\n        info.elementType = types.DB_TYPE_TIMESTAMP_LTZ;\n        break;\n      case constants.TNS_OBJ_TDS_TYPE_TIMESTAMP_TZ:\n        info.elementType = types.DB_TYPE_TIMESTAMP_TZ;\n        break;\n      case constants.TNS_OBJ_TDS_TYPE_BOOLEAN:\n        info.elementType = types.DB_TYPE_BOOLEAN;\n        break;\n      case constants.TNS_OBJ_TDS_TYPE_CLOB:\n        this._determineElementTypeCharsetForm(info);\n        break;\n      case constants.TNS_OBJ_TDS_TYPE_BLOB:\n        info.elementType = types.DB_TYPE_BLOB;\n        break;\n      case constants.TNS_OBJ_TDS_TYPE_OBJ:\n        info.elementType = types.DB_TYPE_OBJECT;\n        await this._determineElementObjType(info);\n        break;\n      default:\n        errors.throwErr(errors.ERR_TDS_TYPE_NOT_SUPPORTED, attrType);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _parseTDS()\n  //\n  // Parses the TDS for the type. This is only needed for collection types, so\n  // if the TDS is determined to be for an object type, the remaining\n  // information is ignored.\n  //---------------------------------------------------------------------------\n  async _parseTDS(tds, info) {\n    // parse initial TDS bytes\n    const buf = new TDSBuffer(tds);\n    buf.skipBytes(4); // end offset\n    buf.skipBytes(2); // version op code and version\n    buf.skipBytes(2); // unknown\n\n    // if the number of attributes exceeds 1, the type cannot refer to a\n    // collection, so nothing further needs to be done\n    const numAttrs = buf.readUInt16BE();\n    if (numAttrs > 1) {\n      info.isCollection = false;\n      return;\n    }\n\n    // continue parsing TDS bytes to discover if type refers to a collection\n    buf.skipBytes(1); // TDS attributes?\n    buf.skipBytes(1); // start ADT op code\n    buf.skipBytes(2); // ADT number (always zero)\n    buf.skipBytes(4); // offset to index table\n\n    // if type of first attribute is not a collection, nothing further needs\n    // to be done\n    const attrType = buf.readUInt8();\n    info.isCollection = attrType === constants.TNS_OBJ_TDS_TYPE_COLL;\n    if (!info.isCollection) return;\n\n    // continue parsing TDS to determine element type\n    const elementPos = buf.readUInt32BE();\n    info.maxNumElements = buf.readUInt32BE();\n    info.collectionType = buf.readUInt8();\n    if (info.collectionType === constants.TNS_OBJ_PLSQL_INDEX_TABLE) {\n      info.collectionFlags = constants.TNS_OBJ_HAS_INDEXES;\n    }\n    buf.pos = elementPos;\n    await this._parseElementType(buf, info);\n  }\n\n  //---------------------------------------------------------------------------\n  // _populateDbObjectTypeInfo()\n  //\n  // Poplates type information given the name of the type.\n  //---------------------------------------------------------------------------\n  async _populateDbObjectTypeInfo(name) {\n    // get type information from the database\n    const sql = `\n      declare\n          t_Instantiable              varchar2(3);\n          t_SuperTypeOwner            varchar2(128);\n          t_SuperTypeName             varchar2(128);\n          t_SubTypeRefCursor          sys_refcursor;\n          t_Pos                       pls_integer;\n      begin\n          :ret_val := dbms_pickler.get_type_shape(:full_name, :oid,\n              :version, :tds, t_Instantiable, t_SuperTypeOwner,\n              t_SuperTypeName, :attrs_rc, t_SubTypeRefCursor);\n          :package_name := null;\n          if substr(:full_name, length(:full_name) - 7) = '%ROWTYPE' then\n              t_Pos := instr(:full_name, '.');\n              :schema := substr(:full_name, 1, t_Pos - 1);\n              :name := substr(:full_name, t_Pos + 1);\n          else\n              begin\n                  select owner, type_name\n                  into :schema, :name\n                  from all_types\n                  where type_oid = :oid;\n              exception\n              when no_data_found then\n                  begin\n                      select owner, package_name, type_name\n                      into :schema, :package_name, :name\n                      from all_plsql_types\n                      where type_oid = :oid;\n                  exception\n                  when no_data_found then\n                      null;\n                  end;\n              end;\n          end if;\n      end;`;\n    const binds = [{\n      name: \"full_name\",\n      type: types.DB_TYPE_VARCHAR,\n      dir: constants.BIND_INOUT,\n      maxSize: 500,\n      values: [name]\n    }, {\n      name: \"ret_val\",\n      type: types.DB_TYPE_BINARY_INTEGER,\n      dir: constants.BIND_OUT,\n      values: []\n    }, {\n      name: \"oid\",\n      type: types.DB_TYPE_RAW,\n      maxSize: 16,\n      dir: constants.BIND_OUT,\n      values: []\n    }, {\n      name: \"version\",\n      type: types.DB_TYPE_BINARY_INTEGER,\n      dir: constants.BIND_OUT,\n      values: []\n    }, {\n      name: \"tds\",\n      type: types.DB_TYPE_RAW,\n      maxSize: 2000,\n      dir: constants.BIND_OUT,\n      values: []\n    }, {\n      name: \"attrs_rc\",\n      type: types.DB_TYPE_CURSOR,\n      dir: constants.BIND_OUT,\n      values: []\n    }, {\n      name: \"package_name\",\n      type: types.DB_TYPE_VARCHAR,\n      maxSize: 128,\n      dir: constants.BIND_OUT,\n      values: []\n    }, {\n      name: \"schema\",\n      type: types.DB_TYPE_VARCHAR,\n      maxSize: 128,\n      dir: constants.BIND_OUT,\n      values: []\n    }, {\n      name: \"name\",\n      type: types.DB_TYPE_VARCHAR,\n      maxSize: 128,\n      dir: constants.BIND_OUT,\n      values: []\n    }];\n    const options = {\n      connection: {\n        _impl: this\n      },\n      nullifyInvalidCursor: true\n    };\n    const result = await this.execute(sql, 1, binds, options, false);\n    if (result.outBinds.ret_val !== 0) {\n      errors.throwErr(errors.ERR_INVALID_OBJECT_TYPE_NAME, name);\n    }\n\n    // check cache; if already present, nothing more to do!\n    const info = this._getDbObjectType(result.outBinds.schema, result.outBinds.name, result.outBinds.package_name, result.outBinds.oid);\n    if (!info.partial) return info;\n\n    // process TDS and attributes cursor\n    info.version = result.outBinds.version;\n    await this._parseTDS(result.outBinds.tds, info);\n    const attrRows = await result.outBinds.attrs_rc.getRows(1000, {});\n    if (attrRows.length > 0) {\n      info.attributes = [];\n      for (const row of attrRows) {\n        const attr = {\n          name: row[1]\n        };\n        if (row[4]) {\n          attr.type = types.DB_TYPE_OBJECT;\n          attr.typeClass = this._getDbObjectType(row[4], row[3], row[5], row[6]);\n          if (attr.typeClass.partial) {\n            this._partialDbObjectTypes.push(attr.typeClass);\n          }\n        } else {\n          attr.type = types.getTypeByColumnTypeName(row[3]);\n        }\n        info.attributes.push(attr);\n      }\n    }\n    info.partial = false;\n    return info;\n  }\n\n  //---------------------------------------------------------------------------\n  // _populatePartialDbObjectTypes()\n  //\n  // Populates partial types that were discovered earlier. Since populating an\n  // object type might result in additional object types being discovered,\n  // object types are popped from the partial types list until the list is\n  // empty.\n  //---------------------------------------------------------------------------\n  async _populatePartialDbObjectTypes() {\n    while (this._partialDbObjectTypes.length > 0) {\n      const info = this._partialDbObjectTypes.pop();\n      let suffix = \"%ROWTYPE\";\n      let name = info.name;\n      if (name.endsWith(suffix)) {\n        name = name.substring(0, name.length - suffix.length);\n      } else {\n        suffix = \"\";\n      }\n      let fullName;\n      if (info.packageName) {\n        fullName = `\"${info.schema}\".\"${info.packageName}\".\"${name}\"${suffix}`;\n      } else {\n        fullName = `\"${info.schema}\".\"${name}\"${suffix}`;\n      }\n      await this._populateDbObjectTypeInfo(fullName);\n    }\n  }\n  async commit() {\n    const message = new messages.CommitMessage(this);\n    await this._protocol._processMessage(message);\n  }\n  async breakExecution() {\n    await this._protocol.breakMessage();\n  }\n  isHealthy() {\n    try {\n      if (this.nscon.recvInbandNotif() === 0) return true;\n      return false;\n    } catch {\n      return false;\n    }\n  }\n  isPooled() {\n    return this._pool ? true : false;\n  }\n\n  //---------------------------------------------------------------------------\n  // getConnectionCookieByUUID()\n  //\n  // It fetches from map which keeps keyname as UUID+ServiceName.\n  // UUID identifies the CDB instance and ServiceName identifies the\n  // entity within a PDB which uniquely identifies a pdb instance.\n  //---------------------------------------------------------------------------\n  getConnectionCookieByUUID(uuid) {\n    let cookie;\n    if (uuid) {\n      const key = uuid + (this.serviceName ? this.serviceName : this.sid);\n      cookie = connectionCookies.get(key);\n      if (!cookie) {\n        cookie = {};\n        connectionCookies.set(key, cookie);\n      }\n    }\n    return cookie;\n  }\n\n  /**\n   *\n   * @param {object} params  Configuration of the connection\n   *\n   * @return {Promise}\n   */\n  async connect(params) {\n    if (!params.connectString) {\n      errors.throwErr(errors.ERR_EMPTY_CONNECT_STRING);\n    }\n    thinUtil.checkCredentials(params);\n    this.sessionID = 0;\n    this.serialNum = 0;\n    this.autoCommit = false;\n    this.serverVersion = \"\";\n    this.statementCache = null;\n    this.currentSchema = \"\";\n    this.invokeSessionCallback = true;\n    this.statementCache = new Map();\n    this.statementCacheSize = params.stmtCacheSize;\n    this._numCursorsToClose = 0;\n    this._currentSchemaModified = false;\n    this._cursorsToClose = new Set();\n    this._tempLobsToClose = [];\n    this._tempLobsTotalSize = 0;\n    this._drcpEstablishSession = false;\n    this._cclass = null;\n    this._clientIdentifier = \"\";\n    this._clientIdentifierModified = false;\n    this._action = \"\";\n    this._actionModified = false;\n    this._dbOp = \"\";\n    this._dbOpModified = false;\n    this._clientInfo = \"\";\n    this._clientInfoModified = false;\n    this._module = \"\";\n    this._moduleModified = false;\n    this._drcpEnabled = false;\n    this.serviceName = '';\n    this.remoteAddress = '';\n    this.comboKey = null; // used in changePassword API\n\n    this.nscon = new nsi();\n    finalizationRegistry.register(this, this.nscon);\n    await this.nscon.connect(params);\n    let serverType;\n    if (this.isPooled()) {\n      serverType = params._connInfo[0];\n      this.serviceName = params._connInfo[2];\n      this.purity = params._connInfo[3] | constants.PURITY_DEFAULT;\n      this.sid = params._connInfo[4];\n    } else {\n      serverType = this.nscon.getOption(sqlNetConstants.SERVERTYPE);\n      this.serviceName = this.nscon.getOption(sqlNetConstants.SVCNAME);\n      this.sid = this.nscon.getOption(sqlNetConstants.SID);\n      this.purity = this.nscon.getOption(sqlNetConstants.PURITY) | constants.PURITY_DEFAULT;\n    }\n    if (serverType) {\n      this._drcpEnabled = serverType.toLowerCase() === 'pooled';\n    }\n    this.remoteAddress = this.nscon.getOption(sqlNetConstants.REMOTEADDR);\n    this.connectionClass = params.connectionClass;\n\n    /*\n     * if drcp is used, use purity = NEW as the default purity for\n     * standalone connections and purity = SELF for connections that belong\n     * to a pool\n     */\n    if (this.purity === constants.PURITY_DEFAULT && this._drcpEnabled) {\n      if (this.isPooled()) {\n        this.purity = constants.PURITY_SELF;\n      } else {\n        this.purity = constants.PURITY_NEW;\n      }\n    }\n    this._protocol = new Protocol(this);\n\n    // check if the protocol version supported by the database is high\n    // enough; if not, reject the connection immediately\n    if (this._protocol.caps.protocolVersion < constants.TNS_VERSION_MIN_ACCEPTED) {\n      errors.throwErr(errors.ERR_SERVER_VERSION_NOT_SUPPORTED);\n    }\n    try {\n      const cookie = this.getConnectionCookieByUUID(this.nscon.dbUUID);\n      this.nscon.dbUUID = null;\n      const protocolMessage = new messages.ProtocolMessage(this);\n      const dataTypeMessage = new messages.DataTypeMessage(this);\n      const authMessage = new messages.AuthMessage(this, params);\n      let sentCookie = false;\n      if (cookie && cookie.populated) {\n        const cookieMessage = new messages.ConnectionCookieMessage(this);\n        cookieMessage.cookie = cookie;\n        cookieMessage.protocolMessage = protocolMessage;\n        cookieMessage.dataTypeMessage = dataTypeMessage;\n        cookieMessage.authMessage = authMessage;\n        await this._protocol._processMessage(cookieMessage);\n        sentCookie = true;\n      } else {\n        await this._protocol._processMessage(protocolMessage);\n      }\n      if (!sentCookie || !cookie.populated) {\n        await this._protocol._processMessage(dataTypeMessage);\n        // Does OSESSKEY for non-token Authentication else OAUTH\n        await this._protocol._processMessage(authMessage);\n        if (cookie && !cookie.populated) {\n          cookie.protocolVersion = protocolMessage.serverVersion;\n          cookie.serverBanner = protocolMessage.serverBanner;\n          cookie.charsetID = this._protocol.caps.charSetID;\n          cookie.ncharsetID = this._protocol.caps.nCharsetId;\n          cookie.flags = protocolMessage.serverFlags;\n          cookie.compileCaps = Buffer.from(protocolMessage.serverCompileCaps);\n          cookie.runtimeCaps = Buffer.from(protocolMessage.serverRunTimeCaps);\n          cookie.populated = true;\n        }\n      }\n      if (!params.token) {\n        // non-token Authentication\n        await this._protocol._processMessage(authMessage); // OAUTH\n      }\n    } catch (err) {\n      this.nscon.disconnect();\n      throw err;\n    }\n\n    // maintain a list of partially populated database object types\n    this._partialDbObjectTypes = [];\n    if (params.debugJDWP) {\n      this.jdwpData = Buffer.from(params.debugJDWP);\n    } else if (process.env.ORA_DEBUG_JDWP) {\n      this.jdwpData = Buffer.from(process.env.ORA_DEBUG_JDWP);\n    }\n    this._protocol.connInProgress = false;\n  }\n\n  //---------------------------------------------------------------------------\n  // Sets that a statement is no longer in use\n  //---------------------------------------------------------------------------\n  _returnStatement(statement) {\n    if (statement.bindInfoList) {\n      statement.bindInfoList.forEach(bindInfo => {\n        bindInfo.bindVar = null;\n      });\n    }\n    if (statement.queryVars) {\n      statement.queryVars.forEach(queryVar => {\n        queryVar.values.fill(null);\n      });\n    }\n    if (statement.returnToCache) {\n      statement.inUse = false;\n    } else if (statement.cursorId !== 0) {\n      this._addCursorToClose(statement.cursorId);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // Adds the cursors that needs to be closed to the _cursorsToClose set\n  //---------------------------------------------------------------------------\n  _addCursorToClose(cursorId) {\n    if (this._cursorsToClose.has(cursorId)) {\n      const reason = `attempt to close cursor ${cursorId} twice`;\n      errors.throwErr(errors.ERR_INTERNAL, reason);\n    }\n    this._cursorsToClose.add(cursorId);\n  }\n\n  //---------------------------------------------------------------------------\n  // Adjusts the statement cache to remove least recently used statements\n  //---------------------------------------------------------------------------\n  _adjustStatementCache() {\n    while (this.statementCache.size > this.statementCacheSize) {\n      const sql = this.statementCache.keys().next().value;\n      const stmt = this.statementCache.get(sql);\n      this.statementCache.delete(sql);\n      if (stmt.inUse) {\n        stmt.returnToCache = false;\n      } else if (stmt.cursorId !== 0) {\n        this._addCursorToClose(stmt.cursorId);\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // Parses the sql statement and puts it into cache if keepInStmtCache\n  // option is true\n  //---------------------------------------------------------------------------\n  _prepare(sql, options) {\n    const statement = this._getStatement(sql, options.keepInStmtCache);\n    statement.bufferRowIndex = 0;\n    statement.bufferRowCount = 0;\n    statement.lastRowIndex = 0;\n    statement.moreRowsToFetch = true;\n    return statement;\n  }\n\n  //---------------------------------------------------------------------------\n  // Binds the values by user to the statement object\n  //---------------------------------------------------------------------------\n  async _bind(stmt, variable, pos = 0) {\n    const bindInfoDict = stmt.bindInfoDict;\n    const bindInfoList = stmt.bindInfoList;\n\n    /*\n     * For PL/SQL blocks, if the size of a string or bytes object exceeds\n     * 32,767 bytes it is converted to a BLOB/CLOB; and conversion\n     * needs to be established as well to return the string in the way that\n     * the user expects to get it\n     */\n    if (stmt.isPlSql && variable.maxSize > 32767) {\n      if (variable.type === types.DB_TYPE_RAW || variable.type === types.DB_TYPE_LONG_RAW) {\n        variable.type = types.DB_TYPE_BLOB;\n      } else if (variable.type._csfrm === constants.CSFRM_NCHAR) {\n        variable.type = types.DB_TYPE_NCLOB;\n      } else {\n        variable.type = types.DB_TYPE_CLOB;\n      }\n      const maxSize = variable.maxSize;\n      delete variable.maxSize;\n      variable.outConverter = async function (val) {\n        if (val === null) {\n          return null;\n        }\n        const data = await val.getData();\n        const len = val._length;\n        if (data && len > maxSize) {\n          errors.throwErr(errors.ERR_INSUFFICIENT_BUFFER_FOR_BINDS);\n        }\n        return data;\n      };\n    }\n    if (variable.type === types.DB_TYPE_CLOB || variable.type === types.DB_TYPE_NCLOB || variable.type === types.DB_TYPE_BLOB) {\n      for (const [index, val] of variable.values.entries()) {\n        if (!(val instanceof ThinLobImpl)) {\n          if (val && val.length > 0) {\n            const lobImpl = new ThinLobImpl();\n            await lobImpl.create(this, variable.type);\n            await lobImpl.write(1, val);\n            variable.values[index] = lobImpl;\n          } else {\n            variable.values[index] = null;\n          }\n        }\n      }\n    }\n    if (variable.name) {\n      let normalizedName;\n      if (variable.name.startsWith('\"') && variable.name.endsWith('\"')) {\n        normalizedName = variable.name.substring(1, variable.name.length - 1);\n      } else {\n        normalizedName = variable.name.toUpperCase();\n      }\n      if (normalizedName.startsWith(':')) {\n        normalizedName = variable.name.substring(1);\n      }\n      if (!bindInfoDict.has(normalizedName)) {\n        errors.throwErr(errors.ERR_INVALID_BIND_NAME, normalizedName);\n      }\n      bindInfoDict.get(normalizedName).forEach(bindInfo => {\n        stmt._setVariable(bindInfo, variable);\n      });\n    } else {\n      const bindInfo = bindInfoList[pos - 1];\n      stmt._setVariable(bindInfo, variable);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _createResultSet()\n  //\n  // Creates a result set and performs any necessary initialization.\n  //---------------------------------------------------------------------------\n  _createResultSet(options, statement) {\n    const resultSet = new ThinResultSetImpl();\n    if (!statement) {\n      statement = new Statement();\n    }\n    resultSet._resultSetNew(this, statement, options);\n    if (statement.queryVars.length > 0) {\n      const metadata = thinUtil.getMetadataMany(statement.queryVars);\n      resultSet._setup(options, metadata);\n    }\n    return resultSet;\n  }\n\n  //---------------------------------------------------------------------------\n  // Clears the statement cache for the connection\n  //---------------------------------------------------------------------------\n  resetStatementCache() {\n    this.statementCache.clear();\n    this._cursorsToClose.clear();\n  }\n\n  //---------------------------------------------------------------------------\n  // getDbObjectClass()\n  //\n  // Returns a database object class given its name.\n  //---------------------------------------------------------------------------\n  async getDbObjectClass(name) {\n    const info = await this._populateDbObjectTypeInfo(name);\n    await this._populatePartialDbObjectTypes();\n    return info;\n  }\n\n  //---------------------------------------------------------------------------\n  // getStatementInfo()\n  //\n  // Parses the SQL statement and returns information about the statement.\n  //---------------------------------------------------------------------------\n  async getStatementInfo(sql) {\n    const options = {};\n    const result = {};\n    const statement = this._prepare(sql, options);\n    options.connection = this;\n    try {\n      if (!statement.isDdl) {\n        const message = new messages.ExecuteMessage(this, statement, options);\n        message.parseOnly = true;\n        await this._protocol._processMessage(message);\n      }\n      if (statement.numQueryVars > 0) {\n        result.metaData = thinUtil.getMetadataMany(statement.queryVars);\n      }\n      result.bindNames = Array.from(statement.bindInfoDict.keys());\n      result.statementType = statement.statementType;\n      return result;\n    } finally {\n      this._returnStatement(statement);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // execute()\n  //\n  // Calls the RPC that executes a SQL statement and returns the results.\n  //---------------------------------------------------------------------------\n  async execute(sql, numIters, binds, options, executeManyFlag) {\n    const statement = this._prepare(sql, options);\n    try {\n      return await this._execute(statement, numIters, binds, options, executeManyFlag);\n    } catch (err) {\n      this._returnStatement(statement);\n      throw err;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // Get the statement object from the statement cache for the SQL if it exists\n  // else prepare a new statement object for the SQL. If a statement is already\n  // in use a copy will be made and returned (and will not be returned to the\n  // cache). If a statement is being executed for the first time after releasing\n  // a DRCP session, a copy will also be made (and will not be returned to the\n  // cache) since it is unknown at this point whether the original session or a\n  // new session is going to be used.\n  //---------------------------------------------------------------------------\n  _getStatement(sql, cacheStatement = false) {\n    let statement = this.statementCache.get(sql);\n    if (!statement) {\n      statement = new Statement();\n      statement._prepare(sql);\n      if (cacheStatement && !this._drcpEstablishSession && !statement.isDdl && this.statementCacheSize > 0) {\n        statement.returnToCache = true;\n        this.statementCache.set(sql, statement);\n        this._adjustStatementCache();\n      }\n    } else if (statement.inUse || !cacheStatement || this._drcpEstablishSession) {\n      if (!cacheStatement) {\n        this.statementCache.delete(sql);\n        statement.returnToCache = false;\n      }\n      if (statement.inUse || this._drcpEstablishSession) {\n        statement = statement._copy();\n      }\n    } else {\n      this.statementCache.delete(sql);\n      this.statementCache.set(sql, statement);\n    }\n    statement.inUse = true;\n    return statement;\n  }\n\n  //---------------------------------------------------------------------------\n  // Calls the ping RPC for Oracle Database\n  //---------------------------------------------------------------------------\n  async ping() {\n    const message = new messages.PingMessage(this);\n    await this._protocol._processMessage(message);\n  }\n\n  //---------------------------------------------------------------------------\n  // Calls the Rollback RPC for Oracle Database\n  //---------------------------------------------------------------------------\n  async rollback() {\n    const message = new messages.RollbackMessage(this);\n    await this._protocol._processMessage(message);\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the Oracle Server version\n  //---------------------------------------------------------------------------\n  getOracleServerVersion() {\n    return this.serverVersion;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the Oracle Server version string\n  //---------------------------------------------------------------------------\n  getOracleServerVersionString() {\n    return this.serverVersionString;\n  }\n  setCurrentSchema(schema) {\n    this._currentSchemaModified = true;\n    this.currentSchema = schema;\n  }\n  getCurrentSchema() {\n    return this.currentSchema;\n  }\n  setClientId(clientId) {\n    this._clientIdentifierModified = true;\n    this._clientIdentifier = clientId;\n  }\n  setDbOp(dbOp) {\n    this._dbOpModified = true;\n    this._dbOp = dbOp;\n  }\n  setClientInfo(clientInfo) {\n    this._clientInfoModified = true;\n    this._clientInfo = clientInfo;\n  }\n  setModule(module) {\n    this._moduleModified = true;\n    this._module = module;\n\n    /*\n     * setting the module by itself results in an error so always force\n     * action to be set as well (which eliminates this error)\n     */\n    this._actionModified = true;\n  }\n  setAction(action) {\n    this._actionModified = true;\n    this._action = action;\n  }\n  async changePassword(user, password, newPassword) {\n    const config = {\n      user: user,\n      newPassword: newPassword,\n      password: password,\n      changePassword: true\n    };\n    const message = new messages.AuthMessage(this, config);\n    await this._protocol._processMessage(message); // OAUTH\n  }\n  async createLob(dbType) {\n    const lobImpl = new ThinLobImpl();\n    await lobImpl.create(this, dbType);\n    return lobImpl;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the statement cache size for the statement cache maintained by\n  // the connection object\n  //---------------------------------------------------------------------------\n  getStmtCacheSize() {\n    return this.statementCacheSize;\n  }\n  setCallTimeout(timeout) {\n    this._protocol.callTimeout = timeout;\n  }\n  getCallTimeout() {\n    return this._protocol.callTimeout;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns getTag. Actual tag returned by db must be a string.\n  //---------------------------------------------------------------------------\n  getTag() {\n    return '';\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the Oracle Database instance name associated with the connection.\n  //---------------------------------------------------------------------------\n  getInstanceName() {\n    return this.instanceName;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the Oracle Database domain name associated with the connection.\n  //---------------------------------------------------------------------------\n  getDbDomain() {\n    return this.dbDomain;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the Oracle Database name associated with the connection.\n  //---------------------------------------------------------------------------\n  getDbName() {\n    return this.dbName;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns maximum number of cursors that can be opened in one session.\n  //---------------------------------------------------------------------------\n  getMaxOpenCursors() {\n    return this.maxOpenCursors;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the Oracle Database service name associated with the connection.\n  //---------------------------------------------------------------------------\n  getServiceName() {\n    return this.serviceName;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns boolean based on this._protocol.txnInProgress value.\n  //---------------------------------------------------------------------------\n  getTransactionInProgress() {\n    return this._protocol.txnInProgress === constants.TNS_TXN_IN_PROGRESS;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the warning object.\n  //---------------------------------------------------------------------------\n  getWarning() {\n    return this.warning;\n  }\n}\nmodule.exports = ThinConnectionImpl;","map":{"version":3,"names":["Buffer","require","ConnectionImpl","ThinResultSetImpl","ThinLobImpl","Protocol","BaseBuffer","NetworkSession","nsi","Statement","thinUtil","sqlNetConstants","constants","process","types","errors","messages","finalizationRegistry","global","FinalizationRegistry","heldValue","disconnect","TDSBuffer","connectionCookies","Map","ThinConnectionImpl","close","_protocol","txnInProgress","rollback","callTimeout","_drcpEnabled","_sessRelease","_drcpEstablishSession","_pool","_dropSess","release","message","LogOffMessage","_processMessage","nscon","err","NSFIMM","SessionReleaseMessage","isPooled","sessReleaseMode","DRCP_DEAUTHENTICATE","_determineElementObjType","info","binds","name","type","DB_TYPE_VARCHAR","dir","BIND_IN","maxSize","values","schema","packageName","sql","pop","options","connection","_impl","prefetchRows","result","execute","rows","resultSet","getRows","row","elementTypeClass","_getDbObjectType","partial","_partialDbObjectTypes","push","_execute","statement","numIters","executeManyFlag","numBinds","bindInfoList","length","numVars","throwErr","ERR_WRONG_NUMBER_OF_POSITIONAL_BINDS","i","_bind","isPlSql","batchErrors","dmlRowCounts","ERR_EXEC_MODE_ONLY_FOR_DML","ExecuteMessage","numExecs","arrayDmlRowCounts","requiresFullExecute","offset","requiresDefine","warning","numQueryVars","bufferRowIndex","outBinds","getOutBinds","rowsAffected","rowCount","implicitResultSet","implicitResults","lastRowid","_returnStatement","_parseElementType","buf","oraTypeNum","csfrm","attrType","readUInt8","TNS_OBJ_TDS_TYPE_NUMBER","TNS_OBJ_TDS_TYPE_FLOAT","elementType","DB_TYPE_NUMBER","TNS_OBJ_TDS_TYPE_VARCHAR","TNS_OBJ_TDS_TYPE_CHAR","readUInt16BE","TNS_DATA_TYPE_VARCHAR","TNS_DATA_TYPE_CHAR","getTypeByOraTypeNum","TNS_OBJ_TDS_TYPE_RAW","DB_TYPE_RAW","TNS_OBJ_TDS_TYPE_BINARY_FLOAT","DB_TYPE_BINARY_FLOAT","TNS_OBJ_TDS_TYPE_BINARY_DOUBLE","DB_TYPE_BINARY_DOUBLE","TNS_OBJ_TDS_TYPE_DATE","DB_TYPE_DATE","TNS_OBJ_TDS_TYPE_TIMESTAMP","DB_TYPE_TIMESTAMP","TNS_OBJ_TDS_TYPE_TIMESTAMP_LTZ","DB_TYPE_TIMESTAMP_LTZ","TNS_OBJ_TDS_TYPE_TIMESTAMP_TZ","DB_TYPE_TIMESTAMP_TZ","TNS_OBJ_TDS_TYPE_BOOLEAN","DB_TYPE_BOOLEAN","TNS_OBJ_TDS_TYPE_CLOB","_determineElementTypeCharsetForm","TNS_OBJ_TDS_TYPE_BLOB","DB_TYPE_BLOB","TNS_OBJ_TDS_TYPE_OBJ","DB_TYPE_OBJECT","ERR_TDS_TYPE_NOT_SUPPORTED","_parseTDS","tds","skipBytes","numAttrs","isCollection","TNS_OBJ_TDS_TYPE_COLL","elementPos","readUInt32BE","maxNumElements","collectionType","TNS_OBJ_PLSQL_INDEX_TABLE","collectionFlags","TNS_OBJ_HAS_INDEXES","pos","_populateDbObjectTypeInfo","BIND_INOUT","DB_TYPE_BINARY_INTEGER","BIND_OUT","DB_TYPE_CURSOR","nullifyInvalidCursor","ret_val","ERR_INVALID_OBJECT_TYPE_NAME","package_name","oid","version","attrRows","attrs_rc","attributes","attr","typeClass","getTypeByColumnTypeName","_populatePartialDbObjectTypes","suffix","endsWith","substring","fullName","commit","CommitMessage","breakExecution","breakMessage","isHealthy","recvInbandNotif","getConnectionCookieByUUID","uuid","cookie","key","serviceName","sid","get","set","connect","params","connectString","ERR_EMPTY_CONNECT_STRING","checkCredentials","sessionID","serialNum","autoCommit","serverVersion","statementCache","currentSchema","invokeSessionCallback","statementCacheSize","stmtCacheSize","_numCursorsToClose","_currentSchemaModified","_cursorsToClose","Set","_tempLobsToClose","_tempLobsTotalSize","_cclass","_clientIdentifier","_clientIdentifierModified","_action","_actionModified","_dbOp","_dbOpModified","_clientInfo","_clientInfoModified","_module","_moduleModified","remoteAddress","comboKey","register","serverType","_connInfo","purity","PURITY_DEFAULT","getOption","SERVERTYPE","SVCNAME","SID","PURITY","toLowerCase","REMOTEADDR","connectionClass","PURITY_SELF","PURITY_NEW","caps","protocolVersion","TNS_VERSION_MIN_ACCEPTED","ERR_SERVER_VERSION_NOT_SUPPORTED","dbUUID","protocolMessage","ProtocolMessage","dataTypeMessage","DataTypeMessage","authMessage","AuthMessage","sentCookie","populated","cookieMessage","ConnectionCookieMessage","serverBanner","charsetID","charSetID","ncharsetID","nCharsetId","flags","serverFlags","compileCaps","from","serverCompileCaps","runtimeCaps","serverRunTimeCaps","token","debugJDWP","jdwpData","env","ORA_DEBUG_JDWP","connInProgress","forEach","bindInfo","bindVar","queryVars","queryVar","fill","returnToCache","inUse","cursorId","_addCursorToClose","has","reason","ERR_INTERNAL","add","_adjustStatementCache","size","keys","next","value","stmt","delete","_prepare","_getStatement","keepInStmtCache","bufferRowCount","lastRowIndex","moreRowsToFetch","variable","bindInfoDict","DB_TYPE_LONG_RAW","_csfrm","CSFRM_NCHAR","DB_TYPE_NCLOB","DB_TYPE_CLOB","outConverter","val","data","getData","len","_length","ERR_INSUFFICIENT_BUFFER_FOR_BINDS","index","entries","lobImpl","create","write","normalizedName","startsWith","toUpperCase","ERR_INVALID_BIND_NAME","_setVariable","_createResultSet","_resultSetNew","metadata","getMetadataMany","_setup","resetStatementCache","clear","getDbObjectClass","getStatementInfo","isDdl","parseOnly","metaData","bindNames","Array","statementType","cacheStatement","_copy","ping","PingMessage","RollbackMessage","getOracleServerVersion","getOracleServerVersionString","serverVersionString","setCurrentSchema","getCurrentSchema","setClientId","clientId","setDbOp","dbOp","setClientInfo","clientInfo","setModule","module","setAction","action","changePassword","user","password","newPassword","config","createLob","dbType","getStmtCacheSize","setCallTimeout","timeout","getCallTimeout","getTag","getInstanceName","instanceName","getDbDomain","dbDomain","getDbName","dbName","getMaxOpenCursors","maxOpenCursors","getServiceName","getTransactionInProgress","TNS_TXN_IN_PROGRESS","getWarning","exports"],"sources":["C:/Users/user1/Desktop/finalproject_penpick/node_modules/oracledb/lib/thin/connection.js"],"sourcesContent":["// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst { Buffer } = require('buffer');\nconst ConnectionImpl = require('../impl/connection.js');\nconst ThinResultSetImpl = require('./resultSet.js');\nconst ThinLobImpl  = require(\"./lob.js\");\nconst Protocol = require(\"./protocol/protocol.js\");\nconst { BaseBuffer } = require('./protocol/buffer.js');\nconst {NetworkSession: nsi} = require(\"./sqlnet/networkSession.js\");\nconst { Statement } = require(\"./statement\");\nconst thinUtil = require('./util');\nconst sqlNetConstants = require('./sqlnet/constants.js');\nconst constants = require('./protocol/constants.js');\nconst process = require('process');\nconst types = require('../types.js');\nconst errors = require(\"../errors.js\");\nconst messages = require('./protocol/messages');\n\nconst finalizationRegistry = new global.FinalizationRegistry((heldValue) => {\n  heldValue.disconnect();\n});\n\nclass TDSBuffer extends BaseBuffer {\n}\n\nconst connectionCookies = new Map();\n\nclass ThinConnectionImpl extends ConnectionImpl {\n\n  /**\n   * Terminates the connection\n   *\n   * @return {Promise}\n   */\n  async close() {\n    try {\n      if (this._protocol.txnInProgress) {\n        await this.rollback();\n      }\n      this._protocol.callTimeout = 0;      // not applicable for close\n      if (this._drcpEnabled) {\n        await this._sessRelease();\n        this._drcpEstablishSession = true;\n      }\n\n      if (this._pool && !this._dropSess) {\n        await this._pool.release(this);\n      } else {\n        if (!this._drcpEnabled) {\n          const message = new messages.LogOffMessage(this);\n          await this._protocol._processMessage(message);\n        }\n        this.nscon.disconnect();\n      }\n    } catch (err) {\n      // immediate close of open socket on failure\n      // exception won't be thrown to user\n      this.nscon.disconnect(sqlNetConstants.NSFIMM);\n    }\n  }\n\n  async _sessRelease() {\n    const message = new messages.SessionReleaseMessage(this);\n    if (!this.isPooled()) {\n      message.sessReleaseMode = constants.DRCP_DEAUTHENTICATE;\n    }\n    await this._protocol._processMessage(message);\n  }\n\n  //---------------------------------------------------------------------------\n  // _determineElementObjType()\n  //\n  // Determine the element type's object type. This is needed when processing\n  // collections with an object as the element type since this information is\n  // not available in the TDS.\n  //---------------------------------------------------------------------------\n  async _determineElementObjType(info) {\n    const binds = [\n      {\n        name: \"owner\",\n        type: types.DB_TYPE_VARCHAR,\n        dir: constants.BIND_IN,\n        maxSize: 128,\n        values: [info.schema]\n      },\n      {\n        name: \"name\",\n        type: types.DB_TYPE_VARCHAR,\n        dir: constants.BIND_IN,\n        maxSize: 128,\n        values: [info.name]\n      },\n      {\n        name: \"package_name\",\n        type: types.DB_TYPE_VARCHAR,\n        dir: constants.BIND_IN,\n        maxSize: 128,\n        values: [info.packageName]\n      }\n    ];\n    let sql;\n    if (info.packageName) {\n      sql = `\n        select\n            elem_type_owner,\n            elem_type_name,\n            elem_type_package\n        from all_plsql_coll_types\n        where owner = :owner\n          and type_name = :name\n          and package_name = :package_name`;\n    } else {\n      binds.pop();\n      sql = `\n        select\n            elem_type_owner,\n            elem_type_name\n        from all_coll_types\n        where owner = :owner\n          and type_name = :name`;\n    }\n    const options = {\n      connection: { _impl: this },\n      prefetchRows: 2\n    };\n    const result = await this.execute(sql, 1, binds, options, false);\n    const rows = await result.resultSet.getRows(1, options);\n    await result.resultSet.close();\n    const row = rows[0];\n    info.elementTypeClass = this._getDbObjectType(row[0], row[1], row[2]);\n    if (info.elementTypeClass.partial) {\n      this._partialDbObjectTypes.push(info.elementTypeClass);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _execute()\n  //\n  // Calls the RPC that executes a SQL statement and returns the results.\n  //---------------------------------------------------------------------------\n  async _execute(statement, numIters, binds, options, executeManyFlag) {\n\n    // perform binds\n    const numBinds = statement.bindInfoList.length;\n    const numVars = binds.length;\n    if (numBinds !== numVars && (numVars === 0 || !binds[0].name)) {\n      errors.throwErr(errors.ERR_WRONG_NUMBER_OF_POSITIONAL_BINDS, numBinds, numVars);\n    }\n    for (let i = 0; i < binds.length; i++) {\n      await this._bind(statement, binds[i], i + 1);\n    }\n    if (statement.isPlSql && (options.batchErrors || options.dmlRowCounts)) {\n      errors.throwErr(errors.ERR_EXEC_MODE_ONLY_FOR_DML);\n    }\n\n    // send database request\n    const message = new messages.ExecuteMessage(this, statement, options);\n    message.numExecs = numIters;\n    message.arrayDmlRowCounts = options.dmlRowCounts;\n    message.batchErrors = options.batchErrors;\n    if (statement.isPlSql && statement.requiresFullExecute) {\n      message.numExecs = 1;\n      await this._protocol._processMessage(message);\n      statement.requiresFullExecute = false;\n      message.numExecs = numIters - 1;\n      message.offset = 1;\n    }\n    if (message.numExecs > 0) {\n      await this._protocol._processMessage(message);\n      statement.requiresFullExecute = false;\n    }\n\n    // if a define is required, send an additional request to the database\n    if (statement.requiresDefine && statement.sql) {\n      statement.requiresFullExecute = true;\n      await this._protocol._processMessage(message);\n      statement.requiresFullExecute = false;\n      statement.requiresDefine = false;\n    }\n\n    // process results\n    const result = {};\n    if (message.warning) {\n      result.warning = message.warning;\n    }\n    if (statement.numQueryVars > 0) {\n      result.resultSet = message.resultSet;\n    } else {\n      statement.bufferRowIndex = 0;\n      const outBinds = thinUtil.getOutBinds(statement, numIters,\n        executeManyFlag);\n      if (outBinds) {\n        result.outBinds = outBinds;\n      }\n      if (executeManyFlag) {\n        if (!statement.isPlSql) {\n          result.rowsAffected = statement.rowCount;\n          delete statement.rowCount;\n        }\n        if (options.dmlRowCounts) {\n          result.dmlRowCounts = options.dmlRowCounts;\n        }\n        if (options.batchErrors) {\n          result.batchErrors = options.batchErrors;\n        }\n      } else {\n        if (statement.isPlSql && options.implicitResultSet) {\n          result.implicitResults = options.implicitResultSet;\n        }\n        if (statement.lastRowid) {\n          result.lastRowid = statement.lastRowid;\n          delete statement.lastRowid;\n        }\n        if (statement.isPlSql) {\n          if (statement.rowCount) {\n            result.rowsAffected = statement.rowCount;\n          }\n        } else {\n          result.rowsAffected = statement.rowCount || 0;\n        }\n        if (statement.rowCount) {\n          delete statement.rowCount;\n        }\n      }\n      this._returnStatement(statement);\n    }\n\n    return result;\n  }\n\n  //---------------------------------------------------------------------------\n  // _parseElementType()\n  //\n  // Parses the element type from the TDS buffer.\n  //---------------------------------------------------------------------------\n  async _parseElementType(buf, info) {\n    let oraTypeNum, csfrm;\n    const attrType = buf.readUInt8();\n    switch (attrType) {\n      case constants.TNS_OBJ_TDS_TYPE_NUMBER:\n      case constants.TNS_OBJ_TDS_TYPE_FLOAT:\n        info.elementType = types.DB_TYPE_NUMBER;\n        break;\n      case constants.TNS_OBJ_TDS_TYPE_VARCHAR:\n      case constants.TNS_OBJ_TDS_TYPE_CHAR:\n        info.maxSize = buf.readUInt16BE();\n        oraTypeNum = (attrType === constants.TNS_OBJ_TDS_TYPE_VARCHAR) ?\n          constants.TNS_DATA_TYPE_VARCHAR : constants.TNS_DATA_TYPE_CHAR;\n        csfrm = buf.readUInt8();\n        info.elementType = types.getTypeByOraTypeNum(oraTypeNum, csfrm);\n        break;\n      case constants.TNS_OBJ_TDS_TYPE_RAW:\n        info.elementType = types.DB_TYPE_RAW;\n        break;\n      case constants.TNS_OBJ_TDS_TYPE_BINARY_FLOAT:\n        info.elementType = types.DB_TYPE_BINARY_FLOAT;\n        break;\n      case constants.TNS_OBJ_TDS_TYPE_BINARY_DOUBLE:\n        info.elementType = types.DB_TYPE_BINARY_DOUBLE;\n        break;\n      case constants.TNS_OBJ_TDS_TYPE_DATE:\n        info.elementType = types.DB_TYPE_DATE;\n        break;\n      case constants.TNS_OBJ_TDS_TYPE_TIMESTAMP:\n        info.elementType = types.DB_TYPE_TIMESTAMP;\n        break;\n      case constants.TNS_OBJ_TDS_TYPE_TIMESTAMP_LTZ:\n        info.elementType = types.DB_TYPE_TIMESTAMP_LTZ;\n        break;\n      case constants.TNS_OBJ_TDS_TYPE_TIMESTAMP_TZ:\n        info.elementType = types.DB_TYPE_TIMESTAMP_TZ;\n        break;\n      case constants.TNS_OBJ_TDS_TYPE_BOOLEAN:\n        info.elementType = types.DB_TYPE_BOOLEAN;\n        break;\n      case constants.TNS_OBJ_TDS_TYPE_CLOB:\n        this._determineElementTypeCharsetForm(info);\n        break;\n      case constants.TNS_OBJ_TDS_TYPE_BLOB:\n        info.elementType = types.DB_TYPE_BLOB;\n        break;\n      case constants.TNS_OBJ_TDS_TYPE_OBJ:\n        info.elementType = types.DB_TYPE_OBJECT;\n        await this._determineElementObjType(info);\n        break;\n      default:\n        errors.throwErr(errors.ERR_TDS_TYPE_NOT_SUPPORTED, attrType);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _parseTDS()\n  //\n  // Parses the TDS for the type. This is only needed for collection types, so\n  // if the TDS is determined to be for an object type, the remaining\n  // information is ignored.\n  //---------------------------------------------------------------------------\n  async _parseTDS(tds, info) {\n\n    // parse initial TDS bytes\n    const buf = new TDSBuffer(tds);\n    buf.skipBytes(4);                   // end offset\n    buf.skipBytes(2);                   // version op code and version\n    buf.skipBytes(2);                   // unknown\n\n    // if the number of attributes exceeds 1, the type cannot refer to a\n    // collection, so nothing further needs to be done\n    const numAttrs = buf.readUInt16BE();\n    if (numAttrs > 1) {\n      info.isCollection = false;\n      return;\n    }\n\n    // continue parsing TDS bytes to discover if type refers to a collection\n    buf.skipBytes(1);                   // TDS attributes?\n    buf.skipBytes(1);                   // start ADT op code\n    buf.skipBytes(2);                   // ADT number (always zero)\n    buf.skipBytes(4);                   // offset to index table\n\n    // if type of first attribute is not a collection, nothing further needs\n    // to be done\n    const attrType = buf.readUInt8();\n    info.isCollection = (attrType === constants.TNS_OBJ_TDS_TYPE_COLL);\n    if (!info.isCollection)\n      return;\n\n    // continue parsing TDS to determine element type\n    const elementPos = buf.readUInt32BE();\n    info.maxNumElements = buf.readUInt32BE();\n    info.collectionType = buf.readUInt8();\n    if (info.collectionType === constants.TNS_OBJ_PLSQL_INDEX_TABLE) {\n      info.collectionFlags = constants.TNS_OBJ_HAS_INDEXES;\n    }\n    buf.pos = elementPos;\n\n    await this._parseElementType(buf, info);\n  }\n\n  //---------------------------------------------------------------------------\n  // _populateDbObjectTypeInfo()\n  //\n  // Poplates type information given the name of the type.\n  //---------------------------------------------------------------------------\n  async _populateDbObjectTypeInfo(name) {\n\n    // get type information from the database\n    const sql = `\n      declare\n          t_Instantiable              varchar2(3);\n          t_SuperTypeOwner            varchar2(128);\n          t_SuperTypeName             varchar2(128);\n          t_SubTypeRefCursor          sys_refcursor;\n          t_Pos                       pls_integer;\n      begin\n          :ret_val := dbms_pickler.get_type_shape(:full_name, :oid,\n              :version, :tds, t_Instantiable, t_SuperTypeOwner,\n              t_SuperTypeName, :attrs_rc, t_SubTypeRefCursor);\n          :package_name := null;\n          if substr(:full_name, length(:full_name) - 7) = '%ROWTYPE' then\n              t_Pos := instr(:full_name, '.');\n              :schema := substr(:full_name, 1, t_Pos - 1);\n              :name := substr(:full_name, t_Pos + 1);\n          else\n              begin\n                  select owner, type_name\n                  into :schema, :name\n                  from all_types\n                  where type_oid = :oid;\n              exception\n              when no_data_found then\n                  begin\n                      select owner, package_name, type_name\n                      into :schema, :package_name, :name\n                      from all_plsql_types\n                      where type_oid = :oid;\n                  exception\n                  when no_data_found then\n                      null;\n                  end;\n              end;\n          end if;\n      end;`;\n    const binds = [\n      {\n        name: \"full_name\",\n        type: types.DB_TYPE_VARCHAR,\n        dir: constants.BIND_INOUT,\n        maxSize: 500,\n        values: [name]\n      },\n      {\n        name: \"ret_val\",\n        type: types.DB_TYPE_BINARY_INTEGER,\n        dir: constants.BIND_OUT,\n        values: []\n      },\n      {\n        name: \"oid\",\n        type: types.DB_TYPE_RAW,\n        maxSize: 16,\n        dir: constants.BIND_OUT,\n        values: []\n      },\n      {\n        name: \"version\",\n        type: types.DB_TYPE_BINARY_INTEGER,\n        dir: constants.BIND_OUT,\n        values: []\n      },\n      {\n        name: \"tds\",\n        type: types.DB_TYPE_RAW,\n        maxSize: 2000,\n        dir: constants.BIND_OUT,\n        values: []\n      },\n      {\n        name: \"attrs_rc\",\n        type: types.DB_TYPE_CURSOR,\n        dir: constants.BIND_OUT,\n        values: []\n      },\n      {\n        name: \"package_name\",\n        type: types.DB_TYPE_VARCHAR,\n        maxSize: 128,\n        dir: constants.BIND_OUT,\n        values: []\n      },\n      {\n        name: \"schema\",\n        type: types.DB_TYPE_VARCHAR,\n        maxSize: 128,\n        dir: constants.BIND_OUT,\n        values: []\n      },\n      {\n        name: \"name\",\n        type: types.DB_TYPE_VARCHAR,\n        maxSize: 128,\n        dir: constants.BIND_OUT,\n        values: []\n      }\n    ];\n    const options = {\n      connection: { _impl: this },\n      nullifyInvalidCursor: true\n    };\n    const result = await this.execute(sql, 1, binds, options, false);\n    if (result.outBinds.ret_val !== 0) {\n      errors.throwErr(errors.ERR_INVALID_OBJECT_TYPE_NAME, name);\n    }\n\n    // check cache; if already present, nothing more to do!\n    const info = this._getDbObjectType(result.outBinds.schema,\n      result.outBinds.name, result.outBinds.package_name, result.outBinds.oid);\n    if (!info.partial)\n      return info;\n\n    // process TDS and attributes cursor\n    info.version = result.outBinds.version;\n    await this._parseTDS(result.outBinds.tds, info);\n    const attrRows = await result.outBinds.attrs_rc.getRows(1000, {});\n    if (attrRows.length > 0) {\n      info.attributes = [];\n      for (const row of attrRows) {\n        const attr = { name: row[1] };\n        if (row[4]) {\n          attr.type = types.DB_TYPE_OBJECT;\n          attr.typeClass = this._getDbObjectType(row[4], row[3], row[5], row[6]);\n          if (attr.typeClass.partial) {\n            this._partialDbObjectTypes.push(attr.typeClass);\n          }\n        } else {\n          attr.type = types.getTypeByColumnTypeName(row[3]);\n        }\n        info.attributes.push(attr);\n      }\n    }\n    info.partial = false;\n\n    return info;\n\n  }\n\n  //---------------------------------------------------------------------------\n  // _populatePartialDbObjectTypes()\n  //\n  // Populates partial types that were discovered earlier. Since populating an\n  // object type might result in additional object types being discovered,\n  // object types are popped from the partial types list until the list is\n  // empty.\n  //---------------------------------------------------------------------------\n  async _populatePartialDbObjectTypes() {\n    while (this._partialDbObjectTypes.length > 0) {\n      const info = this._partialDbObjectTypes.pop();\n      let suffix = \"%ROWTYPE\";\n      let name = info.name;\n      if (name.endsWith(suffix)) {\n        name = name.substring(0, name.length - suffix.length);\n      } else {\n        suffix = \"\";\n      }\n      let fullName;\n      if (info.packageName) {\n        fullName = `\"${info.schema}\".\"${info.packageName}\".\"${name}\"${suffix}`;\n      } else {\n        fullName = `\"${info.schema}\".\"${name}\"${suffix}`;\n      }\n      await this._populateDbObjectTypeInfo(fullName);\n    }\n  }\n\n  async commit() {\n    const message = new messages.CommitMessage(this);\n    await this._protocol._processMessage(message);\n  }\n\n  async breakExecution() {\n    await this._protocol.breakMessage();\n  }\n\n  isHealthy() {\n    try {\n      if (this.nscon.recvInbandNotif() === 0)\n        return true;\n      return false;\n    } catch {\n      return false;\n    }\n  }\n\n  isPooled() {\n    return (this._pool) ? true : false;\n  }\n\n  //---------------------------------------------------------------------------\n  // getConnectionCookieByUUID()\n  //\n  // It fetches from map which keeps keyname as UUID+ServiceName.\n  // UUID identifies the CDB instance and ServiceName identifies the\n  // entity within a PDB which uniquely identifies a pdb instance.\n  //---------------------------------------------------------------------------\n  getConnectionCookieByUUID(uuid) {\n    let cookie;\n    if (uuid) {\n      const key = uuid + ((this.serviceName) ? this.serviceName : this.sid);\n      cookie = connectionCookies.get(key);\n      if (!cookie) {\n        cookie = {};\n        connectionCookies.set(key, cookie);\n      }\n    }\n    return cookie;\n  }\n\n  /**\n   *\n   * @param {object} params  Configuration of the connection\n   *\n   * @return {Promise}\n   */\n  async connect(params) {\n    if (!params.connectString) {\n      errors.throwErr(errors.ERR_EMPTY_CONNECT_STRING);\n    }\n    thinUtil.checkCredentials(params);\n\n    this.sessionID = 0;\n    this.serialNum = 0;\n    this.autoCommit = false;\n    this.serverVersion = \"\";\n    this.statementCache = null;\n    this.currentSchema = \"\";\n    this.invokeSessionCallback = true;\n    this.statementCache = new Map();\n    this.statementCacheSize = params.stmtCacheSize;\n    this._numCursorsToClose = 0;\n    this._currentSchemaModified = false;\n    this._cursorsToClose = new Set();\n    this._tempLobsToClose = [];\n    this._tempLobsTotalSize = 0;\n    this._drcpEstablishSession = false;\n    this._cclass = null;\n    this._clientIdentifier = \"\";\n    this._clientIdentifierModified = false;\n    this._action = \"\";\n    this._actionModified = false;\n    this._dbOp = \"\";\n    this._dbOpModified = false;\n    this._clientInfo = \"\";\n    this._clientInfoModified = false;\n    this._module = \"\";\n    this._moduleModified = false;\n    this._drcpEnabled = false;\n    this.serviceName = '';\n    this.remoteAddress = '';\n    this.comboKey = null; // used in changePassword API\n\n    this.nscon = new nsi();\n    finalizationRegistry.register(this, this.nscon);\n    await this.nscon.connect(params);\n\n    let serverType;\n    if (this.isPooled()) {\n      serverType = params._connInfo[0];\n      this.serviceName = params._connInfo[2];\n      this.purity = params._connInfo[3] | constants.PURITY_DEFAULT;\n      this.sid = params._connInfo[4];\n    } else {\n      serverType = this.nscon.getOption(sqlNetConstants.SERVERTYPE);\n      this.serviceName = this.nscon.getOption(sqlNetConstants.SVCNAME);\n      this.sid = this.nscon.getOption(sqlNetConstants.SID);\n      this.purity = this.nscon.getOption(sqlNetConstants.PURITY) | constants.PURITY_DEFAULT;\n    }\n    if (serverType) {\n      this._drcpEnabled = serverType.toLowerCase() === 'pooled';\n    }\n    this.remoteAddress = this.nscon.getOption(sqlNetConstants.REMOTEADDR);\n    this.connectionClass = params.connectionClass;\n\n    /*\n     * if drcp is used, use purity = NEW as the default purity for\n     * standalone connections and purity = SELF for connections that belong\n     * to a pool\n     */\n    if (this.purity === constants.PURITY_DEFAULT && this._drcpEnabled) {\n      if (this.isPooled()) {\n        this.purity = constants.PURITY_SELF;\n      } else {\n        this.purity = constants.PURITY_NEW;\n      }\n    }\n\n    this._protocol = new Protocol(this);\n\n    // check if the protocol version supported by the database is high\n    // enough; if not, reject the connection immediately\n    if (this._protocol.caps.protocolVersion < constants.TNS_VERSION_MIN_ACCEPTED) {\n      errors.throwErr(errors.ERR_SERVER_VERSION_NOT_SUPPORTED);\n    }\n\n    try {\n      const cookie = this.getConnectionCookieByUUID(this.nscon.dbUUID);\n      this.nscon.dbUUID = null;\n      const protocolMessage = new messages.ProtocolMessage(this);\n      const dataTypeMessage = new messages.DataTypeMessage(this);\n      const authMessage = new messages.AuthMessage(this, params);\n      let sentCookie = false;\n      if (cookie && cookie.populated) {\n        const cookieMessage = new messages.ConnectionCookieMessage(this);\n        cookieMessage.cookie = cookie;\n        cookieMessage.protocolMessage = protocolMessage;\n        cookieMessage.dataTypeMessage = dataTypeMessage;\n        cookieMessage.authMessage = authMessage;\n        await this._protocol._processMessage(cookieMessage);\n        sentCookie = true;\n      } else {\n        await this._protocol._processMessage(protocolMessage);\n      }\n      if (!sentCookie || !cookie.populated) {\n        await this._protocol._processMessage(dataTypeMessage);\n        // Does OSESSKEY for non-token Authentication else OAUTH\n        await this._protocol._processMessage(authMessage);\n        if (cookie && !cookie.populated) {\n          cookie.protocolVersion = protocolMessage.serverVersion;\n          cookie.serverBanner = protocolMessage.serverBanner;\n          cookie.charsetID = this._protocol.caps.charSetID;\n          cookie.ncharsetID = this._protocol.caps.nCharsetId;\n          cookie.flags = protocolMessage.serverFlags;\n          cookie.compileCaps = Buffer.from(protocolMessage.serverCompileCaps);\n          cookie.runtimeCaps = Buffer.from(protocolMessage.serverRunTimeCaps);\n          cookie.populated = true;\n        }\n      }\n      if (!params.token) { // non-token Authentication\n        await this._protocol._processMessage(authMessage); // OAUTH\n      }\n    } catch (err) {\n      this.nscon.disconnect();\n      throw err;\n    }\n\n    // maintain a list of partially populated database object types\n    this._partialDbObjectTypes = [];\n\n    if (params.debugJDWP) {\n      this.jdwpData = Buffer.from(params.debugJDWP);\n    } else if (process.env.ORA_DEBUG_JDWP) {\n      this.jdwpData = Buffer.from(process.env.ORA_DEBUG_JDWP);\n    }\n    this._protocol.connInProgress = false;\n  }\n\n  //---------------------------------------------------------------------------\n  // Sets that a statement is no longer in use\n  //---------------------------------------------------------------------------\n  _returnStatement(statement) {\n    if (statement.bindInfoList) {\n      statement.bindInfoList.forEach(bindInfo => {\n        bindInfo.bindVar = null;\n      });\n    }\n    if (statement.queryVars) {\n      statement.queryVars.forEach(queryVar => {\n        queryVar.values.fill(null);\n      });\n    }\n    if (statement.returnToCache) {\n      statement.inUse = false;\n    } else if (statement.cursorId !== 0) {\n      this._addCursorToClose(statement.cursorId);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // Adds the cursors that needs to be closed to the _cursorsToClose set\n  //---------------------------------------------------------------------------\n  _addCursorToClose(cursorId) {\n    if (this._cursorsToClose.has(cursorId)) {\n      const reason = `attempt to close cursor ${cursorId} twice`;\n      errors.throwErr(errors.ERR_INTERNAL, reason);\n    }\n    this._cursorsToClose.add(cursorId);\n  }\n\n  //---------------------------------------------------------------------------\n  // Adjusts the statement cache to remove least recently used statements\n  //---------------------------------------------------------------------------\n  _adjustStatementCache() {\n    while (this.statementCache.size > this.statementCacheSize) {\n      const sql = this.statementCache.keys().next().value;\n      const stmt = this.statementCache.get(sql);\n      this.statementCache.delete(sql);\n      if (stmt.inUse) {\n        stmt.returnToCache = false;\n      } else if (stmt.cursorId !== 0) {\n        this._addCursorToClose(stmt.cursorId);\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // Parses the sql statement and puts it into cache if keepInStmtCache\n  // option is true\n  //---------------------------------------------------------------------------\n  _prepare(sql, options) {\n    const statement = this._getStatement(sql, options.keepInStmtCache);\n    statement.bufferRowIndex = 0;\n    statement.bufferRowCount = 0;\n    statement.lastRowIndex = 0;\n    statement.moreRowsToFetch = true;\n    return statement;\n  }\n\n  //---------------------------------------------------------------------------\n  // Binds the values by user to the statement object\n  //---------------------------------------------------------------------------\n  async _bind(stmt, variable, pos = 0) {\n    const bindInfoDict = stmt.bindInfoDict;\n    const bindInfoList = stmt.bindInfoList;\n\n    /*\n     * For PL/SQL blocks, if the size of a string or bytes object exceeds\n     * 32,767 bytes it is converted to a BLOB/CLOB; and conversion\n     * needs to be established as well to return the string in the way that\n     * the user expects to get it\n     */\n    if (stmt.isPlSql && variable.maxSize > 32767) {\n      if (variable.type === types.DB_TYPE_RAW ||\n          variable.type === types.DB_TYPE_LONG_RAW) {\n        variable.type = types.DB_TYPE_BLOB;\n      } else if (variable.type._csfrm === constants.CSFRM_NCHAR)  {\n        variable.type = types.DB_TYPE_NCLOB;\n      } else {\n        variable.type = types.DB_TYPE_CLOB;\n      }\n      const maxSize = variable.maxSize;\n      delete variable.maxSize;\n      variable.outConverter = async function(val) {\n        if (val === null) {\n          return null;\n        }\n        const data = await val.getData();\n        const len = val._length;\n        if (data && len > maxSize) {\n          errors.throwErr(errors.ERR_INSUFFICIENT_BUFFER_FOR_BINDS);\n        }\n        return data;\n      };\n    }\n\n    if (variable.type === types.DB_TYPE_CLOB ||\n        variable.type === types.DB_TYPE_NCLOB ||\n        variable.type === types.DB_TYPE_BLOB) {\n      for (const [index, val] of variable.values.entries()) {\n        if (!(val instanceof ThinLobImpl)) {\n          if (val && val.length > 0) {\n            const lobImpl = new ThinLobImpl();\n            await lobImpl.create(this, variable.type);\n            await lobImpl.write(1, val);\n            variable.values[index] = lobImpl;\n          } else {\n            variable.values[index] = null;\n          }\n        }\n      }\n    }\n\n    if (variable.name) {\n      let normalizedName;\n      if (variable.name.startsWith('\"') && variable.name.endsWith('\"')) {\n        normalizedName = variable.name.substring(1, variable.name.length - 1);\n      } else {\n        normalizedName = variable.name.toUpperCase();\n      }\n      if (normalizedName.startsWith(':')) {\n        normalizedName = variable.name.substring(1);\n      }\n      if (!bindInfoDict.has(normalizedName)) {\n        errors.throwErr(errors.ERR_INVALID_BIND_NAME, normalizedName);\n      }\n      bindInfoDict.get(normalizedName).forEach((bindInfo) => {\n        stmt._setVariable(bindInfo, variable);\n      });\n    } else {\n      const bindInfo = bindInfoList[pos - 1];\n      stmt._setVariable(bindInfo, variable);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _createResultSet()\n  //\n  // Creates a result set and performs any necessary initialization.\n  //---------------------------------------------------------------------------\n  _createResultSet(options, statement) {\n    const resultSet = new ThinResultSetImpl();\n    if (!statement) {\n      statement = new Statement();\n    }\n    resultSet._resultSetNew(this, statement, options);\n    if (statement.queryVars.length > 0) {\n      const metadata = thinUtil.getMetadataMany(statement.queryVars);\n      resultSet._setup(options, metadata);\n    }\n    return resultSet;\n  }\n\n  //---------------------------------------------------------------------------\n  // Clears the statement cache for the connection\n  //---------------------------------------------------------------------------\n  resetStatementCache() {\n    this.statementCache.clear();\n    this._cursorsToClose.clear();\n  }\n\n  //---------------------------------------------------------------------------\n  // getDbObjectClass()\n  //\n  // Returns a database object class given its name.\n  //---------------------------------------------------------------------------\n  async getDbObjectClass(name) {\n    const info = await this._populateDbObjectTypeInfo(name);\n    await this._populatePartialDbObjectTypes();\n    return info;\n  }\n\n  //---------------------------------------------------------------------------\n  // getStatementInfo()\n  //\n  // Parses the SQL statement and returns information about the statement.\n  //---------------------------------------------------------------------------\n  async getStatementInfo(sql) {\n    const options = {};\n    const result = {};\n    const statement = this._prepare(sql, options);\n    options.connection = this;\n    try {\n      if (!statement.isDdl) {\n        const message = new messages.ExecuteMessage(this, statement, options);\n        message.parseOnly = true;\n        await this._protocol._processMessage(message);\n      }\n      if (statement.numQueryVars > 0) {\n        result.metaData = thinUtil.getMetadataMany(statement.queryVars);\n      }\n      result.bindNames = Array.from(statement.bindInfoDict.keys());\n      result.statementType = statement.statementType;\n      return result;\n    } finally {\n      this._returnStatement(statement);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // execute()\n  //\n  // Calls the RPC that executes a SQL statement and returns the results.\n  //---------------------------------------------------------------------------\n  async execute(sql, numIters, binds, options, executeManyFlag) {\n    const statement = this._prepare(sql, options);\n    try {\n      return await this._execute(statement, numIters, binds, options,\n        executeManyFlag);\n    } catch (err) {\n      this._returnStatement(statement);\n      throw err;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // Get the statement object from the statement cache for the SQL if it exists\n  // else prepare a new statement object for the SQL. If a statement is already\n  // in use a copy will be made and returned (and will not be returned to the\n  // cache). If a statement is being executed for the first time after releasing\n  // a DRCP session, a copy will also be made (and will not be returned to the\n  // cache) since it is unknown at this point whether the original session or a\n  // new session is going to be used.\n  //---------------------------------------------------------------------------\n  _getStatement(sql, cacheStatement = false) {\n    let statement = this.statementCache.get(sql);\n    if (!statement) {\n      statement = new Statement();\n      statement._prepare(sql);\n      if (cacheStatement && !this._drcpEstablishSession && !statement.isDdl &&\n          this.statementCacheSize > 0) {\n        statement.returnToCache = true;\n        this.statementCache.set(sql, statement);\n        this._adjustStatementCache();\n      }\n    } else if (statement.inUse || !cacheStatement ||\n        this._drcpEstablishSession) {\n      if (!cacheStatement) {\n        this.statementCache.delete(sql);\n        statement.returnToCache = false;\n      }\n      if (statement.inUse || this._drcpEstablishSession) {\n        statement = statement._copy();\n      }\n    } else {\n      this.statementCache.delete(sql);\n      this.statementCache.set(sql, statement);\n    }\n    statement.inUse = true;\n    return statement;\n  }\n\n  //---------------------------------------------------------------------------\n  // Calls the ping RPC for Oracle Database\n  //---------------------------------------------------------------------------\n  async ping() {\n    const message = new messages.PingMessage(this);\n    await this._protocol._processMessage(message);\n  }\n\n  //---------------------------------------------------------------------------\n  // Calls the Rollback RPC for Oracle Database\n  //---------------------------------------------------------------------------\n  async rollback() {\n    const message = new messages.RollbackMessage(this);\n    await this._protocol._processMessage(message);\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the Oracle Server version\n  //---------------------------------------------------------------------------\n  getOracleServerVersion() {\n    return this.serverVersion;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the Oracle Server version string\n  //---------------------------------------------------------------------------\n  getOracleServerVersionString() {\n    return this.serverVersionString;\n  }\n\n  setCurrentSchema(schema) {\n    this._currentSchemaModified = true;\n    this.currentSchema = schema;\n  }\n\n  getCurrentSchema() {\n    return this.currentSchema;\n  }\n\n  setClientId(clientId) {\n    this._clientIdentifierModified = true;\n    this._clientIdentifier = clientId;\n  }\n\n  setDbOp(dbOp) {\n    this._dbOpModified = true;\n    this._dbOp = dbOp;\n  }\n\n  setClientInfo(clientInfo) {\n    this._clientInfoModified = true;\n    this._clientInfo = clientInfo;\n  }\n\n  setModule(module) {\n    this._moduleModified = true;\n    this._module = module;\n\n    /*\n     * setting the module by itself results in an error so always force\n     * action to be set as well (which eliminates this error)\n     */\n    this._actionModified = true;\n  }\n\n  setAction(action) {\n    this._actionModified = true;\n    this._action = action;\n  }\n\n  async changePassword(user, password, newPassword) {\n    const config = {\n      user: user,\n      newPassword: newPassword,\n      password: password,\n      changePassword: true\n    };\n    const message = new messages.AuthMessage(this, config);\n    await this._protocol._processMessage(message);    // OAUTH\n  }\n\n  async createLob(dbType) {\n    const lobImpl = new ThinLobImpl();\n    await lobImpl.create(this, dbType);\n    return lobImpl;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the statement cache size for the statement cache maintained by\n  // the connection object\n  //---------------------------------------------------------------------------\n  getStmtCacheSize() {\n    return this.statementCacheSize;\n  }\n\n  setCallTimeout(timeout) {\n    this._protocol.callTimeout = timeout;\n  }\n\n  getCallTimeout() {\n    return this._protocol.callTimeout;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns getTag. Actual tag returned by db must be a string.\n  //---------------------------------------------------------------------------\n  getTag() {\n    return '';\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the Oracle Database instance name associated with the connection.\n  //---------------------------------------------------------------------------\n  getInstanceName() {\n    return this.instanceName;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the Oracle Database domain name associated with the connection.\n  //---------------------------------------------------------------------------\n  getDbDomain() {\n    return this.dbDomain;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the Oracle Database name associated with the connection.\n  //---------------------------------------------------------------------------\n  getDbName() {\n    return this.dbName;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns maximum number of cursors that can be opened in one session.\n  //---------------------------------------------------------------------------\n  getMaxOpenCursors() {\n    return this.maxOpenCursors;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the Oracle Database service name associated with the connection.\n  //---------------------------------------------------------------------------\n  getServiceName() {\n    return this.serviceName;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns boolean based on this._protocol.txnInProgress value.\n  //---------------------------------------------------------------------------\n  getTransactionInProgress() {\n    return this._protocol.txnInProgress === constants.TNS_TXN_IN_PROGRESS;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the warning object.\n  //---------------------------------------------------------------------------\n  getWarning() {\n    return this.warning;\n  }\n}\nmodule.exports = ThinConnectionImpl;\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAM;EAAEA;AAAO,CAAC,GAAGC,OAAO,CAAC,QAAQ,CAAC;AACpC,MAAMC,cAAc,GAAGD,OAAO,CAAC,uBAAuB,CAAC;AACvD,MAAME,iBAAiB,GAAGF,OAAO,CAAC,gBAAgB,CAAC;AACnD,MAAMG,WAAW,GAAIH,OAAO,CAAC,UAAU,CAAC;AACxC,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,wBAAwB,CAAC;AAClD,MAAM;EAAEK;AAAW,CAAC,GAAGL,OAAO,CAAC,sBAAsB,CAAC;AACtD,MAAM;EAACM,cAAc,EAAEC;AAAG,CAAC,GAAGP,OAAO,CAAC,4BAA4B,CAAC;AACnE,MAAM;EAAEQ;AAAU,CAAC,GAAGR,OAAO,CAAC,aAAa,CAAC;AAC5C,MAAMS,QAAQ,GAAGT,OAAO,CAAC,QAAQ,CAAC;AAClC,MAAMU,eAAe,GAAGV,OAAO,CAAC,uBAAuB,CAAC;AACxD,MAAMW,SAAS,GAAGX,OAAO,CAAC,yBAAyB,CAAC;AACpD,MAAMY,OAAO,GAAGZ,OAAO,CAAC,SAAS,CAAC;AAClC,MAAMa,KAAK,GAAGb,OAAO,CAAC,aAAa,CAAC;AACpC,MAAMc,MAAM,GAAGd,OAAO,CAAC,cAAc,CAAC;AACtC,MAAMe,QAAQ,GAAGf,OAAO,CAAC,qBAAqB,CAAC;AAE/C,MAAMgB,oBAAoB,GAAG,IAAIC,MAAM,CAACC,oBAAoB,CAAEC,SAAS,IAAK;EAC1EA,SAAS,CAACC,UAAU,CAAC,CAAC;AACxB,CAAC,CAAC;AAEF,MAAMC,SAAS,SAAShB,UAAU,CAAC;AAGnC,MAAMiB,iBAAiB,GAAG,IAAIC,GAAG,CAAC,CAAC;AAEnC,MAAMC,kBAAkB,SAASvB,cAAc,CAAC;EAE9C;AACF;AACA;AACA;AACA;EACE,MAAMwB,KAAKA,CAAA,EAAG;IACZ,IAAI;MACF,IAAI,IAAI,CAACC,SAAS,CAACC,aAAa,EAAE;QAChC,MAAM,IAAI,CAACC,QAAQ,CAAC,CAAC;MACvB;MACA,IAAI,CAACF,SAAS,CAACG,WAAW,GAAG,CAAC,CAAC,CAAM;MACrC,IAAI,IAAI,CAACC,YAAY,EAAE;QACrB,MAAM,IAAI,CAACC,YAAY,CAAC,CAAC;QACzB,IAAI,CAACC,qBAAqB,GAAG,IAAI;MACnC;MAEA,IAAI,IAAI,CAACC,KAAK,IAAI,CAAC,IAAI,CAACC,SAAS,EAAE;QACjC,MAAM,IAAI,CAACD,KAAK,CAACE,OAAO,CAAC,IAAI,CAAC;MAChC,CAAC,MAAM;QACL,IAAI,CAAC,IAAI,CAACL,YAAY,EAAE;UACtB,MAAMM,OAAO,GAAG,IAAIrB,QAAQ,CAACsB,aAAa,CAAC,IAAI,CAAC;UAChD,MAAM,IAAI,CAACX,SAAS,CAACY,eAAe,CAACF,OAAO,CAAC;QAC/C;QACA,IAAI,CAACG,KAAK,CAACnB,UAAU,CAAC,CAAC;MACzB;IACF,CAAC,CAAC,OAAOoB,GAAG,EAAE;MACZ;MACA;MACA,IAAI,CAACD,KAAK,CAACnB,UAAU,CAACV,eAAe,CAAC+B,MAAM,CAAC;IAC/C;EACF;EAEA,MAAMV,YAAYA,CAAA,EAAG;IACnB,MAAMK,OAAO,GAAG,IAAIrB,QAAQ,CAAC2B,qBAAqB,CAAC,IAAI,CAAC;IACxD,IAAI,CAAC,IAAI,CAACC,QAAQ,CAAC,CAAC,EAAE;MACpBP,OAAO,CAACQ,eAAe,GAAGjC,SAAS,CAACkC,mBAAmB;IACzD;IACA,MAAM,IAAI,CAACnB,SAAS,CAACY,eAAe,CAACF,OAAO,CAAC;EAC/C;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAMU,wBAAwBA,CAACC,IAAI,EAAE;IACnC,MAAMC,KAAK,GAAG,CACZ;MACEC,IAAI,EAAE,OAAO;MACbC,IAAI,EAAErC,KAAK,CAACsC,eAAe;MAC3BC,GAAG,EAAEzC,SAAS,CAAC0C,OAAO;MACtBC,OAAO,EAAE,GAAG;MACZC,MAAM,EAAE,CAACR,IAAI,CAACS,MAAM;IACtB,CAAC,EACD;MACEP,IAAI,EAAE,MAAM;MACZC,IAAI,EAAErC,KAAK,CAACsC,eAAe;MAC3BC,GAAG,EAAEzC,SAAS,CAAC0C,OAAO;MACtBC,OAAO,EAAE,GAAG;MACZC,MAAM,EAAE,CAACR,IAAI,CAACE,IAAI;IACpB,CAAC,EACD;MACEA,IAAI,EAAE,cAAc;MACpBC,IAAI,EAAErC,KAAK,CAACsC,eAAe;MAC3BC,GAAG,EAAEzC,SAAS,CAAC0C,OAAO;MACtBC,OAAO,EAAE,GAAG;MACZC,MAAM,EAAE,CAACR,IAAI,CAACU,WAAW;IAC3B,CAAC,CACF;IACD,IAAIC,GAAG;IACP,IAAIX,IAAI,CAACU,WAAW,EAAE;MACpBC,GAAG,GAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;IACvC,CAAC,MAAM;MACLV,KAAK,CAACW,GAAG,CAAC,CAAC;MACXD,GAAG,GAAI;AACb;AACA;AACA;AACA;AACA;AACA,gCAAgC;IAC5B;IACA,MAAME,OAAO,GAAG;MACdC,UAAU,EAAE;QAAEC,KAAK,EAAE;MAAK,CAAC;MAC3BC,YAAY,EAAE;IAChB,CAAC;IACD,MAAMC,MAAM,GAAG,MAAM,IAAI,CAACC,OAAO,CAACP,GAAG,EAAE,CAAC,EAAEV,KAAK,EAAEY,OAAO,EAAE,KAAK,CAAC;IAChE,MAAMM,IAAI,GAAG,MAAMF,MAAM,CAACG,SAAS,CAACC,OAAO,CAAC,CAAC,EAAER,OAAO,CAAC;IACvD,MAAMI,MAAM,CAACG,SAAS,CAAC1C,KAAK,CAAC,CAAC;IAC9B,MAAM4C,GAAG,GAAGH,IAAI,CAAC,CAAC,CAAC;IACnBnB,IAAI,CAACuB,gBAAgB,GAAG,IAAI,CAACC,gBAAgB,CAACF,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,CAAC;IACrE,IAAItB,IAAI,CAACuB,gBAAgB,CAACE,OAAO,EAAE;MACjC,IAAI,CAACC,qBAAqB,CAACC,IAAI,CAAC3B,IAAI,CAACuB,gBAAgB,CAAC;IACxD;EACF;;EAEA;EACA;EACA;EACA;EACA;EACA,MAAMK,QAAQA,CAACC,SAAS,EAAEC,QAAQ,EAAE7B,KAAK,EAAEY,OAAO,EAAEkB,eAAe,EAAE;IAEnE;IACA,MAAMC,QAAQ,GAAGH,SAAS,CAACI,YAAY,CAACC,MAAM;IAC9C,MAAMC,OAAO,GAAGlC,KAAK,CAACiC,MAAM;IAC5B,IAAIF,QAAQ,KAAKG,OAAO,KAAKA,OAAO,KAAK,CAAC,IAAI,CAAClC,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,EAAE;MAC7DnC,MAAM,CAACqE,QAAQ,CAACrE,MAAM,CAACsE,oCAAoC,EAAEL,QAAQ,EAAEG,OAAO,CAAC;IACjF;IACA,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrC,KAAK,CAACiC,MAAM,EAAEI,CAAC,EAAE,EAAE;MACrC,MAAM,IAAI,CAACC,KAAK,CAACV,SAAS,EAAE5B,KAAK,CAACqC,CAAC,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC;IAC9C;IACA,IAAIT,SAAS,CAACW,OAAO,KAAK3B,OAAO,CAAC4B,WAAW,IAAI5B,OAAO,CAAC6B,YAAY,CAAC,EAAE;MACtE3E,MAAM,CAACqE,QAAQ,CAACrE,MAAM,CAAC4E,0BAA0B,CAAC;IACpD;;IAEA;IACA,MAAMtD,OAAO,GAAG,IAAIrB,QAAQ,CAAC4E,cAAc,CAAC,IAAI,EAAEf,SAAS,EAAEhB,OAAO,CAAC;IACrExB,OAAO,CAACwD,QAAQ,GAAGf,QAAQ;IAC3BzC,OAAO,CAACyD,iBAAiB,GAAGjC,OAAO,CAAC6B,YAAY;IAChDrD,OAAO,CAACoD,WAAW,GAAG5B,OAAO,CAAC4B,WAAW;IACzC,IAAIZ,SAAS,CAACW,OAAO,IAAIX,SAAS,CAACkB,mBAAmB,EAAE;MACtD1D,OAAO,CAACwD,QAAQ,GAAG,CAAC;MACpB,MAAM,IAAI,CAAClE,SAAS,CAACY,eAAe,CAACF,OAAO,CAAC;MAC7CwC,SAAS,CAACkB,mBAAmB,GAAG,KAAK;MACrC1D,OAAO,CAACwD,QAAQ,GAAGf,QAAQ,GAAG,CAAC;MAC/BzC,OAAO,CAAC2D,MAAM,GAAG,CAAC;IACpB;IACA,IAAI3D,OAAO,CAACwD,QAAQ,GAAG,CAAC,EAAE;MACxB,MAAM,IAAI,CAAClE,SAAS,CAACY,eAAe,CAACF,OAAO,CAAC;MAC7CwC,SAAS,CAACkB,mBAAmB,GAAG,KAAK;IACvC;;IAEA;IACA,IAAIlB,SAAS,CAACoB,cAAc,IAAIpB,SAAS,CAAClB,GAAG,EAAE;MAC7CkB,SAAS,CAACkB,mBAAmB,GAAG,IAAI;MACpC,MAAM,IAAI,CAACpE,SAAS,CAACY,eAAe,CAACF,OAAO,CAAC;MAC7CwC,SAAS,CAACkB,mBAAmB,GAAG,KAAK;MACrClB,SAAS,CAACoB,cAAc,GAAG,KAAK;IAClC;;IAEA;IACA,MAAMhC,MAAM,GAAG,CAAC,CAAC;IACjB,IAAI5B,OAAO,CAAC6D,OAAO,EAAE;MACnBjC,MAAM,CAACiC,OAAO,GAAG7D,OAAO,CAAC6D,OAAO;IAClC;IACA,IAAIrB,SAAS,CAACsB,YAAY,GAAG,CAAC,EAAE;MAC9BlC,MAAM,CAACG,SAAS,GAAG/B,OAAO,CAAC+B,SAAS;IACtC,CAAC,MAAM;MACLS,SAAS,CAACuB,cAAc,GAAG,CAAC;MAC5B,MAAMC,QAAQ,GAAG3F,QAAQ,CAAC4F,WAAW,CAACzB,SAAS,EAAEC,QAAQ,EACvDC,eAAe,CAAC;MAClB,IAAIsB,QAAQ,EAAE;QACZpC,MAAM,CAACoC,QAAQ,GAAGA,QAAQ;MAC5B;MACA,IAAItB,eAAe,EAAE;QACnB,IAAI,CAACF,SAAS,CAACW,OAAO,EAAE;UACtBvB,MAAM,CAACsC,YAAY,GAAG1B,SAAS,CAAC2B,QAAQ;UACxC,OAAO3B,SAAS,CAAC2B,QAAQ;QAC3B;QACA,IAAI3C,OAAO,CAAC6B,YAAY,EAAE;UACxBzB,MAAM,CAACyB,YAAY,GAAG7B,OAAO,CAAC6B,YAAY;QAC5C;QACA,IAAI7B,OAAO,CAAC4B,WAAW,EAAE;UACvBxB,MAAM,CAACwB,WAAW,GAAG5B,OAAO,CAAC4B,WAAW;QAC1C;MACF,CAAC,MAAM;QACL,IAAIZ,SAAS,CAACW,OAAO,IAAI3B,OAAO,CAAC4C,iBAAiB,EAAE;UAClDxC,MAAM,CAACyC,eAAe,GAAG7C,OAAO,CAAC4C,iBAAiB;QACpD;QACA,IAAI5B,SAAS,CAAC8B,SAAS,EAAE;UACvB1C,MAAM,CAAC0C,SAAS,GAAG9B,SAAS,CAAC8B,SAAS;UACtC,OAAO9B,SAAS,CAAC8B,SAAS;QAC5B;QACA,IAAI9B,SAAS,CAACW,OAAO,EAAE;UACrB,IAAIX,SAAS,CAAC2B,QAAQ,EAAE;YACtBvC,MAAM,CAACsC,YAAY,GAAG1B,SAAS,CAAC2B,QAAQ;UAC1C;QACF,CAAC,MAAM;UACLvC,MAAM,CAACsC,YAAY,GAAG1B,SAAS,CAAC2B,QAAQ,IAAI,CAAC;QAC/C;QACA,IAAI3B,SAAS,CAAC2B,QAAQ,EAAE;UACtB,OAAO3B,SAAS,CAAC2B,QAAQ;QAC3B;MACF;MACA,IAAI,CAACI,gBAAgB,CAAC/B,SAAS,CAAC;IAClC;IAEA,OAAOZ,MAAM;EACf;;EAEA;EACA;EACA;EACA;EACA;EACA,MAAM4C,iBAAiBA,CAACC,GAAG,EAAE9D,IAAI,EAAE;IACjC,IAAI+D,UAAU,EAAEC,KAAK;IACrB,MAAMC,QAAQ,GAAGH,GAAG,CAACI,SAAS,CAAC,CAAC;IAChC,QAAQD,QAAQ;MACd,KAAKrG,SAAS,CAACuG,uBAAuB;MACtC,KAAKvG,SAAS,CAACwG,sBAAsB;QACnCpE,IAAI,CAACqE,WAAW,GAAGvG,KAAK,CAACwG,cAAc;QACvC;MACF,KAAK1G,SAAS,CAAC2G,wBAAwB;MACvC,KAAK3G,SAAS,CAAC4G,qBAAqB;QAClCxE,IAAI,CAACO,OAAO,GAAGuD,GAAG,CAACW,YAAY,CAAC,CAAC;QACjCV,UAAU,GAAIE,QAAQ,KAAKrG,SAAS,CAAC2G,wBAAwB,GAC3D3G,SAAS,CAAC8G,qBAAqB,GAAG9G,SAAS,CAAC+G,kBAAkB;QAChEX,KAAK,GAAGF,GAAG,CAACI,SAAS,CAAC,CAAC;QACvBlE,IAAI,CAACqE,WAAW,GAAGvG,KAAK,CAAC8G,mBAAmB,CAACb,UAAU,EAAEC,KAAK,CAAC;QAC/D;MACF,KAAKpG,SAAS,CAACiH,oBAAoB;QACjC7E,IAAI,CAACqE,WAAW,GAAGvG,KAAK,CAACgH,WAAW;QACpC;MACF,KAAKlH,SAAS,CAACmH,6BAA6B;QAC1C/E,IAAI,CAACqE,WAAW,GAAGvG,KAAK,CAACkH,oBAAoB;QAC7C;MACF,KAAKpH,SAAS,CAACqH,8BAA8B;QAC3CjF,IAAI,CAACqE,WAAW,GAAGvG,KAAK,CAACoH,qBAAqB;QAC9C;MACF,KAAKtH,SAAS,CAACuH,qBAAqB;QAClCnF,IAAI,CAACqE,WAAW,GAAGvG,KAAK,CAACsH,YAAY;QACrC;MACF,KAAKxH,SAAS,CAACyH,0BAA0B;QACvCrF,IAAI,CAACqE,WAAW,GAAGvG,KAAK,CAACwH,iBAAiB;QAC1C;MACF,KAAK1H,SAAS,CAAC2H,8BAA8B;QAC3CvF,IAAI,CAACqE,WAAW,GAAGvG,KAAK,CAAC0H,qBAAqB;QAC9C;MACF,KAAK5H,SAAS,CAAC6H,6BAA6B;QAC1CzF,IAAI,CAACqE,WAAW,GAAGvG,KAAK,CAAC4H,oBAAoB;QAC7C;MACF,KAAK9H,SAAS,CAAC+H,wBAAwB;QACrC3F,IAAI,CAACqE,WAAW,GAAGvG,KAAK,CAAC8H,eAAe;QACxC;MACF,KAAKhI,SAAS,CAACiI,qBAAqB;QAClC,IAAI,CAACC,gCAAgC,CAAC9F,IAAI,CAAC;QAC3C;MACF,KAAKpC,SAAS,CAACmI,qBAAqB;QAClC/F,IAAI,CAACqE,WAAW,GAAGvG,KAAK,CAACkI,YAAY;QACrC;MACF,KAAKpI,SAAS,CAACqI,oBAAoB;QACjCjG,IAAI,CAACqE,WAAW,GAAGvG,KAAK,CAACoI,cAAc;QACvC,MAAM,IAAI,CAACnG,wBAAwB,CAACC,IAAI,CAAC;QACzC;MACF;QACEjC,MAAM,CAACqE,QAAQ,CAACrE,MAAM,CAACoI,0BAA0B,EAAElC,QAAQ,CAAC;IAChE;EACF;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAMmC,SAASA,CAACC,GAAG,EAAErG,IAAI,EAAE;IAEzB;IACA,MAAM8D,GAAG,GAAG,IAAIxF,SAAS,CAAC+H,GAAG,CAAC;IAC9BvC,GAAG,CAACwC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAmB;IACpCxC,GAAG,CAACwC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAmB;IACpCxC,GAAG,CAACwC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAmB;;IAEpC;IACA;IACA,MAAMC,QAAQ,GAAGzC,GAAG,CAACW,YAAY,CAAC,CAAC;IACnC,IAAI8B,QAAQ,GAAG,CAAC,EAAE;MAChBvG,IAAI,CAACwG,YAAY,GAAG,KAAK;MACzB;IACF;;IAEA;IACA1C,GAAG,CAACwC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAmB;IACpCxC,GAAG,CAACwC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAmB;IACpCxC,GAAG,CAACwC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAmB;IACpCxC,GAAG,CAACwC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAmB;;IAEpC;IACA;IACA,MAAMrC,QAAQ,GAAGH,GAAG,CAACI,SAAS,CAAC,CAAC;IAChClE,IAAI,CAACwG,YAAY,GAAIvC,QAAQ,KAAKrG,SAAS,CAAC6I,qBAAsB;IAClE,IAAI,CAACzG,IAAI,CAACwG,YAAY,EACpB;;IAEF;IACA,MAAME,UAAU,GAAG5C,GAAG,CAAC6C,YAAY,CAAC,CAAC;IACrC3G,IAAI,CAAC4G,cAAc,GAAG9C,GAAG,CAAC6C,YAAY,CAAC,CAAC;IACxC3G,IAAI,CAAC6G,cAAc,GAAG/C,GAAG,CAACI,SAAS,CAAC,CAAC;IACrC,IAAIlE,IAAI,CAAC6G,cAAc,KAAKjJ,SAAS,CAACkJ,yBAAyB,EAAE;MAC/D9G,IAAI,CAAC+G,eAAe,GAAGnJ,SAAS,CAACoJ,mBAAmB;IACtD;IACAlD,GAAG,CAACmD,GAAG,GAAGP,UAAU;IAEpB,MAAM,IAAI,CAAC7C,iBAAiB,CAACC,GAAG,EAAE9D,IAAI,CAAC;EACzC;;EAEA;EACA;EACA;EACA;EACA;EACA,MAAMkH,yBAAyBA,CAAChH,IAAI,EAAE;IAEpC;IACA,MAAMS,GAAG,GAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;IACP,MAAMV,KAAK,GAAG,CACZ;MACEC,IAAI,EAAE,WAAW;MACjBC,IAAI,EAAErC,KAAK,CAACsC,eAAe;MAC3BC,GAAG,EAAEzC,SAAS,CAACuJ,UAAU;MACzB5G,OAAO,EAAE,GAAG;MACZC,MAAM,EAAE,CAACN,IAAI;IACf,CAAC,EACD;MACEA,IAAI,EAAE,SAAS;MACfC,IAAI,EAAErC,KAAK,CAACsJ,sBAAsB;MAClC/G,GAAG,EAAEzC,SAAS,CAACyJ,QAAQ;MACvB7G,MAAM,EAAE;IACV,CAAC,EACD;MACEN,IAAI,EAAE,KAAK;MACXC,IAAI,EAAErC,KAAK,CAACgH,WAAW;MACvBvE,OAAO,EAAE,EAAE;MACXF,GAAG,EAAEzC,SAAS,CAACyJ,QAAQ;MACvB7G,MAAM,EAAE;IACV,CAAC,EACD;MACEN,IAAI,EAAE,SAAS;MACfC,IAAI,EAAErC,KAAK,CAACsJ,sBAAsB;MAClC/G,GAAG,EAAEzC,SAAS,CAACyJ,QAAQ;MACvB7G,MAAM,EAAE;IACV,CAAC,EACD;MACEN,IAAI,EAAE,KAAK;MACXC,IAAI,EAAErC,KAAK,CAACgH,WAAW;MACvBvE,OAAO,EAAE,IAAI;MACbF,GAAG,EAAEzC,SAAS,CAACyJ,QAAQ;MACvB7G,MAAM,EAAE;IACV,CAAC,EACD;MACEN,IAAI,EAAE,UAAU;MAChBC,IAAI,EAAErC,KAAK,CAACwJ,cAAc;MAC1BjH,GAAG,EAAEzC,SAAS,CAACyJ,QAAQ;MACvB7G,MAAM,EAAE;IACV,CAAC,EACD;MACEN,IAAI,EAAE,cAAc;MACpBC,IAAI,EAAErC,KAAK,CAACsC,eAAe;MAC3BG,OAAO,EAAE,GAAG;MACZF,GAAG,EAAEzC,SAAS,CAACyJ,QAAQ;MACvB7G,MAAM,EAAE;IACV,CAAC,EACD;MACEN,IAAI,EAAE,QAAQ;MACdC,IAAI,EAAErC,KAAK,CAACsC,eAAe;MAC3BG,OAAO,EAAE,GAAG;MACZF,GAAG,EAAEzC,SAAS,CAACyJ,QAAQ;MACvB7G,MAAM,EAAE;IACV,CAAC,EACD;MACEN,IAAI,EAAE,MAAM;MACZC,IAAI,EAAErC,KAAK,CAACsC,eAAe;MAC3BG,OAAO,EAAE,GAAG;MACZF,GAAG,EAAEzC,SAAS,CAACyJ,QAAQ;MACvB7G,MAAM,EAAE;IACV,CAAC,CACF;IACD,MAAMK,OAAO,GAAG;MACdC,UAAU,EAAE;QAAEC,KAAK,EAAE;MAAK,CAAC;MAC3BwG,oBAAoB,EAAE;IACxB,CAAC;IACD,MAAMtG,MAAM,GAAG,MAAM,IAAI,CAACC,OAAO,CAACP,GAAG,EAAE,CAAC,EAAEV,KAAK,EAAEY,OAAO,EAAE,KAAK,CAAC;IAChE,IAAII,MAAM,CAACoC,QAAQ,CAACmE,OAAO,KAAK,CAAC,EAAE;MACjCzJ,MAAM,CAACqE,QAAQ,CAACrE,MAAM,CAAC0J,4BAA4B,EAAEvH,IAAI,CAAC;IAC5D;;IAEA;IACA,MAAMF,IAAI,GAAG,IAAI,CAACwB,gBAAgB,CAACP,MAAM,CAACoC,QAAQ,CAAC5C,MAAM,EACvDQ,MAAM,CAACoC,QAAQ,CAACnD,IAAI,EAAEe,MAAM,CAACoC,QAAQ,CAACqE,YAAY,EAAEzG,MAAM,CAACoC,QAAQ,CAACsE,GAAG,CAAC;IAC1E,IAAI,CAAC3H,IAAI,CAACyB,OAAO,EACf,OAAOzB,IAAI;;IAEb;IACAA,IAAI,CAAC4H,OAAO,GAAG3G,MAAM,CAACoC,QAAQ,CAACuE,OAAO;IACtC,MAAM,IAAI,CAACxB,SAAS,CAACnF,MAAM,CAACoC,QAAQ,CAACgD,GAAG,EAAErG,IAAI,CAAC;IAC/C,MAAM6H,QAAQ,GAAG,MAAM5G,MAAM,CAACoC,QAAQ,CAACyE,QAAQ,CAACzG,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;IACjE,IAAIwG,QAAQ,CAAC3F,MAAM,GAAG,CAAC,EAAE;MACvBlC,IAAI,CAAC+H,UAAU,GAAG,EAAE;MACpB,KAAK,MAAMzG,GAAG,IAAIuG,QAAQ,EAAE;QAC1B,MAAMG,IAAI,GAAG;UAAE9H,IAAI,EAAEoB,GAAG,CAAC,CAAC;QAAE,CAAC;QAC7B,IAAIA,GAAG,CAAC,CAAC,CAAC,EAAE;UACV0G,IAAI,CAAC7H,IAAI,GAAGrC,KAAK,CAACoI,cAAc;UAChC8B,IAAI,CAACC,SAAS,GAAG,IAAI,CAACzG,gBAAgB,CAACF,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,CAAC;UACtE,IAAI0G,IAAI,CAACC,SAAS,CAACxG,OAAO,EAAE;YAC1B,IAAI,CAACC,qBAAqB,CAACC,IAAI,CAACqG,IAAI,CAACC,SAAS,CAAC;UACjD;QACF,CAAC,MAAM;UACLD,IAAI,CAAC7H,IAAI,GAAGrC,KAAK,CAACoK,uBAAuB,CAAC5G,GAAG,CAAC,CAAC,CAAC,CAAC;QACnD;QACAtB,IAAI,CAAC+H,UAAU,CAACpG,IAAI,CAACqG,IAAI,CAAC;MAC5B;IACF;IACAhI,IAAI,CAACyB,OAAO,GAAG,KAAK;IAEpB,OAAOzB,IAAI;EAEb;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAMmI,6BAA6BA,CAAA,EAAG;IACpC,OAAO,IAAI,CAACzG,qBAAqB,CAACQ,MAAM,GAAG,CAAC,EAAE;MAC5C,MAAMlC,IAAI,GAAG,IAAI,CAAC0B,qBAAqB,CAACd,GAAG,CAAC,CAAC;MAC7C,IAAIwH,MAAM,GAAG,UAAU;MACvB,IAAIlI,IAAI,GAAGF,IAAI,CAACE,IAAI;MACpB,IAAIA,IAAI,CAACmI,QAAQ,CAACD,MAAM,CAAC,EAAE;QACzBlI,IAAI,GAAGA,IAAI,CAACoI,SAAS,CAAC,CAAC,EAAEpI,IAAI,CAACgC,MAAM,GAAGkG,MAAM,CAAClG,MAAM,CAAC;MACvD,CAAC,MAAM;QACLkG,MAAM,GAAG,EAAE;MACb;MACA,IAAIG,QAAQ;MACZ,IAAIvI,IAAI,CAACU,WAAW,EAAE;QACpB6H,QAAQ,GAAI,IAAGvI,IAAI,CAACS,MAAO,MAAKT,IAAI,CAACU,WAAY,MAAKR,IAAK,IAAGkI,MAAO,EAAC;MACxE,CAAC,MAAM;QACLG,QAAQ,GAAI,IAAGvI,IAAI,CAACS,MAAO,MAAKP,IAAK,IAAGkI,MAAO,EAAC;MAClD;MACA,MAAM,IAAI,CAAClB,yBAAyB,CAACqB,QAAQ,CAAC;IAChD;EACF;EAEA,MAAMC,MAAMA,CAAA,EAAG;IACb,MAAMnJ,OAAO,GAAG,IAAIrB,QAAQ,CAACyK,aAAa,CAAC,IAAI,CAAC;IAChD,MAAM,IAAI,CAAC9J,SAAS,CAACY,eAAe,CAACF,OAAO,CAAC;EAC/C;EAEA,MAAMqJ,cAAcA,CAAA,EAAG;IACrB,MAAM,IAAI,CAAC/J,SAAS,CAACgK,YAAY,CAAC,CAAC;EACrC;EAEAC,SAASA,CAAA,EAAG;IACV,IAAI;MACF,IAAI,IAAI,CAACpJ,KAAK,CAACqJ,eAAe,CAAC,CAAC,KAAK,CAAC,EACpC,OAAO,IAAI;MACb,OAAO,KAAK;IACd,CAAC,CAAC,MAAM;MACN,OAAO,KAAK;IACd;EACF;EAEAjJ,QAAQA,CAAA,EAAG;IACT,OAAQ,IAAI,CAACV,KAAK,GAAI,IAAI,GAAG,KAAK;EACpC;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA4J,yBAAyBA,CAACC,IAAI,EAAE;IAC9B,IAAIC,MAAM;IACV,IAAID,IAAI,EAAE;MACR,MAAME,GAAG,GAAGF,IAAI,IAAK,IAAI,CAACG,WAAW,GAAI,IAAI,CAACA,WAAW,GAAG,IAAI,CAACC,GAAG,CAAC;MACrEH,MAAM,GAAGzK,iBAAiB,CAAC6K,GAAG,CAACH,GAAG,CAAC;MACnC,IAAI,CAACD,MAAM,EAAE;QACXA,MAAM,GAAG,CAAC,CAAC;QACXzK,iBAAiB,CAAC8K,GAAG,CAACJ,GAAG,EAAED,MAAM,CAAC;MACpC;IACF;IACA,OAAOA,MAAM;EACf;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMM,OAAOA,CAACC,MAAM,EAAE;IACpB,IAAI,CAACA,MAAM,CAACC,aAAa,EAAE;MACzBzL,MAAM,CAACqE,QAAQ,CAACrE,MAAM,CAAC0L,wBAAwB,CAAC;IAClD;IACA/L,QAAQ,CAACgM,gBAAgB,CAACH,MAAM,CAAC;IAEjC,IAAI,CAACI,SAAS,GAAG,CAAC;IAClB,IAAI,CAACC,SAAS,GAAG,CAAC;IAClB,IAAI,CAACC,UAAU,GAAG,KAAK;IACvB,IAAI,CAACC,aAAa,GAAG,EAAE;IACvB,IAAI,CAACC,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACC,aAAa,GAAG,EAAE;IACvB,IAAI,CAACC,qBAAqB,GAAG,IAAI;IACjC,IAAI,CAACF,cAAc,GAAG,IAAIvL,GAAG,CAAC,CAAC;IAC/B,IAAI,CAAC0L,kBAAkB,GAAGX,MAAM,CAACY,aAAa;IAC9C,IAAI,CAACC,kBAAkB,GAAG,CAAC;IAC3B,IAAI,CAACC,sBAAsB,GAAG,KAAK;IACnC,IAAI,CAACC,eAAe,GAAG,IAAIC,GAAG,CAAC,CAAC;IAChC,IAAI,CAACC,gBAAgB,GAAG,EAAE;IAC1B,IAAI,CAACC,kBAAkB,GAAG,CAAC;IAC3B,IAAI,CAACxL,qBAAqB,GAAG,KAAK;IAClC,IAAI,CAACyL,OAAO,GAAG,IAAI;IACnB,IAAI,CAACC,iBAAiB,GAAG,EAAE;IAC3B,IAAI,CAACC,yBAAyB,GAAG,KAAK;IACtC,IAAI,CAACC,OAAO,GAAG,EAAE;IACjB,IAAI,CAACC,eAAe,GAAG,KAAK;IAC5B,IAAI,CAACC,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,aAAa,GAAG,KAAK;IAC1B,IAAI,CAACC,WAAW,GAAG,EAAE;IACrB,IAAI,CAACC,mBAAmB,GAAG,KAAK;IAChC,IAAI,CAACC,OAAO,GAAG,EAAE;IACjB,IAAI,CAACC,eAAe,GAAG,KAAK;IAC5B,IAAI,CAACrM,YAAY,GAAG,KAAK;IACzB,IAAI,CAACmK,WAAW,GAAG,EAAE;IACrB,IAAI,CAACmC,aAAa,GAAG,EAAE;IACvB,IAAI,CAACC,QAAQ,GAAG,IAAI,CAAC,CAAC;;IAEtB,IAAI,CAAC9L,KAAK,GAAG,IAAIhC,GAAG,CAAC,CAAC;IACtBS,oBAAoB,CAACsN,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC/L,KAAK,CAAC;IAC/C,MAAM,IAAI,CAACA,KAAK,CAAC8J,OAAO,CAACC,MAAM,CAAC;IAEhC,IAAIiC,UAAU;IACd,IAAI,IAAI,CAAC5L,QAAQ,CAAC,CAAC,EAAE;MACnB4L,UAAU,GAAGjC,MAAM,CAACkC,SAAS,CAAC,CAAC,CAAC;MAChC,IAAI,CAACvC,WAAW,GAAGK,MAAM,CAACkC,SAAS,CAAC,CAAC,CAAC;MACtC,IAAI,CAACC,MAAM,GAAGnC,MAAM,CAACkC,SAAS,CAAC,CAAC,CAAC,GAAG7N,SAAS,CAAC+N,cAAc;MAC5D,IAAI,CAACxC,GAAG,GAAGI,MAAM,CAACkC,SAAS,CAAC,CAAC,CAAC;IAChC,CAAC,MAAM;MACLD,UAAU,GAAG,IAAI,CAAChM,KAAK,CAACoM,SAAS,CAACjO,eAAe,CAACkO,UAAU,CAAC;MAC7D,IAAI,CAAC3C,WAAW,GAAG,IAAI,CAAC1J,KAAK,CAACoM,SAAS,CAACjO,eAAe,CAACmO,OAAO,CAAC;MAChE,IAAI,CAAC3C,GAAG,GAAG,IAAI,CAAC3J,KAAK,CAACoM,SAAS,CAACjO,eAAe,CAACoO,GAAG,CAAC;MACpD,IAAI,CAACL,MAAM,GAAG,IAAI,CAAClM,KAAK,CAACoM,SAAS,CAACjO,eAAe,CAACqO,MAAM,CAAC,GAAGpO,SAAS,CAAC+N,cAAc;IACvF;IACA,IAAIH,UAAU,EAAE;MACd,IAAI,CAACzM,YAAY,GAAGyM,UAAU,CAACS,WAAW,CAAC,CAAC,KAAK,QAAQ;IAC3D;IACA,IAAI,CAACZ,aAAa,GAAG,IAAI,CAAC7L,KAAK,CAACoM,SAAS,CAACjO,eAAe,CAACuO,UAAU,CAAC;IACrE,IAAI,CAACC,eAAe,GAAG5C,MAAM,CAAC4C,eAAe;;IAE7C;AACJ;AACA;AACA;AACA;IACI,IAAI,IAAI,CAACT,MAAM,KAAK9N,SAAS,CAAC+N,cAAc,IAAI,IAAI,CAAC5M,YAAY,EAAE;MACjE,IAAI,IAAI,CAACa,QAAQ,CAAC,CAAC,EAAE;QACnB,IAAI,CAAC8L,MAAM,GAAG9N,SAAS,CAACwO,WAAW;MACrC,CAAC,MAAM;QACL,IAAI,CAACV,MAAM,GAAG9N,SAAS,CAACyO,UAAU;MACpC;IACF;IAEA,IAAI,CAAC1N,SAAS,GAAG,IAAItB,QAAQ,CAAC,IAAI,CAAC;;IAEnC;IACA;IACA,IAAI,IAAI,CAACsB,SAAS,CAAC2N,IAAI,CAACC,eAAe,GAAG3O,SAAS,CAAC4O,wBAAwB,EAAE;MAC5EzO,MAAM,CAACqE,QAAQ,CAACrE,MAAM,CAAC0O,gCAAgC,CAAC;IAC1D;IAEA,IAAI;MACF,MAAMzD,MAAM,GAAG,IAAI,CAACF,yBAAyB,CAAC,IAAI,CAACtJ,KAAK,CAACkN,MAAM,CAAC;MAChE,IAAI,CAAClN,KAAK,CAACkN,MAAM,GAAG,IAAI;MACxB,MAAMC,eAAe,GAAG,IAAI3O,QAAQ,CAAC4O,eAAe,CAAC,IAAI,CAAC;MAC1D,MAAMC,eAAe,GAAG,IAAI7O,QAAQ,CAAC8O,eAAe,CAAC,IAAI,CAAC;MAC1D,MAAMC,WAAW,GAAG,IAAI/O,QAAQ,CAACgP,WAAW,CAAC,IAAI,EAAEzD,MAAM,CAAC;MAC1D,IAAI0D,UAAU,GAAG,KAAK;MACtB,IAAIjE,MAAM,IAAIA,MAAM,CAACkE,SAAS,EAAE;QAC9B,MAAMC,aAAa,GAAG,IAAInP,QAAQ,CAACoP,uBAAuB,CAAC,IAAI,CAAC;QAChED,aAAa,CAACnE,MAAM,GAAGA,MAAM;QAC7BmE,aAAa,CAACR,eAAe,GAAGA,eAAe;QAC/CQ,aAAa,CAACN,eAAe,GAAGA,eAAe;QAC/CM,aAAa,CAACJ,WAAW,GAAGA,WAAW;QACvC,MAAM,IAAI,CAACpO,SAAS,CAACY,eAAe,CAAC4N,aAAa,CAAC;QACnDF,UAAU,GAAG,IAAI;MACnB,CAAC,MAAM;QACL,MAAM,IAAI,CAACtO,SAAS,CAACY,eAAe,CAACoN,eAAe,CAAC;MACvD;MACA,IAAI,CAACM,UAAU,IAAI,CAACjE,MAAM,CAACkE,SAAS,EAAE;QACpC,MAAM,IAAI,CAACvO,SAAS,CAACY,eAAe,CAACsN,eAAe,CAAC;QACrD;QACA,MAAM,IAAI,CAAClO,SAAS,CAACY,eAAe,CAACwN,WAAW,CAAC;QACjD,IAAI/D,MAAM,IAAI,CAACA,MAAM,CAACkE,SAAS,EAAE;UAC/BlE,MAAM,CAACuD,eAAe,GAAGI,eAAe,CAAC7C,aAAa;UACtDd,MAAM,CAACqE,YAAY,GAAGV,eAAe,CAACU,YAAY;UAClDrE,MAAM,CAACsE,SAAS,GAAG,IAAI,CAAC3O,SAAS,CAAC2N,IAAI,CAACiB,SAAS;UAChDvE,MAAM,CAACwE,UAAU,GAAG,IAAI,CAAC7O,SAAS,CAAC2N,IAAI,CAACmB,UAAU;UAClDzE,MAAM,CAAC0E,KAAK,GAAGf,eAAe,CAACgB,WAAW;UAC1C3E,MAAM,CAAC4E,WAAW,GAAG5Q,MAAM,CAAC6Q,IAAI,CAAClB,eAAe,CAACmB,iBAAiB,CAAC;UACnE9E,MAAM,CAAC+E,WAAW,GAAG/Q,MAAM,CAAC6Q,IAAI,CAAClB,eAAe,CAACqB,iBAAiB,CAAC;UACnEhF,MAAM,CAACkE,SAAS,GAAG,IAAI;QACzB;MACF;MACA,IAAI,CAAC3D,MAAM,CAAC0E,KAAK,EAAE;QAAE;QACnB,MAAM,IAAI,CAACtP,SAAS,CAACY,eAAe,CAACwN,WAAW,CAAC,CAAC,CAAC;MACrD;IACF,CAAC,CAAC,OAAOtN,GAAG,EAAE;MACZ,IAAI,CAACD,KAAK,CAACnB,UAAU,CAAC,CAAC;MACvB,MAAMoB,GAAG;IACX;;IAEA;IACA,IAAI,CAACiC,qBAAqB,GAAG,EAAE;IAE/B,IAAI6H,MAAM,CAAC2E,SAAS,EAAE;MACpB,IAAI,CAACC,QAAQ,GAAGnR,MAAM,CAAC6Q,IAAI,CAACtE,MAAM,CAAC2E,SAAS,CAAC;IAC/C,CAAC,MAAM,IAAIrQ,OAAO,CAACuQ,GAAG,CAACC,cAAc,EAAE;MACrC,IAAI,CAACF,QAAQ,GAAGnR,MAAM,CAAC6Q,IAAI,CAAChQ,OAAO,CAACuQ,GAAG,CAACC,cAAc,CAAC;IACzD;IACA,IAAI,CAAC1P,SAAS,CAAC2P,cAAc,GAAG,KAAK;EACvC;;EAEA;EACA;EACA;EACA1K,gBAAgBA,CAAC/B,SAAS,EAAE;IAC1B,IAAIA,SAAS,CAACI,YAAY,EAAE;MAC1BJ,SAAS,CAACI,YAAY,CAACsM,OAAO,CAACC,QAAQ,IAAI;QACzCA,QAAQ,CAACC,OAAO,GAAG,IAAI;MACzB,CAAC,CAAC;IACJ;IACA,IAAI5M,SAAS,CAAC6M,SAAS,EAAE;MACvB7M,SAAS,CAAC6M,SAAS,CAACH,OAAO,CAACI,QAAQ,IAAI;QACtCA,QAAQ,CAACnO,MAAM,CAACoO,IAAI,CAAC,IAAI,CAAC;MAC5B,CAAC,CAAC;IACJ;IACA,IAAI/M,SAAS,CAACgN,aAAa,EAAE;MAC3BhN,SAAS,CAACiN,KAAK,GAAG,KAAK;IACzB,CAAC,MAAM,IAAIjN,SAAS,CAACkN,QAAQ,KAAK,CAAC,EAAE;MACnC,IAAI,CAACC,iBAAiB,CAACnN,SAAS,CAACkN,QAAQ,CAAC;IAC5C;EACF;;EAEA;EACA;EACA;EACAC,iBAAiBA,CAACD,QAAQ,EAAE;IAC1B,IAAI,IAAI,CAACzE,eAAe,CAAC2E,GAAG,CAACF,QAAQ,CAAC,EAAE;MACtC,MAAMG,MAAM,GAAI,2BAA0BH,QAAS,QAAO;MAC1DhR,MAAM,CAACqE,QAAQ,CAACrE,MAAM,CAACoR,YAAY,EAAED,MAAM,CAAC;IAC9C;IACA,IAAI,CAAC5E,eAAe,CAAC8E,GAAG,CAACL,QAAQ,CAAC;EACpC;;EAEA;EACA;EACA;EACAM,qBAAqBA,CAAA,EAAG;IACtB,OAAO,IAAI,CAACtF,cAAc,CAACuF,IAAI,GAAG,IAAI,CAACpF,kBAAkB,EAAE;MACzD,MAAMvJ,GAAG,GAAG,IAAI,CAACoJ,cAAc,CAACwF,IAAI,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,CAACC,KAAK;MACnD,MAAMC,IAAI,GAAG,IAAI,CAAC3F,cAAc,CAACX,GAAG,CAACzI,GAAG,CAAC;MACzC,IAAI,CAACoJ,cAAc,CAAC4F,MAAM,CAAChP,GAAG,CAAC;MAC/B,IAAI+O,IAAI,CAACZ,KAAK,EAAE;QACdY,IAAI,CAACb,aAAa,GAAG,KAAK;MAC5B,CAAC,MAAM,IAAIa,IAAI,CAACX,QAAQ,KAAK,CAAC,EAAE;QAC9B,IAAI,CAACC,iBAAiB,CAACU,IAAI,CAACX,QAAQ,CAAC;MACvC;IACF;EACF;;EAEA;EACA;EACA;EACA;EACAa,QAAQA,CAACjP,GAAG,EAAEE,OAAO,EAAE;IACrB,MAAMgB,SAAS,GAAG,IAAI,CAACgO,aAAa,CAAClP,GAAG,EAAEE,OAAO,CAACiP,eAAe,CAAC;IAClEjO,SAAS,CAACuB,cAAc,GAAG,CAAC;IAC5BvB,SAAS,CAACkO,cAAc,GAAG,CAAC;IAC5BlO,SAAS,CAACmO,YAAY,GAAG,CAAC;IAC1BnO,SAAS,CAACoO,eAAe,GAAG,IAAI;IAChC,OAAOpO,SAAS;EAClB;;EAEA;EACA;EACA;EACA,MAAMU,KAAKA,CAACmN,IAAI,EAAEQ,QAAQ,EAAEjJ,GAAG,GAAG,CAAC,EAAE;IACnC,MAAMkJ,YAAY,GAAGT,IAAI,CAACS,YAAY;IACtC,MAAMlO,YAAY,GAAGyN,IAAI,CAACzN,YAAY;;IAEtC;AACJ;AACA;AACA;AACA;AACA;IACI,IAAIyN,IAAI,CAAClN,OAAO,IAAI0N,QAAQ,CAAC3P,OAAO,GAAG,KAAK,EAAE;MAC5C,IAAI2P,QAAQ,CAAC/P,IAAI,KAAKrC,KAAK,CAACgH,WAAW,IACnCoL,QAAQ,CAAC/P,IAAI,KAAKrC,KAAK,CAACsS,gBAAgB,EAAE;QAC5CF,QAAQ,CAAC/P,IAAI,GAAGrC,KAAK,CAACkI,YAAY;MACpC,CAAC,MAAM,IAAIkK,QAAQ,CAAC/P,IAAI,CAACkQ,MAAM,KAAKzS,SAAS,CAAC0S,WAAW,EAAG;QAC1DJ,QAAQ,CAAC/P,IAAI,GAAGrC,KAAK,CAACyS,aAAa;MACrC,CAAC,MAAM;QACLL,QAAQ,CAAC/P,IAAI,GAAGrC,KAAK,CAAC0S,YAAY;MACpC;MACA,MAAMjQ,OAAO,GAAG2P,QAAQ,CAAC3P,OAAO;MAChC,OAAO2P,QAAQ,CAAC3P,OAAO;MACvB2P,QAAQ,CAACO,YAAY,GAAG,gBAAeC,GAAG,EAAE;QAC1C,IAAIA,GAAG,KAAK,IAAI,EAAE;UAChB,OAAO,IAAI;QACb;QACA,MAAMC,IAAI,GAAG,MAAMD,GAAG,CAACE,OAAO,CAAC,CAAC;QAChC,MAAMC,GAAG,GAAGH,GAAG,CAACI,OAAO;QACvB,IAAIH,IAAI,IAAIE,GAAG,GAAGtQ,OAAO,EAAE;UACzBxC,MAAM,CAACqE,QAAQ,CAACrE,MAAM,CAACgT,iCAAiC,CAAC;QAC3D;QACA,OAAOJ,IAAI;MACb,CAAC;IACH;IAEA,IAAIT,QAAQ,CAAC/P,IAAI,KAAKrC,KAAK,CAAC0S,YAAY,IACpCN,QAAQ,CAAC/P,IAAI,KAAKrC,KAAK,CAACyS,aAAa,IACrCL,QAAQ,CAAC/P,IAAI,KAAKrC,KAAK,CAACkI,YAAY,EAAE;MACxC,KAAK,MAAM,CAACgL,KAAK,EAAEN,GAAG,CAAC,IAAIR,QAAQ,CAAC1P,MAAM,CAACyQ,OAAO,CAAC,CAAC,EAAE;QACpD,IAAI,EAAEP,GAAG,YAAYtT,WAAW,CAAC,EAAE;UACjC,IAAIsT,GAAG,IAAIA,GAAG,CAACxO,MAAM,GAAG,CAAC,EAAE;YACzB,MAAMgP,OAAO,GAAG,IAAI9T,WAAW,CAAC,CAAC;YACjC,MAAM8T,OAAO,CAACC,MAAM,CAAC,IAAI,EAAEjB,QAAQ,CAAC/P,IAAI,CAAC;YACzC,MAAM+Q,OAAO,CAACE,KAAK,CAAC,CAAC,EAAEV,GAAG,CAAC;YAC3BR,QAAQ,CAAC1P,MAAM,CAACwQ,KAAK,CAAC,GAAGE,OAAO;UAClC,CAAC,MAAM;YACLhB,QAAQ,CAAC1P,MAAM,CAACwQ,KAAK,CAAC,GAAG,IAAI;UAC/B;QACF;MACF;IACF;IAEA,IAAId,QAAQ,CAAChQ,IAAI,EAAE;MACjB,IAAImR,cAAc;MAClB,IAAInB,QAAQ,CAAChQ,IAAI,CAACoR,UAAU,CAAC,GAAG,CAAC,IAAIpB,QAAQ,CAAChQ,IAAI,CAACmI,QAAQ,CAAC,GAAG,CAAC,EAAE;QAChEgJ,cAAc,GAAGnB,QAAQ,CAAChQ,IAAI,CAACoI,SAAS,CAAC,CAAC,EAAE4H,QAAQ,CAAChQ,IAAI,CAACgC,MAAM,GAAG,CAAC,CAAC;MACvE,CAAC,MAAM;QACLmP,cAAc,GAAGnB,QAAQ,CAAChQ,IAAI,CAACqR,WAAW,CAAC,CAAC;MAC9C;MACA,IAAIF,cAAc,CAACC,UAAU,CAAC,GAAG,CAAC,EAAE;QAClCD,cAAc,GAAGnB,QAAQ,CAAChQ,IAAI,CAACoI,SAAS,CAAC,CAAC,CAAC;MAC7C;MACA,IAAI,CAAC6H,YAAY,CAAClB,GAAG,CAACoC,cAAc,CAAC,EAAE;QACrCtT,MAAM,CAACqE,QAAQ,CAACrE,MAAM,CAACyT,qBAAqB,EAAEH,cAAc,CAAC;MAC/D;MACAlB,YAAY,CAAC/G,GAAG,CAACiI,cAAc,CAAC,CAAC9C,OAAO,CAAEC,QAAQ,IAAK;QACrDkB,IAAI,CAAC+B,YAAY,CAACjD,QAAQ,EAAE0B,QAAQ,CAAC;MACvC,CAAC,CAAC;IACJ,CAAC,MAAM;MACL,MAAM1B,QAAQ,GAAGvM,YAAY,CAACgF,GAAG,GAAG,CAAC,CAAC;MACtCyI,IAAI,CAAC+B,YAAY,CAACjD,QAAQ,EAAE0B,QAAQ,CAAC;IACvC;EACF;;EAEA;EACA;EACA;EACA;EACA;EACAwB,gBAAgBA,CAAC7Q,OAAO,EAAEgB,SAAS,EAAE;IACnC,MAAMT,SAAS,GAAG,IAAIjE,iBAAiB,CAAC,CAAC;IACzC,IAAI,CAAC0E,SAAS,EAAE;MACdA,SAAS,GAAG,IAAIpE,SAAS,CAAC,CAAC;IAC7B;IACA2D,SAAS,CAACuQ,aAAa,CAAC,IAAI,EAAE9P,SAAS,EAAEhB,OAAO,CAAC;IACjD,IAAIgB,SAAS,CAAC6M,SAAS,CAACxM,MAAM,GAAG,CAAC,EAAE;MAClC,MAAM0P,QAAQ,GAAGlU,QAAQ,CAACmU,eAAe,CAAChQ,SAAS,CAAC6M,SAAS,CAAC;MAC9DtN,SAAS,CAAC0Q,MAAM,CAACjR,OAAO,EAAE+Q,QAAQ,CAAC;IACrC;IACA,OAAOxQ,SAAS;EAClB;;EAEA;EACA;EACA;EACA2Q,mBAAmBA,CAAA,EAAG;IACpB,IAAI,CAAChI,cAAc,CAACiI,KAAK,CAAC,CAAC;IAC3B,IAAI,CAAC1H,eAAe,CAAC0H,KAAK,CAAC,CAAC;EAC9B;;EAEA;EACA;EACA;EACA;EACA;EACA,MAAMC,gBAAgBA,CAAC/R,IAAI,EAAE;IAC3B,MAAMF,IAAI,GAAG,MAAM,IAAI,CAACkH,yBAAyB,CAAChH,IAAI,CAAC;IACvD,MAAM,IAAI,CAACiI,6BAA6B,CAAC,CAAC;IAC1C,OAAOnI,IAAI;EACb;;EAEA;EACA;EACA;EACA;EACA;EACA,MAAMkS,gBAAgBA,CAACvR,GAAG,EAAE;IAC1B,MAAME,OAAO,GAAG,CAAC,CAAC;IAClB,MAAMI,MAAM,GAAG,CAAC,CAAC;IACjB,MAAMY,SAAS,GAAG,IAAI,CAAC+N,QAAQ,CAACjP,GAAG,EAAEE,OAAO,CAAC;IAC7CA,OAAO,CAACC,UAAU,GAAG,IAAI;IACzB,IAAI;MACF,IAAI,CAACe,SAAS,CAACsQ,KAAK,EAAE;QACpB,MAAM9S,OAAO,GAAG,IAAIrB,QAAQ,CAAC4E,cAAc,CAAC,IAAI,EAAEf,SAAS,EAAEhB,OAAO,CAAC;QACrExB,OAAO,CAAC+S,SAAS,GAAG,IAAI;QACxB,MAAM,IAAI,CAACzT,SAAS,CAACY,eAAe,CAACF,OAAO,CAAC;MAC/C;MACA,IAAIwC,SAAS,CAACsB,YAAY,GAAG,CAAC,EAAE;QAC9BlC,MAAM,CAACoR,QAAQ,GAAG3U,QAAQ,CAACmU,eAAe,CAAChQ,SAAS,CAAC6M,SAAS,CAAC;MACjE;MACAzN,MAAM,CAACqR,SAAS,GAAGC,KAAK,CAAC1E,IAAI,CAAChM,SAAS,CAACsO,YAAY,CAACZ,IAAI,CAAC,CAAC,CAAC;MAC5DtO,MAAM,CAACuR,aAAa,GAAG3Q,SAAS,CAAC2Q,aAAa;MAC9C,OAAOvR,MAAM;IACf,CAAC,SAAS;MACR,IAAI,CAAC2C,gBAAgB,CAAC/B,SAAS,CAAC;IAClC;EACF;;EAEA;EACA;EACA;EACA;EACA;EACA,MAAMX,OAAOA,CAACP,GAAG,EAAEmB,QAAQ,EAAE7B,KAAK,EAAEY,OAAO,EAAEkB,eAAe,EAAE;IAC5D,MAAMF,SAAS,GAAG,IAAI,CAAC+N,QAAQ,CAACjP,GAAG,EAAEE,OAAO,CAAC;IAC7C,IAAI;MACF,OAAO,MAAM,IAAI,CAACe,QAAQ,CAACC,SAAS,EAAEC,QAAQ,EAAE7B,KAAK,EAAEY,OAAO,EAC5DkB,eAAe,CAAC;IACpB,CAAC,CAAC,OAAOtC,GAAG,EAAE;MACZ,IAAI,CAACmE,gBAAgB,CAAC/B,SAAS,CAAC;MAChC,MAAMpC,GAAG;IACX;EACF;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAoQ,aAAaA,CAAClP,GAAG,EAAE8R,cAAc,GAAG,KAAK,EAAE;IACzC,IAAI5Q,SAAS,GAAG,IAAI,CAACkI,cAAc,CAACX,GAAG,CAACzI,GAAG,CAAC;IAC5C,IAAI,CAACkB,SAAS,EAAE;MACdA,SAAS,GAAG,IAAIpE,SAAS,CAAC,CAAC;MAC3BoE,SAAS,CAAC+N,QAAQ,CAACjP,GAAG,CAAC;MACvB,IAAI8R,cAAc,IAAI,CAAC,IAAI,CAACxT,qBAAqB,IAAI,CAAC4C,SAAS,CAACsQ,KAAK,IACjE,IAAI,CAACjI,kBAAkB,GAAG,CAAC,EAAE;QAC/BrI,SAAS,CAACgN,aAAa,GAAG,IAAI;QAC9B,IAAI,CAAC9E,cAAc,CAACV,GAAG,CAAC1I,GAAG,EAAEkB,SAAS,CAAC;QACvC,IAAI,CAACwN,qBAAqB,CAAC,CAAC;MAC9B;IACF,CAAC,MAAM,IAAIxN,SAAS,CAACiN,KAAK,IAAI,CAAC2D,cAAc,IACzC,IAAI,CAACxT,qBAAqB,EAAE;MAC9B,IAAI,CAACwT,cAAc,EAAE;QACnB,IAAI,CAAC1I,cAAc,CAAC4F,MAAM,CAAChP,GAAG,CAAC;QAC/BkB,SAAS,CAACgN,aAAa,GAAG,KAAK;MACjC;MACA,IAAIhN,SAAS,CAACiN,KAAK,IAAI,IAAI,CAAC7P,qBAAqB,EAAE;QACjD4C,SAAS,GAAGA,SAAS,CAAC6Q,KAAK,CAAC,CAAC;MAC/B;IACF,CAAC,MAAM;MACL,IAAI,CAAC3I,cAAc,CAAC4F,MAAM,CAAChP,GAAG,CAAC;MAC/B,IAAI,CAACoJ,cAAc,CAACV,GAAG,CAAC1I,GAAG,EAAEkB,SAAS,CAAC;IACzC;IACAA,SAAS,CAACiN,KAAK,GAAG,IAAI;IACtB,OAAOjN,SAAS;EAClB;;EAEA;EACA;EACA;EACA,MAAM8Q,IAAIA,CAAA,EAAG;IACX,MAAMtT,OAAO,GAAG,IAAIrB,QAAQ,CAAC4U,WAAW,CAAC,IAAI,CAAC;IAC9C,MAAM,IAAI,CAACjU,SAAS,CAACY,eAAe,CAACF,OAAO,CAAC;EAC/C;;EAEA;EACA;EACA;EACA,MAAMR,QAAQA,CAAA,EAAG;IACf,MAAMQ,OAAO,GAAG,IAAIrB,QAAQ,CAAC6U,eAAe,CAAC,IAAI,CAAC;IAClD,MAAM,IAAI,CAAClU,SAAS,CAACY,eAAe,CAACF,OAAO,CAAC;EAC/C;;EAEA;EACA;EACA;EACAyT,sBAAsBA,CAAA,EAAG;IACvB,OAAO,IAAI,CAAChJ,aAAa;EAC3B;;EAEA;EACA;EACA;EACAiJ,4BAA4BA,CAAA,EAAG;IAC7B,OAAO,IAAI,CAACC,mBAAmB;EACjC;EAEAC,gBAAgBA,CAACxS,MAAM,EAAE;IACvB,IAAI,CAAC4J,sBAAsB,GAAG,IAAI;IAClC,IAAI,CAACL,aAAa,GAAGvJ,MAAM;EAC7B;EAEAyS,gBAAgBA,CAAA,EAAG;IACjB,OAAO,IAAI,CAAClJ,aAAa;EAC3B;EAEAmJ,WAAWA,CAACC,QAAQ,EAAE;IACpB,IAAI,CAACxI,yBAAyB,GAAG,IAAI;IACrC,IAAI,CAACD,iBAAiB,GAAGyI,QAAQ;EACnC;EAEAC,OAAOA,CAACC,IAAI,EAAE;IACZ,IAAI,CAACtI,aAAa,GAAG,IAAI;IACzB,IAAI,CAACD,KAAK,GAAGuI,IAAI;EACnB;EAEAC,aAAaA,CAACC,UAAU,EAAE;IACxB,IAAI,CAACtI,mBAAmB,GAAG,IAAI;IAC/B,IAAI,CAACD,WAAW,GAAGuI,UAAU;EAC/B;EAEAC,SAASA,CAACC,MAAM,EAAE;IAChB,IAAI,CAACtI,eAAe,GAAG,IAAI;IAC3B,IAAI,CAACD,OAAO,GAAGuI,MAAM;;IAErB;AACJ;AACA;AACA;IACI,IAAI,CAAC5I,eAAe,GAAG,IAAI;EAC7B;EAEA6I,SAASA,CAACC,MAAM,EAAE;IAChB,IAAI,CAAC9I,eAAe,GAAG,IAAI;IAC3B,IAAI,CAACD,OAAO,GAAG+I,MAAM;EACvB;EAEA,MAAMC,cAAcA,CAACC,IAAI,EAAEC,QAAQ,EAAEC,WAAW,EAAE;IAChD,MAAMC,MAAM,GAAG;MACbH,IAAI,EAAEA,IAAI;MACVE,WAAW,EAAEA,WAAW;MACxBD,QAAQ,EAAEA,QAAQ;MAClBF,cAAc,EAAE;IAClB,CAAC;IACD,MAAMxU,OAAO,GAAG,IAAIrB,QAAQ,CAACgP,WAAW,CAAC,IAAI,EAAEiH,MAAM,CAAC;IACtD,MAAM,IAAI,CAACtV,SAAS,CAACY,eAAe,CAACF,OAAO,CAAC,CAAC,CAAI;EACpD;EAEA,MAAM6U,SAASA,CAACC,MAAM,EAAE;IACtB,MAAMjD,OAAO,GAAG,IAAI9T,WAAW,CAAC,CAAC;IACjC,MAAM8T,OAAO,CAACC,MAAM,CAAC,IAAI,EAAEgD,MAAM,CAAC;IAClC,OAAOjD,OAAO;EAChB;;EAEA;EACA;EACA;EACA;EACAkD,gBAAgBA,CAAA,EAAG;IACjB,OAAO,IAAI,CAAClK,kBAAkB;EAChC;EAEAmK,cAAcA,CAACC,OAAO,EAAE;IACtB,IAAI,CAAC3V,SAAS,CAACG,WAAW,GAAGwV,OAAO;EACtC;EAEAC,cAAcA,CAAA,EAAG;IACf,OAAO,IAAI,CAAC5V,SAAS,CAACG,WAAW;EACnC;;EAEA;EACA;EACA;EACA0V,MAAMA,CAAA,EAAG;IACP,OAAO,EAAE;EACX;;EAEA;EACA;EACA;EACAC,eAAeA,CAAA,EAAG;IAChB,OAAO,IAAI,CAACC,YAAY;EAC1B;;EAEA;EACA;EACA;EACAC,WAAWA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACC,QAAQ;EACtB;;EAEA;EACA;EACA;EACAC,SAASA,CAAA,EAAG;IACV,OAAO,IAAI,CAACC,MAAM;EACpB;;EAEA;EACA;EACA;EACAC,iBAAiBA,CAAA,EAAG;IAClB,OAAO,IAAI,CAACC,cAAc;EAC5B;;EAEA;EACA;EACA;EACAC,cAAcA,CAAA,EAAG;IACf,OAAO,IAAI,CAAC/L,WAAW;EACzB;;EAEA;EACA;EACA;EACAgM,wBAAwBA,CAAA,EAAG;IACzB,OAAO,IAAI,CAACvW,SAAS,CAACC,aAAa,KAAKhB,SAAS,CAACuX,mBAAmB;EACvE;;EAEA;EACA;EACA;EACAC,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI,CAAClS,OAAO;EACrB;AACF;AACAwQ,MAAM,CAAC2B,OAAO,GAAG5W,kBAAkB"},"metadata":{},"sourceType":"script","externalDependencies":[]}