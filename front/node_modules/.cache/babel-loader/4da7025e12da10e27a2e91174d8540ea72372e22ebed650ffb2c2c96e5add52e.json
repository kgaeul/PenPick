{"ast":null,"code":"// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst constants = require('../constants.js');\nconst errors = require('../errors.js');\nconst nodbUtil = require('../util.js');\nconst settings = require('../settings.js');\nconst future = require('../future.js');\nconst types = require('../types.js');\nconst Lob = require('../lob.js');\n\n// define implementation class\nclass ResultSetImpl {\n  //---------------------------------------------------------------------------\n  // _determineFetchType()\n  //\n  // Determine the fetch type to use for the specified metadata.\n  //---------------------------------------------------------------------------\n  _determineFetchType(metadata, options) {\n    // clear any previous fetch type and converter functions that may have been\n    // retained\n    delete metadata.fetchType;\n    delete metadata.converter;\n\n    // if a fetch type handler is specified, call it; if no value (undefined)\n    // is returned, the normal processing takes place\n    if (options.fetchTypeHandler) {\n      const result = options.fetchTypeHandler(metadata);\n      if (result !== undefined) {\n        errors.assert(typeof result === 'object', errors.ERR_FETCH_TYPE_HANDLER_RETURN_VALUE);\n        if (result.type !== undefined) {\n          errors.assert(result.type instanceof types.DbType, errors.ERR_FETCH_TYPE_HANDLER_TYPE);\n        }\n        if (result.converter !== undefined) {\n          errors.assert(typeof result.converter === 'function', errors.ERR_FETCH_TYPE_HANDLER_CONVERTER);\n        }\n        metadata.fetchType = result.type;\n        metadata.converter = result.converter;\n      }\n    }\n\n    // continue processing if no fetch type was specified or no fetch type\n    // handler was supplied\n    if (!metadata.fetchType) {\n      // if the fetchTypeMap exists (calculated from the fetchInfo argument),\n      // use it to determine the fetch type\n      if (options.fetchTypeMap && options.fetchTypeMap.has(metadata.name)) {\n        metadata.fetchType = options.fetchTypeMap.get(metadata.name);\n        if (metadata.fetchType === constants.DEFAULT) {\n          metadata.fetchType = types.DB_TYPE_FETCH_TYPE_MAP.get(metadata.dbType);\n        }\n\n        // otherwise, use the default fetch type map (calculated from the\n        // fetchAsString and fetchAsBuffer settings\n      } else {\n        metadata.fetchType = settings.fetchTypeMap.get(metadata.dbType);\n      }\n    }\n\n    // if the types do not match, verify that the conversion is supported and\n    // adjust the final fetch type to match what the database expects\n    if (metadata.fetchType !== metadata.dbType) {\n      const map = types.DB_TYPE_CONVERSION_MAP.get(metadata.dbType);\n      const actualFetchType = map && map.get(metadata.fetchType);\n      if (!actualFetchType) {\n        errors.throwErr(errors.ERR_UNSUPPORTED_CONVERSION, metadata.dbType.name, metadata.fetchType.name);\n      }\n      metadata.fetchType = actualFetchType;\n    }\n    let converter;\n    const userConverter = metadata.converter;\n\n    // If IsJson is set convert to JSON objects unless\n    // user defined output type handler overwrites it.\n    if (future.oldJsonColumnAsObj && metadata.isJson && metadata.dbType !== types.DB_TYPE_JSON && userConverter === undefined) {\n      const outConverter = async function (val) {\n        if (!val) {\n          return val;\n        }\n        let result = val;\n        if (val instanceof Lob) {\n          result = await val.getData();\n        }\n        if (result instanceof Buffer) {\n          result = result.toString();\n        }\n        result = JSON.parse(result);\n        return result;\n      };\n      converter = outConverter;\n    }\n\n    // in thin mode, Oracle NUMBER values are internally fetched as string in\n    // order to preserve precision so must be converted to JavaScript Number\n    // when needed; other numeric and date types are fetched natively as\n    // JavaScript Number and Date values and are converted to string using\n    // toString() when desired\n    if (settings.thin) {\n      if (metadata.dbType === types.DB_TYPE_NUMBER && metadata.fetchType === types.DB_TYPE_NUMBER) {\n        converter = v => v === null ? null : parseFloat(v);\n      } else if (metadata.fetchType === types.DB_TYPE_VARCHAR) {\n        if (metadata.dbType === types.DB_TYPE_BINARY_DOUBLE || metadata.dbType === types.DB_TYPE_BINARY_FLOAT || metadata.dbType === types.DB_TYPE_DATE || metadata.dbType === types.DB_TYPE_TIMESTAMP || metadata.dbType === types.DB_TYPE_TIMESTAMP_LTZ || metadata.dbType === types.DB_TYPE_TIMESTAMP_TZ) {\n          converter = v => v === null ? null : v.toString();\n        } else if (metadata.dbType === types.DB_TYPE_RAW) {\n          converter = v => v === null ? null : v.toString('hex').toUpperCase();\n        }\n      } else if (metadata.dbType === types.DB_TYPE_XMLTYPE) {\n        const xmlConverter = async function (val) {\n          if (!val) {\n            return val;\n          }\n          if (typeof val === 'string') {\n            return val;\n          }\n          return await val.getData();\n        };\n        converter = xmlConverter;\n      }\n      if (userConverter && converter) {\n        const internalConverter = converter;\n        converter = v => userConverter(internalConverter(v));\n      }\n    }\n    if (converter) {\n      metadata.converter = converter;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _getConnImpl()\n  //\n  // Common method on all classes that make use of a connection -- used to\n  // ensure serialization of all use of the connection.\n  //---------------------------------------------------------------------------\n  _getConnImpl() {\n    return this._parentObj;\n  }\n\n  //---------------------------------------------------------------------------\n  // _setup()\n  //\n  // Setup a result set. The metadata is examined to to determine if any\n  // columns need to be manipulated before being returned to the caller. If the\n  // rows fetched from the result set are expected to be objects, a unique set\n  // of attribute names are also determined.\n  //---------------------------------------------------------------------------\n  _setup(options, metaData) {\n    this._parentObj = options.connection._impl;\n    this.metaData = metaData;\n    this.lobIndices = [];\n    this.dbObjectIndices = [];\n    this.nestedCursorIndices = [];\n    this.converterIndices = [];\n    this.outFormat = options.outFormat;\n    this.fetchArraySize = options.fetchArraySize;\n    this.dbObjectAsPojo = options.dbObjectAsPojo;\n    this.maxRows = options.maxRows;\n    const names = new Map();\n    for (let i = 0; i < metaData.length; i++) {\n      const name = metaData[i].name;\n      if (!names.has(name)) {\n        names.set(name, i);\n      }\n    }\n    for (let i = 0; i < metaData.length; i++) {\n      const info = metaData[i];\n      if (info.dbTypeClass) {\n        const cls = options.connection._getDbObjectClass(info.dbTypeClass);\n        info.dbTypeClass = cls;\n      }\n      nodbUtil.addTypeProperties(info, \"dbType\");\n      this._determineFetchType(info, options);\n      if (info.fetchType === types.DB_TYPE_CURSOR) {\n        this.nestedCursorIndices.push(i);\n      } else if (info.fetchType === types.DB_TYPE_CLOB || info.fetchType === types.DB_TYPE_NCLOB || info.fetchType === types.DB_TYPE_BLOB) {\n        this.lobIndices.push(i);\n      } else if (info.fetchType === types.DB_TYPE_OBJECT) {\n        this.dbObjectIndices.push(i);\n      }\n      if (info.converter) {\n        this.converterIndices.push(i);\n      }\n      let name = info.name;\n      if (names.get(name) !== i) {\n        let seqNum = 0;\n        while (names.has(name)) {\n          seqNum = seqNum + 1;\n          name = `${info.name}_${seqNum}`;\n        }\n        names.set(name, i);\n        info.name = name;\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // close()\n  //\n  // Closes the result set.\n  //---------------------------------------------------------------------------\n  close() {\n    errors.throwNotImplemented(\"closing a result set\");\n  }\n\n  //---------------------------------------------------------------------------\n  // getRows()\n  //\n  // Returns rows from a result set.\n  //---------------------------------------------------------------------------\n  getRows() {\n    errors.throwNotImplemented(\"getting rows\");\n  }\n}\nmodule.exports = ResultSetImpl;","map":{"version":3,"names":["constants","require","errors","nodbUtil","settings","future","types","Lob","ResultSetImpl","_determineFetchType","metadata","options","fetchType","converter","fetchTypeHandler","result","undefined","assert","ERR_FETCH_TYPE_HANDLER_RETURN_VALUE","type","DbType","ERR_FETCH_TYPE_HANDLER_TYPE","ERR_FETCH_TYPE_HANDLER_CONVERTER","fetchTypeMap","has","name","get","DEFAULT","DB_TYPE_FETCH_TYPE_MAP","dbType","map","DB_TYPE_CONVERSION_MAP","actualFetchType","throwErr","ERR_UNSUPPORTED_CONVERSION","userConverter","oldJsonColumnAsObj","isJson","DB_TYPE_JSON","outConverter","val","getData","Buffer","toString","JSON","parse","thin","DB_TYPE_NUMBER","v","parseFloat","DB_TYPE_VARCHAR","DB_TYPE_BINARY_DOUBLE","DB_TYPE_BINARY_FLOAT","DB_TYPE_DATE","DB_TYPE_TIMESTAMP","DB_TYPE_TIMESTAMP_LTZ","DB_TYPE_TIMESTAMP_TZ","DB_TYPE_RAW","toUpperCase","DB_TYPE_XMLTYPE","xmlConverter","internalConverter","_getConnImpl","_parentObj","_setup","metaData","connection","_impl","lobIndices","dbObjectIndices","nestedCursorIndices","converterIndices","outFormat","fetchArraySize","dbObjectAsPojo","maxRows","names","Map","i","length","set","info","dbTypeClass","cls","_getDbObjectClass","addTypeProperties","DB_TYPE_CURSOR","push","DB_TYPE_CLOB","DB_TYPE_NCLOB","DB_TYPE_BLOB","DB_TYPE_OBJECT","seqNum","close","throwNotImplemented","getRows","module","exports"],"sources":["C:/Users/user1/Desktop/finalproject_penpick/node_modules/oracledb/lib/impl/resultset.js"],"sourcesContent":["// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst constants = require('../constants.js');\nconst errors = require('../errors.js');\nconst nodbUtil = require('../util.js');\nconst settings = require('../settings.js');\nconst future = require('../future.js');\nconst types = require('../types.js');\nconst Lob = require('../lob.js');\n\n// define implementation class\nclass ResultSetImpl {\n\n  //---------------------------------------------------------------------------\n  // _determineFetchType()\n  //\n  // Determine the fetch type to use for the specified metadata.\n  //---------------------------------------------------------------------------\n  _determineFetchType(metadata, options) {\n\n    // clear any previous fetch type and converter functions that may have been\n    // retained\n    delete metadata.fetchType;\n    delete metadata.converter;\n\n    // if a fetch type handler is specified, call it; if no value (undefined)\n    // is returned, the normal processing takes place\n    if (options.fetchTypeHandler) {\n      const result = options.fetchTypeHandler(metadata);\n      if (result !== undefined) {\n        errors.assert(typeof result === 'object',\n          errors.ERR_FETCH_TYPE_HANDLER_RETURN_VALUE);\n        if (result.type !== undefined) {\n          errors.assert(result.type instanceof types.DbType,\n            errors.ERR_FETCH_TYPE_HANDLER_TYPE);\n        }\n        if (result.converter !== undefined) {\n          errors.assert(typeof result.converter === 'function',\n            errors.ERR_FETCH_TYPE_HANDLER_CONVERTER);\n        }\n        metadata.fetchType = result.type;\n        metadata.converter = result.converter;\n      }\n    }\n\n    // continue processing if no fetch type was specified or no fetch type\n    // handler was supplied\n    if (!metadata.fetchType) {\n\n      // if the fetchTypeMap exists (calculated from the fetchInfo argument),\n      // use it to determine the fetch type\n      if (options.fetchTypeMap && options.fetchTypeMap.has(metadata.name)) {\n        metadata.fetchType = options.fetchTypeMap.get(metadata.name);\n        if (metadata.fetchType === constants.DEFAULT) {\n          metadata.fetchType =\n            types.DB_TYPE_FETCH_TYPE_MAP.get(metadata.dbType);\n        }\n\n      // otherwise, use the default fetch type map (calculated from the\n      // fetchAsString and fetchAsBuffer settings\n      } else {\n        metadata.fetchType = settings.fetchTypeMap.get(metadata.dbType);\n      }\n\n    }\n\n    // if the types do not match, verify that the conversion is supported and\n    // adjust the final fetch type to match what the database expects\n    if (metadata.fetchType !== metadata.dbType) {\n      const map = types.DB_TYPE_CONVERSION_MAP.get(metadata.dbType);\n      const actualFetchType = map && map.get(metadata.fetchType);\n      if (!actualFetchType) {\n        errors.throwErr(errors.ERR_UNSUPPORTED_CONVERSION,\n          metadata.dbType.name, metadata.fetchType.name);\n      }\n      metadata.fetchType = actualFetchType;\n    }\n\n    let converter;\n    const userConverter = metadata.converter;\n\n    // If IsJson is set convert to JSON objects unless\n    // user defined output type handler overwrites it.\n    if (future.oldJsonColumnAsObj && metadata.isJson && metadata.dbType !== types.DB_TYPE_JSON\n      && userConverter === undefined) {\n      const outConverter = async function(val) {\n        if (!val) {\n          return val;\n        }\n\n        let result = val;\n        if (val instanceof Lob) {\n          result = await val.getData();\n        }\n        if (result instanceof Buffer) {\n          result = result.toString();\n        }\n        result = JSON.parse(result);\n        return result;\n      };\n      converter = outConverter;\n    }\n\n    // in thin mode, Oracle NUMBER values are internally fetched as string in\n    // order to preserve precision so must be converted to JavaScript Number\n    // when needed; other numeric and date types are fetched natively as\n    // JavaScript Number and Date values and are converted to string using\n    // toString() when desired\n    if (settings.thin) {\n      if (metadata.dbType === types.DB_TYPE_NUMBER &&\n        metadata.fetchType === types.DB_TYPE_NUMBER) {\n        converter = (v) => (v === null) ? null : parseFloat(v);\n      } else if (metadata.fetchType === types.DB_TYPE_VARCHAR) {\n        if (metadata.dbType === types.DB_TYPE_BINARY_DOUBLE ||\n          metadata.dbType === types.DB_TYPE_BINARY_FLOAT ||\n          metadata.dbType === types.DB_TYPE_DATE ||\n          metadata.dbType === types.DB_TYPE_TIMESTAMP ||\n          metadata.dbType === types.DB_TYPE_TIMESTAMP_LTZ ||\n          metadata.dbType === types.DB_TYPE_TIMESTAMP_TZ) {\n          converter = (v) => (v === null) ? null : v.toString();\n        } else if (metadata.dbType === types.DB_TYPE_RAW) {\n          converter = (v) => (v === null) ? null : v.toString('hex').toUpperCase();\n        }\n      } else if (metadata.dbType === types.DB_TYPE_XMLTYPE) {\n        const xmlConverter = async function(val) {\n          if (!val) {\n            return val;\n          }\n          if (typeof val === 'string') {\n            return val;\n          }\n          return await val.getData();\n        };\n        converter = xmlConverter;\n      }\n      if (userConverter && converter) {\n        const internalConverter = converter;\n        converter = (v) => userConverter(internalConverter(v));\n      }\n    }\n\n    if (converter) {\n      metadata.converter = converter;\n    }\n\n  }\n\n  //---------------------------------------------------------------------------\n  // _getConnImpl()\n  //\n  // Common method on all classes that make use of a connection -- used to\n  // ensure serialization of all use of the connection.\n  //---------------------------------------------------------------------------\n  _getConnImpl() {\n    return this._parentObj;\n  }\n\n  //---------------------------------------------------------------------------\n  // _setup()\n  //\n  // Setup a result set. The metadata is examined to to determine if any\n  // columns need to be manipulated before being returned to the caller. If the\n  // rows fetched from the result set are expected to be objects, a unique set\n  // of attribute names are also determined.\n  //---------------------------------------------------------------------------\n  _setup(options, metaData) {\n    this._parentObj = options.connection._impl;\n    this.metaData = metaData;\n    this.lobIndices = [];\n    this.dbObjectIndices = [];\n    this.nestedCursorIndices = [];\n    this.converterIndices = [];\n    this.outFormat = options.outFormat;\n    this.fetchArraySize = options.fetchArraySize;\n    this.dbObjectAsPojo = options.dbObjectAsPojo;\n    this.maxRows = options.maxRows;\n    const names = new Map();\n    for (let i = 0; i < metaData.length; i++) {\n      const name = metaData[i].name;\n      if (!names.has(name)) {\n        names.set(name, i);\n      }\n    }\n    for (let i = 0; i < metaData.length; i++) {\n      const info = metaData[i];\n      if (info.dbTypeClass) {\n        const cls = options.connection._getDbObjectClass(info.dbTypeClass);\n        info.dbTypeClass = cls;\n      }\n      nodbUtil.addTypeProperties(info, \"dbType\");\n      this._determineFetchType(info, options);\n      if (info.fetchType === types.DB_TYPE_CURSOR) {\n        this.nestedCursorIndices.push(i);\n      } else if (info.fetchType === types.DB_TYPE_CLOB ||\n          info.fetchType === types.DB_TYPE_NCLOB ||\n          info.fetchType === types.DB_TYPE_BLOB) {\n        this.lobIndices.push(i);\n      } else if (info.fetchType === types.DB_TYPE_OBJECT) {\n        this.dbObjectIndices.push(i);\n      }\n      if (info.converter) {\n        this.converterIndices.push(i);\n      }\n      let name = info.name;\n      if (names.get(name) !== i) {\n        let seqNum = 0;\n        while (names.has(name)) {\n          seqNum = seqNum + 1;\n          name = `${info.name}_${seqNum}`;\n        }\n        names.set(name, i);\n        info.name = name;\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // close()\n  //\n  // Closes the result set.\n  //---------------------------------------------------------------------------\n  close() {\n    errors.throwNotImplemented(\"closing a result set\");\n  }\n\n  //---------------------------------------------------------------------------\n  // getRows()\n  //\n  // Returns rows from a result set.\n  //---------------------------------------------------------------------------\n  getRows() {\n    errors.throwNotImplemented(\"getting rows\");\n  }\n\n}\n\nmodule.exports = ResultSetImpl;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}