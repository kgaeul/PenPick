{"ast":null,"code":"// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst PoolImpl = require('../impl/pool.js');\nconst ThinConnectionImpl = require('./connection.js');\nconst protocolUtil = require('./protocol/utils.js');\nconst errors = require('../errors.js');\nconst settings = require('../settings.js');\nconst util = require('../util.js');\nconst thinUtil = require('./util.js');\nconst {\n  getConnectionInfo\n} = require('./sqlnet/networkSession.js');\nconst crypto = require('crypto');\nconst EventEmitter = require('events');\nconst Timers = require('timers');\nclass ThinPoolImpl extends PoolImpl {\n  _init(params) {\n    if (!params.homogeneous) {\n      errors.throwErr(errors.ERR_NOT_IMPLEMENTED, 'Heterogeneous Pooling');\n    }\n    thinUtil.checkCredentials(params);\n    this._availableObjects = [];\n    this._name = 'node-thin';\n    this._poolMin = params.poolMin;\n    this._poolMax = params.poolMax;\n    this._poolIncrement = params.poolIncrement;\n    this._poolTimeout = params.poolTimeout;\n    this._poolPingInterval = params.poolPingInterval;\n    this._stmtCacheSize = params.stmtCacheSize;\n\n    // The user Config filterd from common layer is cached except\n    // sensitive data as sensitive data is obfuscated in the pool\n    // and de-obfuscated as necessary.\n    this._userConfig = params;\n    this._freeConnectionList = [];\n    this._usedConnectionList = new Set();\n    this._password = params.password;\n    this._walletPassword = params.walletPassword;\n    this._obfuscatedPassword = [];\n    this._obfuscatedWalletPassword = [];\n    this._token = params.token;\n    this._obfuscatedToken = [];\n    this._privateKey = params.privateKey;\n    this._obfuscatedPrivateKey = [];\n    this._schedulerJob = null;\n    this._poolCloseWaiter = null;\n    this._pendingRequests = [];\n\n    // password obfuscation\n    if (this._password !== undefined) {\n      const obj = protocolUtil.setObfuscatedValue(this._password);\n      this._password = obj.value;\n      this._obfuscatedPassword = obj.obfuscatedValue;\n      this._userConfig.password = null;\n    }\n    // wallet password obfuscation\n    if (this._walletPassword !== undefined) {\n      const obj = protocolUtil.setObfuscatedValue(this._walletPassword);\n      this._walletPassword = obj.value;\n      this._obfuscatedWalletPassword = obj.obfuscatedValue;\n      this._userConfig.walletPassword = null;\n    }\n    // token obfuscation\n    if (this._token !== undefined) {\n      const obj = protocolUtil.setObfuscatedValue(this._token);\n      this._token = obj.value;\n      this._obfuscatedToken = obj.obfuscatedValue;\n      this._userConfig.token = null;\n    }\n    // privateKey obfuscation\n    if (this._privateKey !== undefined) {\n      const obj = protocolUtil.setObfuscatedValue(this._privateKey);\n      this._privateKey = obj.value;\n      this._obfuscatedPrivateKey = obj.obfuscatedValue;\n      this._userConfig.privateKey = null;\n    }\n    this._accessTokenFn = params.accessTokenFn;\n    this._accessTokenConfig = params.accessTokenConfig;\n    this._isDRCPEnabled = false;\n    this.eventEmitter = new EventEmitter();\n    // listener to remove dead or idle connections\n    this.eventEmitter.on('_removePoolConnection', async connImpl => {\n      await this._destroy(connImpl);\n    });\n  }\n\n  //---------------------------------------------------------------------------\n  // create pool with specified parameters and miminum number of connections as\n  // specified by poolMin\n  //---------------------------------------------------------------------------\n  async create(params) {\n    this._init(params);\n    this._userConfig._connInfo = await getConnectionInfo(params);\n    this._isDRCPEnabled = String(this._userConfig._connInfo[0]).toLowerCase() === 'pooled';\n    // generate connection class when none is provided by user\n    if (this._isDRCPEnabled && settings.connectionClass === '') {\n      this._generateConnectionClass();\n    }\n\n    // create a background task. It will create minimum connections in the pool\n    // and expand the pool as required.\n    this.bgThreadFunc();\n  }\n\n  //---------------------------------------------------------------------------\n  // set new token and private key in pool\n  //---------------------------------------------------------------------------\n  setAccessToken(params) {\n    if (params.token) {\n      this._token = params.token;\n      const objToken = protocolUtil.setObfuscatedValue(this._token);\n      this._token = objToken.value;\n      this._obfuscatedToken = objToken.obfuscatedValue;\n    }\n    if (params.privateKey) {\n      this._privateKey = params.privateKey;\n      const objKey = protocolUtil.setObfuscatedValue(this._privateKey);\n      this._privateKey = objKey.value;\n      this._obfuscatedPrivateKey = objKey.obfuscatedValue;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // credentials are obfuscated and stored in an object(userConfig) during\n  // pool creation. _getConnAttrs() method is used to deobfuscate encrypted\n  // credentials for creating new connections\n  //---------------------------------------------------------------------------\n  async _getConnAttrs() {\n    let accessToken;\n    const clonedAttrs = Object.assign({}, this._userConfig);\n    // deobfuscate password\n    if (clonedAttrs.password === null) {\n      clonedAttrs.password = protocolUtil.getDeobfuscatedValue(this._password, this._obfuscatedPassword);\n    }\n\n    // deobfuscate wallet password\n    if (clonedAttrs.walletPassword === null) {\n      clonedAttrs.walletPassword = protocolUtil.getDeobfuscatedValue(this._walletPassword, this._obfuscatedWalletPassword);\n    }\n\n    // deobfuscate token and private key\n    // check for token expiry\n    if (clonedAttrs.token === null) {\n      clonedAttrs.token = protocolUtil.getDeobfuscatedValue(this._token, this._obfuscatedToken);\n      if (util.isTokenExpired(clonedAttrs.token)) {\n        if (typeof this._accessTokenFn === 'function') {\n          accessToken = await this._accessTokenFn(true, this._accessTokenConfig);\n          if (typeof accessToken === 'string') {\n            clonedAttrs.token = accessToken;\n            if (util.isTokenExpired(clonedAttrs.token)) {\n              // OAuth2 token is expired\n              errors.throwErr(errors.ERR_TOKEN_HAS_EXPIRED);\n            } else {\n              // update pool with OAuth2 token\n              const obj = protocolUtil.setObfuscatedValue(clonedAttrs.token);\n              this._token = obj.value;\n              this._obfuscatedToken = obj.obfuscatedValue;\n            }\n          } else if (typeof accessToken === 'object') {\n            clonedAttrs.token = accessToken.token;\n            clonedAttrs.privateKey = accessToken.privateKey;\n            if (util.isTokenExpired(clonedAttrs.token)) {\n              // IAM token is expired\n              errors.throwErr(errors.ERR_TOKEN_HAS_EXPIRED);\n            } else {\n              // update pool with IAM token and private key\n              const objToken = protocolUtil.setObfuscatedValue(clonedAttrs.token);\n              this._token = objToken.value;\n              this._obfuscatedToken = objToken.obfuscatedValue;\n              const objKey = protocolUtil.setObfuscatedValue(clonedAttrs.privateKey);\n              this._privateKey = objKey.value;\n              this._obfuscatedPrivateKey = objKey.obfuscatedValue;\n            }\n          }\n        } else {\n          errors.throwErr(errors.ERR_TOKEN_HAS_EXPIRED);\n        }\n      }\n    }\n    if (clonedAttrs.privateKey === null) {\n      clonedAttrs.privateKey = protocolUtil.getDeobfuscatedValue(this._privateKey, this._obfuscatedPrivateKey);\n    }\n    return clonedAttrs;\n  }\n\n  //---------------------------------------------------------------------------\n  // return available connection if present in pool else\n  // create new connection and return it\n  //---------------------------------------------------------------------------\n  async getConnection() {\n    return await this.acquire();\n  }\n\n  //---------------------------------------------------------------------------\n  // destroy connection when pool close operation is called\n  //---------------------------------------------------------------------------\n  async _destroy(connection) {\n    if (connection.nscon.ntAdapter.connected) {\n      connection._dropSess = true;\n      await connection.close();\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // close pool by destroying available connections\n  //---------------------------------------------------------------------------\n  async close() {\n    // wait till background task for pool expansion is finished; if it is not\n    // currently running, wake it up!\n    await new Promise(resolve => {\n      this._poolCloseWaiter = resolve;\n      if (this.bgWaiter) {\n        this.bgWaiter();\n      }\n    });\n\n    // clear scheduled job\n    if (this._schedulerJob) {\n      clearTimeout(this._schedulerJob);\n      this._schedulerJob = null;\n    }\n\n    // destroy all free connections\n    for (const conn of this._freeConnectionList) {\n      await this._destroy(conn);\n    }\n\n    // destroy all used connections\n    for (const conn of this._usedConnectionList) {\n      await this._destroy(conn);\n    }\n    this.eventEmitter.removeAllListeners();\n  }\n\n  //---------------------------------------------------------------------------\n  // returns poolMax from configuration\n  //---------------------------------------------------------------------------\n  getPoolMax() {\n    return this._poolMax;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns poolMin from configuration\n  //---------------------------------------------------------------------------\n  getPoolMin() {\n    return this._poolMin;\n  }\n\n  //---------------------------------------------------------------------------\n  // get number of used connection\n  //---------------------------------------------------------------------------\n  getConnectionsInUse() {\n    return this._usedConnectionList.size;\n  }\n\n  //---------------------------------------------------------------------------\n  // get number of free connection\n  //---------------------------------------------------------------------------\n  getConnectionsOpen() {\n    return this._freeConnectionList.length + this._usedConnectionList.size;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns poolIncrement from configuration\n  //---------------------------------------------------------------------------\n  getPoolIncrement() {\n    return this._poolIncrement;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns maximum number of connections allowed per shard in the pool\n  //---------------------------------------------------------------------------\n  getPoolMaxPerShard() {\n    return;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns the pool ping interval (seconds)\n  //---------------------------------------------------------------------------\n  getPoolPingInterval() {\n    return this._poolPingInterval;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns the pool timeout\n  //---------------------------------------------------------------------------\n  getPoolTimeout() {\n    return this._poolTimeout;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns whether the SODA metadata cache is enabled or not\n  //---------------------------------------------------------------------------\n  getSodaMetaDataCache() {\n    return;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns the statement cache size associate with the pool\n  //---------------------------------------------------------------------------\n  getStmtCacheSize() {\n    return this._stmtCacheSize;\n  }\n\n  //---------------------------------------------------------------------------\n  // _setScheduler()\n  //\n  // set scheduler to scan and remove idle connections\n  //---------------------------------------------------------------------------\n  _setScheduler() {\n    if (!this._schedulerJob && this._poolTimeout > 0 && this._freeConnectionList.length > 0 && this._freeConnectionList.length + this._usedConnectionList.size > this._poolMin) {\n      this._schedulerJob = setTimeout(() => {\n        this._scanIdleConnection();\n      }, this._poolTimeout * 1000);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // scanIdleConnection()\n  //\n  // scan connection list and removes idle connections from pool\n  //---------------------------------------------------------------------------\n  _scanIdleConnection() {\n    while (this._usedConnectionList.size + this._freeConnectionList.length > this._poolMin && this._freeConnectionList.length > 0) {\n      const conn = this._freeConnectionList[this._freeConnectionList.length - 1];\n      if (Date.now() - conn._lastTimeUsed < this._poolTimeout * 1000) {\n        break;\n      }\n      this.eventEmitter.emit('_removePoolConnection', conn);\n      this._freeConnectionList.pop();\n    }\n    this._schedulerJob = null;\n    this._setScheduler();\n  }\n\n  //---------------------------------------------------------------------------\n  // _getNumConns()\n  //\n  // get number of connections need to be created\n  //---------------------------------------------------------------------------\n  _getNumConns() {\n    const usedConns = this._freeConnectionList.length + this._usedConnectionList.size;\n    // less connections in the pool than poolMin? restore to poolMin\n    if (usedConns < this._poolMin) {\n      return this._poolMin - usedConns;\n      // connections need to be created? create up to poolIncrement without exceeding poolMax\n    } else if (this._pendingRequests.length > 0) {\n      return Math.min(this._poolIncrement, this._poolMax - usedConns);\n      // no pending requests and we are already at poolMin so nothing to do!\n    } else {\n      return 0;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // bgThreadFunc()\n  //\n  // method which runs in a background thread and is used to create connections.\n  // When first started, it creates poolMin connections. After that, it creates\n  // poolIncrement connections up to the value of poolMax when needed.\n  // The thread terminates automatically when the pool is closed.\n  //---------------------------------------------------------------------------\n  async bgThreadFunc() {\n    // continue until a close request is received\n    while (!this._poolCloseWaiter) {\n      // get count for connections to be created\n      const numConns = this._getNumConns();\n\n      // connection creation is going on serially and not concurrently\n      for (let i = 0; i < numConns; i++) {\n        try {\n          // get deobfuscated value\n          const config = await this._getConnAttrs();\n          const conn = new ThinConnectionImpl();\n          conn._pool = this;\n          await conn.connect(config);\n          conn._newSession = true;\n          conn._dropSess = false;\n          conn._lastTimeUsed = Date.now();\n          this._freeConnectionList.push(conn);\n        } catch (err) {\n          this._bgErr = err;\n        }\n        if (this._poolIncrement > 1 && this._poolMax - this._usedConnectionList.size - this._freeConnectionList.length > 1) {\n          this._setScheduler();\n        }\n\n        // resolve pending request\n        if (this._pendingRequests.length > 0) {\n          const payload = this._pendingRequests.shift();\n          payload.resolve();\n        }\n\n        // give an opportunity for other \"threads\" to do their work.\n        await new Promise(resolve => Timers.setImmediate(resolve));\n\n        // break loop when pool is closing\n        if (this._poolCloseWaiter) {\n          break;\n        }\n      }\n\n      // when pool is closing, break from while loop\n      if (this._poolCloseWaiter) {\n        break;\n      }\n\n      // if no pending requests, wait for pending requests to appear!\n      if (this._pendingRequests.length == 0 || this._bgErr) {\n        await new Promise(resolve => {\n          this.bgWaiter = resolve;\n        });\n        this.bgWaiter = null;\n      }\n    }\n\n    // notify the closer that the close can actually take place\n    this._poolCloseWaiter();\n  }\n\n  //---------------------------------------------------------------------------\n  // acquire()\n  //\n  // acquire a connection from connection pool\n  //---------------------------------------------------------------------------\n  async acquire() {\n    // return first connection from the free list that passes health checks\n    while (this._freeConnectionList.length > 0) {\n      const conn = this._freeConnectionList.pop();\n\n      // if connection is unhealthy, drop it from the pool\n      if (!conn.isHealthy()) {\n        this.eventEmitter.emit('_removePoolConnection', conn);\n        continue;\n      }\n\n      // perform a ping, if necessary; a ping interval less than 0 disables\n      // pings; a ping interval of 0 forces a ping for each use of the\n      // connection and a value greater than 0 will be performed if the\n      // connection has not been used for that period of time; if the ping is\n      // unsuccessful, drop the connection from the pool\n      let requiresPing = false;\n      if (this._poolPingInterval === 0) {\n        requiresPing = true;\n      } else if (this._poolPingInterval > 0) {\n        const elapsed = Date.now() - conn._lastTimeUsed;\n        if (elapsed > this._poolPingInterval * 1000) requiresPing = true;\n      }\n      if (requiresPing) {\n        try {\n          await conn.ping();\n        } catch {\n          this.eventEmitter.emit('_removePoolConnection', conn);\n          continue;\n        }\n      }\n\n      // connection has passed health checks, return it immediately\n      this._usedConnectionList.add(conn);\n      return conn;\n    }\n\n    // no free connections exist at this point; if less than poolMin\n    // connections exist, grow the pool to poolMin again; otherwise, increase\n    // the pool by poolIncrement up to poolMax. We are deferring this\n    // to the background thread function!\n    await new Promise(resolve => {\n      this._pendingRequests.push({\n        resolve: resolve\n      });\n      if (this.bgWaiter) {\n        // this wakes up the function to do some more work\n        this.bgWaiter();\n      }\n    });\n    if (this._bgErr) {\n      const err = this._bgErr;\n      this._bgErr = null;\n\n      // if an error has occurred in the background thread we clear it and then,\n      // if there are more pending requests we request the background thread\n      // function to try again.\n      if (this._pendingRequests.length > 0 && this.bgWaiter) {\n        this.bgWaiter();\n      }\n      throw err;\n    }\n    // return a connection from the ones that were just built\n    const conn = this._freeConnectionList.pop();\n    this._usedConnectionList.add(conn);\n    return conn;\n  }\n\n  // release connection to connection pool\n  release(conn) {\n    conn.warning = undefined;\n    this._usedConnectionList.delete(conn);\n    if (conn.nscon.connected) {\n      conn._lastTimeUsed = Date.now();\n      conn._newSession = false;\n      this._freeConnectionList.push(conn);\n    }\n    this._setScheduler();\n  }\n\n  //---------------------------------------------------------------------------\n  // _generateConnectionClass()\n  //\n  // generate connection class for drcp if none is provided by user\n  //---------------------------------------------------------------------------\n  _generateConnectionClass() {\n    this._userConfig.connectionClass = crypto.randomBytes(16).toString('base64');\n    this._userConfig.connectionClass = \"NJS:\" + this._userConfig.connectionClass;\n  }\n}\nmodule.exports = ThinPoolImpl;","map":{"version":3,"names":["PoolImpl","require","ThinConnectionImpl","protocolUtil","errors","settings","util","thinUtil","getConnectionInfo","crypto","EventEmitter","Timers","ThinPoolImpl","_init","params","homogeneous","throwErr","ERR_NOT_IMPLEMENTED","checkCredentials","_availableObjects","_name","_poolMin","poolMin","_poolMax","poolMax","_poolIncrement","poolIncrement","_poolTimeout","poolTimeout","_poolPingInterval","poolPingInterval","_stmtCacheSize","stmtCacheSize","_userConfig","_freeConnectionList","_usedConnectionList","Set","_password","password","_walletPassword","walletPassword","_obfuscatedPassword","_obfuscatedWalletPassword","_token","token","_obfuscatedToken","_privateKey","privateKey","_obfuscatedPrivateKey","_schedulerJob","_poolCloseWaiter","_pendingRequests","undefined","obj","setObfuscatedValue","value","obfuscatedValue","_accessTokenFn","accessTokenFn","_accessTokenConfig","accessTokenConfig","_isDRCPEnabled","eventEmitter","on","connImpl","_destroy","create","_connInfo","String","toLowerCase","connectionClass","_generateConnectionClass","bgThreadFunc","setAccessToken","objToken","objKey","_getConnAttrs","accessToken","clonedAttrs","Object","assign","getDeobfuscatedValue","isTokenExpired","ERR_TOKEN_HAS_EXPIRED","getConnection","acquire","connection","nscon","ntAdapter","connected","_dropSess","close","Promise","resolve","bgWaiter","clearTimeout","conn","removeAllListeners","getPoolMax","getPoolMin","getConnectionsInUse","size","getConnectionsOpen","length","getPoolIncrement","getPoolMaxPerShard","getPoolPingInterval","getPoolTimeout","getSodaMetaDataCache","getStmtCacheSize","_setScheduler","setTimeout","_scanIdleConnection","Date","now","_lastTimeUsed","emit","pop","_getNumConns","usedConns","Math","min","numConns","i","config","_pool","connect","_newSession","push","err","_bgErr","payload","shift","setImmediate","isHealthy","requiresPing","elapsed","ping","add","release","warning","delete","randomBytes","toString","module","exports"],"sources":["C:/Users/user1/Desktop/finalproject_penpick/node_modules/oracledb/lib/thin/pool.js"],"sourcesContent":["// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst PoolImpl = require('../impl/pool.js');\nconst ThinConnectionImpl = require('./connection.js');\nconst protocolUtil = require('./protocol/utils.js');\nconst errors = require('../errors.js');\nconst settings = require('../settings.js');\nconst util = require('../util.js');\nconst thinUtil = require('./util.js');\nconst {getConnectionInfo} = require('./sqlnet/networkSession.js');\nconst crypto = require('crypto');\nconst EventEmitter = require('events');\nconst Timers = require('timers');\n\nclass ThinPoolImpl extends PoolImpl {\n\n  _init(params) {\n    if (!params.homogeneous) {\n      errors.throwErr(errors.ERR_NOT_IMPLEMENTED, 'Heterogeneous Pooling');\n    }\n    thinUtil.checkCredentials(params);\n\n    this._availableObjects = [];\n    this._name = 'node-thin';\n    this._poolMin = params.poolMin;\n    this._poolMax = params.poolMax;\n    this._poolIncrement = params.poolIncrement;\n    this._poolTimeout = params.poolTimeout;\n    this._poolPingInterval = params.poolPingInterval;\n    this._stmtCacheSize = params.stmtCacheSize;\n\n    // The user Config filterd from common layer is cached except\n    // sensitive data as sensitive data is obfuscated in the pool\n    // and de-obfuscated as necessary.\n    this._userConfig = params;\n    this._freeConnectionList = [];\n    this._usedConnectionList = new Set();\n    this._password = params.password;\n    this._walletPassword = params.walletPassword;\n    this._obfuscatedPassword = [];\n    this._obfuscatedWalletPassword = [];\n    this._token = params.token;\n    this._obfuscatedToken = [];\n    this._privateKey = params.privateKey;\n    this._obfuscatedPrivateKey = [];\n    this._schedulerJob = null;\n    this._poolCloseWaiter = null;\n    this._pendingRequests = [];\n\n    // password obfuscation\n    if (this._password !== undefined) {\n      const obj = protocolUtil.setObfuscatedValue(this._password);\n      this._password = obj.value;\n      this._obfuscatedPassword = obj.obfuscatedValue;\n      this._userConfig.password = null;\n    }\n    // wallet password obfuscation\n    if (this._walletPassword !== undefined) {\n      const obj = protocolUtil.setObfuscatedValue(this._walletPassword);\n      this._walletPassword = obj.value;\n      this._obfuscatedWalletPassword = obj.obfuscatedValue;\n      this._userConfig.walletPassword = null;\n    }\n    // token obfuscation\n    if (this._token !== undefined) {\n      const obj = protocolUtil.setObfuscatedValue(this._token);\n      this._token = obj.value;\n      this._obfuscatedToken = obj.obfuscatedValue;\n      this._userConfig.token = null;\n    }\n    // privateKey obfuscation\n    if (this._privateKey !== undefined) {\n      const obj = protocolUtil.setObfuscatedValue(this._privateKey);\n      this._privateKey = obj.value;\n      this._obfuscatedPrivateKey = obj.obfuscatedValue;\n      this._userConfig.privateKey = null;\n    }\n    this._accessTokenFn = params.accessTokenFn;\n    this._accessTokenConfig = params.accessTokenConfig;\n    this._isDRCPEnabled = false;\n    this.eventEmitter = new EventEmitter();\n    // listener to remove dead or idle connections\n    this.eventEmitter.on('_removePoolConnection', async (connImpl) => {\n      await this._destroy(connImpl);\n    });\n  }\n\n  //---------------------------------------------------------------------------\n  // create pool with specified parameters and miminum number of connections as\n  // specified by poolMin\n  //---------------------------------------------------------------------------\n  async create(params) {\n    this._init(params);\n    this._userConfig._connInfo =\n      await getConnectionInfo(params);\n    this._isDRCPEnabled =\n      String(this._userConfig._connInfo[0]).toLowerCase() === 'pooled';\n    // generate connection class when none is provided by user\n    if (this._isDRCPEnabled && settings.connectionClass === '') {\n      this._generateConnectionClass();\n    }\n\n    // create a background task. It will create minimum connections in the pool\n    // and expand the pool as required.\n    this.bgThreadFunc();\n  }\n\n  //---------------------------------------------------------------------------\n  // set new token and private key in pool\n  //---------------------------------------------------------------------------\n  setAccessToken(params) {\n    if (params.token) {\n      this._token = params.token;\n      const objToken = protocolUtil.setObfuscatedValue(this._token);\n      this._token = objToken.value;\n      this._obfuscatedToken = objToken.obfuscatedValue;\n    }\n    if (params.privateKey) {\n      this._privateKey = params.privateKey;\n      const objKey = protocolUtil.setObfuscatedValue(this._privateKey);\n      this._privateKey = objKey.value;\n      this._obfuscatedPrivateKey = objKey.obfuscatedValue;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // credentials are obfuscated and stored in an object(userConfig) during\n  // pool creation. _getConnAttrs() method is used to deobfuscate encrypted\n  // credentials for creating new connections\n  //---------------------------------------------------------------------------\n  async _getConnAttrs() {\n    let accessToken;\n    const clonedAttrs = Object.assign({}, this._userConfig);\n    // deobfuscate password\n    if (clonedAttrs.password === null) {\n      clonedAttrs.password = protocolUtil.getDeobfuscatedValue(this._password,\n        this._obfuscatedPassword);\n    }\n\n    // deobfuscate wallet password\n    if (clonedAttrs.walletPassword === null) {\n      clonedAttrs.walletPassword =\n        protocolUtil.getDeobfuscatedValue(this._walletPassword,\n          this._obfuscatedWalletPassword);\n    }\n\n    // deobfuscate token and private key\n    // check for token expiry\n    if (clonedAttrs.token === null) {\n      clonedAttrs.token =\n        protocolUtil.getDeobfuscatedValue(this._token, this._obfuscatedToken);\n      if (util.isTokenExpired(clonedAttrs.token)) {\n        if (typeof this._accessTokenFn === 'function') {\n          accessToken = await this._accessTokenFn(true, this._accessTokenConfig);\n          if (typeof accessToken === 'string') {\n            clonedAttrs.token = accessToken;\n            if (util.isTokenExpired(clonedAttrs.token)) {\n              // OAuth2 token is expired\n              errors.throwErr(errors.ERR_TOKEN_HAS_EXPIRED);\n            } else {\n              // update pool with OAuth2 token\n              const obj = protocolUtil.setObfuscatedValue(clonedAttrs.token);\n              this._token = obj.value;\n              this._obfuscatedToken = obj.obfuscatedValue;\n            }\n          } else if (typeof accessToken === 'object') {\n            clonedAttrs.token = accessToken.token;\n            clonedAttrs.privateKey = accessToken.privateKey;\n            if (util.isTokenExpired(clonedAttrs.token)) {\n              // IAM token is expired\n              errors.throwErr(errors.ERR_TOKEN_HAS_EXPIRED);\n            } else {\n              // update pool with IAM token and private key\n              const objToken = protocolUtil.setObfuscatedValue(clonedAttrs.token);\n              this._token = objToken.value;\n              this._obfuscatedToken = objToken.obfuscatedValue;\n              const objKey = protocolUtil.setObfuscatedValue(clonedAttrs.privateKey);\n              this._privateKey = objKey.value;\n              this._obfuscatedPrivateKey = objKey.obfuscatedValue;\n            }\n          }\n        } else {\n          errors.throwErr(errors.ERR_TOKEN_HAS_EXPIRED);\n        }\n      }\n    }\n    if (clonedAttrs.privateKey === null) {\n      clonedAttrs.privateKey =\n        protocolUtil.getDeobfuscatedValue(this._privateKey,\n          this._obfuscatedPrivateKey);\n    }\n    return clonedAttrs;\n  }\n\n  //---------------------------------------------------------------------------\n  // return available connection if present in pool else\n  // create new connection and return it\n  //---------------------------------------------------------------------------\n  async getConnection() {\n    return await this.acquire();\n  }\n\n  //---------------------------------------------------------------------------\n  // destroy connection when pool close operation is called\n  //---------------------------------------------------------------------------\n  async _destroy(connection) {\n    if (connection.nscon.ntAdapter.connected) {\n      connection._dropSess = true;\n      await connection.close();\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // close pool by destroying available connections\n  //---------------------------------------------------------------------------\n  async close() {\n\n    // wait till background task for pool expansion is finished; if it is not\n    // currently running, wake it up!\n    await new Promise((resolve) => {\n      this._poolCloseWaiter = resolve;\n      if (this.bgWaiter) {\n        this.bgWaiter();\n      }\n    });\n\n    // clear scheduled job\n    if (this._schedulerJob) {\n      clearTimeout(this._schedulerJob);\n      this._schedulerJob = null;\n    }\n\n    // destroy all free connections\n    for (const conn of this._freeConnectionList) {\n      await this._destroy(conn);\n    }\n\n    // destroy all used connections\n    for (const conn of this._usedConnectionList) {\n      await this._destroy(conn);\n    }\n\n    this.eventEmitter.removeAllListeners();\n  }\n\n  //---------------------------------------------------------------------------\n  // returns poolMax from configuration\n  //---------------------------------------------------------------------------\n  getPoolMax() {\n    return this._poolMax;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns poolMin from configuration\n  //---------------------------------------------------------------------------\n  getPoolMin() {\n    return this._poolMin;\n  }\n\n  //---------------------------------------------------------------------------\n  // get number of used connection\n  //---------------------------------------------------------------------------\n  getConnectionsInUse() {\n    return this._usedConnectionList.size;\n  }\n\n  //---------------------------------------------------------------------------\n  // get number of free connection\n  //---------------------------------------------------------------------------\n  getConnectionsOpen() {\n    return this._freeConnectionList.length + this._usedConnectionList.size;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns poolIncrement from configuration\n  //---------------------------------------------------------------------------\n  getPoolIncrement() {\n    return this._poolIncrement;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns maximum number of connections allowed per shard in the pool\n  //---------------------------------------------------------------------------\n  getPoolMaxPerShard() {\n    return;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns the pool ping interval (seconds)\n  //---------------------------------------------------------------------------\n  getPoolPingInterval() {\n    return this._poolPingInterval;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns the pool timeout\n  //---------------------------------------------------------------------------\n  getPoolTimeout() {\n    return this._poolTimeout;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns whether the SODA metadata cache is enabled or not\n  //---------------------------------------------------------------------------\n  getSodaMetaDataCache() {\n    return;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns the statement cache size associate with the pool\n  //---------------------------------------------------------------------------\n  getStmtCacheSize() {\n    return this._stmtCacheSize;\n  }\n\n  //---------------------------------------------------------------------------\n  // _setScheduler()\n  //\n  // set scheduler to scan and remove idle connections\n  //---------------------------------------------------------------------------\n  _setScheduler() {\n    if (!this._schedulerJob && this._poolTimeout > 0 &&\n        this._freeConnectionList.length > 0 &&\n        (this._freeConnectionList.length + this._usedConnectionList.size >\n        this._poolMin)) {\n      this._schedulerJob = setTimeout(() => {\n        this._scanIdleConnection();\n      }, this._poolTimeout * 1000);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // scanIdleConnection()\n  //\n  // scan connection list and removes idle connections from pool\n  //---------------------------------------------------------------------------\n  _scanIdleConnection() {\n    while ((this._usedConnectionList.size + this._freeConnectionList.length) >\n        this._poolMin && this._freeConnectionList.length > 0) {\n      const conn = this._freeConnectionList[this._freeConnectionList.length - 1];\n      if (Date.now() - conn._lastTimeUsed < this._poolTimeout * 1000) {\n        break;\n      }\n\n      this.eventEmitter.emit('_removePoolConnection', conn);\n      this._freeConnectionList.pop();\n    }\n\n    this._schedulerJob = null;\n    this._setScheduler();\n  }\n\n  //---------------------------------------------------------------------------\n  // _getNumConns()\n  //\n  // get number of connections need to be created\n  //---------------------------------------------------------------------------\n  _getNumConns() {\n    const usedConns = this._freeConnectionList.length + this._usedConnectionList.size;\n    // less connections in the pool than poolMin? restore to poolMin\n    if (usedConns < this._poolMin) {\n      return this._poolMin - usedConns;\n    // connections need to be created? create up to poolIncrement without exceeding poolMax\n    } else if (this._pendingRequests.length > 0) {\n      return Math.min(this._poolIncrement, this._poolMax - usedConns);\n    // no pending requests and we are already at poolMin so nothing to do!\n    } else {\n      return 0;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // bgThreadFunc()\n  //\n  // method which runs in a background thread and is used to create connections.\n  // When first started, it creates poolMin connections. After that, it creates\n  // poolIncrement connections up to the value of poolMax when needed.\n  // The thread terminates automatically when the pool is closed.\n  //---------------------------------------------------------------------------\n  async bgThreadFunc() {\n\n    // continue until a close request is received\n    while (!this._poolCloseWaiter) {\n      // get count for connections to be created\n      const numConns = this._getNumConns();\n\n      // connection creation is going on serially and not concurrently\n      for (let i = 0; i < numConns; i++) {\n        try {\n          // get deobfuscated value\n          const config = await this._getConnAttrs();\n          const conn = new ThinConnectionImpl();\n          conn._pool = this;\n          await conn.connect(config);\n          conn._newSession = true;\n          conn._dropSess = false;\n          conn._lastTimeUsed = Date.now();\n          this._freeConnectionList.push(conn);\n        } catch (err) {\n          this._bgErr = err;\n        }\n\n        if (this._poolIncrement > 1 && (this._poolMax - this._usedConnectionList.size\n            - this._freeConnectionList.length) > 1) {\n          this._setScheduler();\n        }\n\n        // resolve pending request\n        if (this._pendingRequests.length > 0) {\n          const payload = this._pendingRequests.shift();\n          payload.resolve();\n        }\n\n        // give an opportunity for other \"threads\" to do their work.\n        await new Promise((resolve) => Timers.setImmediate(resolve));\n\n        // break loop when pool is closing\n        if (this._poolCloseWaiter) {\n          break;\n        }\n      }\n\n      // when pool is closing, break from while loop\n      if (this._poolCloseWaiter) {\n        break;\n      }\n\n      // if no pending requests, wait for pending requests to appear!\n      if (this._pendingRequests.length == 0 || this._bgErr) {\n        await new Promise((resolve) => {\n          this.bgWaiter = resolve;\n        });\n        this.bgWaiter = null;\n      }\n    }\n\n    // notify the closer that the close can actually take place\n    this._poolCloseWaiter();\n  }\n\n  //---------------------------------------------------------------------------\n  // acquire()\n  //\n  // acquire a connection from connection pool\n  //---------------------------------------------------------------------------\n  async acquire() {\n\n    // return first connection from the free list that passes health checks\n    while (this._freeConnectionList.length > 0) {\n      const conn = this._freeConnectionList.pop();\n\n      // if connection is unhealthy, drop it from the pool\n      if (!conn.isHealthy()) {\n        this.eventEmitter.emit('_removePoolConnection', conn);\n        continue;\n      }\n\n      // perform a ping, if necessary; a ping interval less than 0 disables\n      // pings; a ping interval of 0 forces a ping for each use of the\n      // connection and a value greater than 0 will be performed if the\n      // connection has not been used for that period of time; if the ping is\n      // unsuccessful, drop the connection from the pool\n      let requiresPing = false;\n      if (this._poolPingInterval === 0) {\n        requiresPing = true;\n      } else if (this._poolPingInterval > 0) {\n        const elapsed = Date.now() - conn._lastTimeUsed;\n        if (elapsed > this._poolPingInterval * 1000)\n          requiresPing = true;\n      }\n      if (requiresPing) {\n        try {\n          await conn.ping();\n        } catch {\n          this.eventEmitter.emit('_removePoolConnection', conn);\n          continue;\n        }\n      }\n\n      // connection has passed health checks, return it immediately\n      this._usedConnectionList.add(conn);\n      return conn;\n\n    }\n\n    // no free connections exist at this point; if less than poolMin\n    // connections exist, grow the pool to poolMin again; otherwise, increase\n    // the pool by poolIncrement up to poolMax. We are deferring this\n    // to the background thread function!\n    await new Promise((resolve) => {\n      this._pendingRequests.push({resolve: resolve});\n      if (this.bgWaiter) {\n        // this wakes up the function to do some more work\n        this.bgWaiter();\n      }\n    });\n\n    if (this._bgErr) {\n      const err = this._bgErr;\n      this._bgErr = null;\n\n      // if an error has occurred in the background thread we clear it and then,\n      // if there are more pending requests we request the background thread\n      // function to try again.\n      if (this._pendingRequests.length > 0 && this.bgWaiter) {\n        this.bgWaiter();\n      }\n      throw err;\n    }\n    // return a connection from the ones that were just built\n    const conn = this._freeConnectionList.pop();\n    this._usedConnectionList.add(conn);\n    return conn;\n  }\n\n  // release connection to connection pool\n  release(conn) {\n    conn.warning = undefined;\n    this._usedConnectionList.delete(conn);\n    if (conn.nscon.connected) {\n      conn._lastTimeUsed = Date.now();\n      conn._newSession = false;\n      this._freeConnectionList.push(conn);\n    }\n    this._setScheduler();\n  }\n\n  //---------------------------------------------------------------------------\n  // _generateConnectionClass()\n  //\n  // generate connection class for drcp if none is provided by user\n  //---------------------------------------------------------------------------\n  _generateConnectionClass() {\n    this._userConfig.connectionClass = crypto.randomBytes(16).toString('base64');\n    this._userConfig.connectionClass = \"NJS:\" + this._userConfig.connectionClass;\n  }\n}\n\nmodule.exports = ThinPoolImpl;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}