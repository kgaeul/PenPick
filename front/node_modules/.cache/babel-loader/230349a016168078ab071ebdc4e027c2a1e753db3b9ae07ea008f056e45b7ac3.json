{"ast":null,"code":"// Copyright (c) 2015, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst process = require('process');\nconst {\n  Readable\n} = require('stream');\nclass QueryStream extends Readable {\n  constructor(rs) {\n    super({\n      objectMode: true\n    });\n    this._fetching = false;\n    this._numRows = 0;\n\n    // calling open via process.nextTick to allow event handlers to be\n    // registered prior to the events being emitted\n    if (rs) {\n      process.nextTick(() => {\n        this._open(rs);\n      });\n    }\n  }\n\n  // called by readable.destroy() and ensures that the result set is closed if\n  // it has not already been closed (never called directly)\n  async _destroy(err, cb) {\n    if (this._resultSet) {\n      const rs = this._resultSet;\n      this._resultSet = null;\n      if (this._fetching) {\n        await new Promise(resolve => this.once('_doneFetching', resolve));\n      }\n      try {\n        await rs._impl.close();\n      } catch (closeErr) {\n        cb(closeErr);\n        return;\n      }\n    }\n    cb(err);\n  }\n\n  // called when the query stream is to be associated with a result set; this\n  // takes place when the query stream if constructed (if a result set is known\n  // at that point) or by Connection.execute() when the result set is ready\n  _open(rs) {\n    this._resultSet = rs;\n\n    // trigger the event listener that may have been added in _read() now that\n    // the result set is ready\n    this.emit('open');\n\n    // emit a metadata event as a convenience to users\n    this.emit('metadata', rs.metaData);\n  }\n\n  // called by readable.read() and pushes rows to the internal queue maintained\n  // by the stream implementation (never called directly) appropriate\n  async _read() {\n    // still waiting on the result set to be added via _open() so add an event\n    // listener to retry when ready\n    if (!this._resultSet) {\n      this.once('open', this._read);\n      return;\n    }\n\n    // using the JS getRow() to leverage the JS row cache; the result set's\n    // _allowGetRowCall is set to true to allow the call for query streams\n    // created via ResultSet.toQueryStream()\n    try {\n      this._fetching = true;\n      this._resultSet._allowGetRowCall = true;\n      const row = await this._resultSet.getRow();\n      if (row) {\n        this.push(row);\n      } else {\n        this.push(null);\n      }\n    } catch (err) {\n      this.destroy(err);\n    } finally {\n      this._fetching = false;\n      if (this._resultSet) {\n        this._resultSet._allowGetRowCall = false;\n      } else {\n        this.emit('_doneFetching');\n      }\n    }\n  }\n}\nmodule.exports = QueryStream;","map":{"version":3,"names":["process","require","Readable","QueryStream","constructor","rs","objectMode","_fetching","_numRows","nextTick","_open","_destroy","err","cb","_resultSet","Promise","resolve","once","_impl","close","closeErr","emit","metaData","_read","_allowGetRowCall","row","getRow","push","destroy","module","exports"],"sources":["C:/Users/user1/Desktop/finalproject_penpick/node_modules/oracledb/lib/queryStream.js"],"sourcesContent":["// Copyright (c) 2015, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst process = require('process');\nconst { Readable } = require('stream');\n\nclass QueryStream extends Readable {\n\n  constructor(rs) {\n    super({ objectMode: true });\n    this._fetching = false;\n    this._numRows = 0;\n\n    // calling open via process.nextTick to allow event handlers to be\n    // registered prior to the events being emitted\n    if (rs) {\n      process.nextTick(() => {\n        this._open(rs);\n      });\n    }\n  }\n\n  // called by readable.destroy() and ensures that the result set is closed if\n  // it has not already been closed (never called directly)\n  async _destroy(err, cb) {\n    if (this._resultSet) {\n      const rs = this._resultSet;\n      this._resultSet = null;\n      if (this._fetching) {\n        await new Promise(resolve =>\n          this.once('_doneFetching', resolve));\n      }\n      try {\n        await rs._impl.close();\n      } catch (closeErr) {\n        cb(closeErr);\n        return;\n      }\n    }\n    cb(err);\n  }\n\n  // called when the query stream is to be associated with a result set; this\n  // takes place when the query stream if constructed (if a result set is known\n  // at that point) or by Connection.execute() when the result set is ready\n  _open(rs) {\n    this._resultSet = rs;\n\n    // trigger the event listener that may have been added in _read() now that\n    // the result set is ready\n    this.emit('open');\n\n    // emit a metadata event as a convenience to users\n    this.emit('metadata', rs.metaData);\n  }\n\n  // called by readable.read() and pushes rows to the internal queue maintained\n  // by the stream implementation (never called directly) appropriate\n  async _read() {\n\n    // still waiting on the result set to be added via _open() so add an event\n    // listener to retry when ready\n    if (!this._resultSet) {\n      this.once('open', this._read);\n      return;\n    }\n\n    // using the JS getRow() to leverage the JS row cache; the result set's\n    // _allowGetRowCall is set to true to allow the call for query streams\n    // created via ResultSet.toQueryStream()\n    try {\n      this._fetching = true;\n      this._resultSet._allowGetRowCall = true;\n      const row = await this._resultSet.getRow();\n      if (row) {\n        this.push(row);\n      } else {\n        this.push(null);\n      }\n    } catch (err) {\n      this.destroy(err);\n    } finally {\n      this._fetching = false;\n      if (this._resultSet) {\n        this._resultSet._allowGetRowCall = false;\n      } else {\n        this.emit('_doneFetching');\n      }\n    }\n  }\n\n}\n\nmodule.exports = QueryStream;\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,OAAO,GAAGC,OAAO,CAAC,SAAS,CAAC;AAClC,MAAM;EAAEC;AAAS,CAAC,GAAGD,OAAO,CAAC,QAAQ,CAAC;AAEtC,MAAME,WAAW,SAASD,QAAQ,CAAC;EAEjCE,WAAWA,CAACC,EAAE,EAAE;IACd,KAAK,CAAC;MAAEC,UAAU,EAAE;IAAK,CAAC,CAAC;IAC3B,IAAI,CAACC,SAAS,GAAG,KAAK;IACtB,IAAI,CAACC,QAAQ,GAAG,CAAC;;IAEjB;IACA;IACA,IAAIH,EAAE,EAAE;MACNL,OAAO,CAACS,QAAQ,CAAC,MAAM;QACrB,IAAI,CAACC,KAAK,CAACL,EAAE,CAAC;MAChB,CAAC,CAAC;IACJ;EACF;;EAEA;EACA;EACA,MAAMM,QAAQA,CAACC,GAAG,EAAEC,EAAE,EAAE;IACtB,IAAI,IAAI,CAACC,UAAU,EAAE;MACnB,MAAMT,EAAE,GAAG,IAAI,CAACS,UAAU;MAC1B,IAAI,CAACA,UAAU,GAAG,IAAI;MACtB,IAAI,IAAI,CAACP,SAAS,EAAE;QAClB,MAAM,IAAIQ,OAAO,CAACC,OAAO,IACvB,IAAI,CAACC,IAAI,CAAC,eAAe,EAAED,OAAO,CAAC,CAAC;MACxC;MACA,IAAI;QACF,MAAMX,EAAE,CAACa,KAAK,CAACC,KAAK,CAAC,CAAC;MACxB,CAAC,CAAC,OAAOC,QAAQ,EAAE;QACjBP,EAAE,CAACO,QAAQ,CAAC;QACZ;MACF;IACF;IACAP,EAAE,CAACD,GAAG,CAAC;EACT;;EAEA;EACA;EACA;EACAF,KAAKA,CAACL,EAAE,EAAE;IACR,IAAI,CAACS,UAAU,GAAGT,EAAE;;IAEpB;IACA;IACA,IAAI,CAACgB,IAAI,CAAC,MAAM,CAAC;;IAEjB;IACA,IAAI,CAACA,IAAI,CAAC,UAAU,EAAEhB,EAAE,CAACiB,QAAQ,CAAC;EACpC;;EAEA;EACA;EACA,MAAMC,KAAKA,CAAA,EAAG;IAEZ;IACA;IACA,IAAI,CAAC,IAAI,CAACT,UAAU,EAAE;MACpB,IAAI,CAACG,IAAI,CAAC,MAAM,EAAE,IAAI,CAACM,KAAK,CAAC;MAC7B;IACF;;IAEA;IACA;IACA;IACA,IAAI;MACF,IAAI,CAAChB,SAAS,GAAG,IAAI;MACrB,IAAI,CAACO,UAAU,CAACU,gBAAgB,GAAG,IAAI;MACvC,MAAMC,GAAG,GAAG,MAAM,IAAI,CAACX,UAAU,CAACY,MAAM,CAAC,CAAC;MAC1C,IAAID,GAAG,EAAE;QACP,IAAI,CAACE,IAAI,CAACF,GAAG,CAAC;MAChB,CAAC,MAAM;QACL,IAAI,CAACE,IAAI,CAAC,IAAI,CAAC;MACjB;IACF,CAAC,CAAC,OAAOf,GAAG,EAAE;MACZ,IAAI,CAACgB,OAAO,CAAChB,GAAG,CAAC;IACnB,CAAC,SAAS;MACR,IAAI,CAACL,SAAS,GAAG,KAAK;MACtB,IAAI,IAAI,CAACO,UAAU,EAAE;QACnB,IAAI,CAACA,UAAU,CAACU,gBAAgB,GAAG,KAAK;MAC1C,CAAC,MAAM;QACL,IAAI,CAACH,IAAI,CAAC,eAAe,CAAC;MAC5B;IACF;EACF;AAEF;AAEAQ,MAAM,CAACC,OAAO,GAAG3B,WAAW"},"metadata":{},"sourceType":"script","externalDependencies":[]}