{"ast":null,"code":"// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst {\n  NavAddress,\n  NavAddressList,\n  NavDescription,\n  NavDescriptionList\n} = require(\"./navNodes.js\");\nconst {\n  createNVPair\n} = require(\"./nvStrToNvPair.js\");\nconst errors = require(\"../../errors.js\");\n\n/**\n * Class that holds all possible attributes under Description\n */\nclass ConnectDescription {\n  constructor() {\n    this.cOpts = new Array();\n  }\n  addConnectOption(opt) {\n    this.cOpts.push(opt);\n  }\n  getConnectOptions() {\n    return this.cOpts;\n  }\n}\n\n/**\n * Class that holds a list of possible connection options.\n */\nclass ConnStrategy {\n  constructor() {\n    this.reset();\n    this.retryCount = 0;\n    this.currentDescription = null;\n    this.descriptionList = new Array();\n    this.sBuf = new Array();\n  }\n  reset() {\n    this.nextOptToTry = 0;\n    this.lastRetryCounter = 0;\n    this.lastRetryConnectDescription = 0;\n    this.reorderDescriptionList = 0;\n  }\n  hasMoreOptions() {\n    let cOptsSize = 0;\n    for (let i = 0; i < this.descriptionList.length; ++i) {\n      cOptsSize += this.descriptionList[i].getConnectOptions().length;\n    }\n    return this.nextOptToTry < cOptsSize;\n  }\n  newConnectionDescription() {\n    this.currentDescription = new ConnectDescription();\n    return this.currentDescription;\n  }\n  getcurrentDescription() {\n    return this.currentDescription;\n  }\n  closeDescription() {\n    this.descriptionList.push(this.currentDescription);\n    this.currentDescription = null;\n  }\n  /**\n  * Execute the Connection Options from the array.  When a refuse packet is received from\n  * server this method is called again and the next connect option is tried.\n  */\n  async execute(config) {\n    /* Check for retryCount in the config if no retryCount exists in the description string */\n    if (config != null) {\n      if (this.retryCount == 0 && config.retryCount > 0) {\n        this.retryCount = config.retryCount;\n      }\n    }\n    if (!this.reorderDescriptionList) {\n      this.descriptionList = SOLE_INST_DHCACHE.reorderDescriptionList(this.descriptionList);\n      this.reorderDescriptionList = true;\n    }\n    /* We try the address list at least once and upto (1 + retryCount) times */\n    for (let d = this.lastRetryConnectDescription; d < this.descriptionList.length; d++) {\n      const desc = this.descriptionList[d];\n      let cOpts = new Array();\n      cOpts = desc.getConnectOptions();\n      let delay = desc.delayInMillis;\n      /* check for retryDelay in config if it doesn't exist in description string */\n      if (config != null) {\n        if ((delay == 0 || delay == undefined) && config.retryDelay > 0) {\n          delay = config.retryDelay * 1000;\n        }\n      }\n      for (let i = this.lastRetryCounter; i <= this.retryCount; ++i) {\n        //Conn options must be reordered only when all options are tried\n        // i.e for retry and before the first try.\n        if (this.nextOptToTry == 0) {\n          cOpts = SOLE_INST_DHCACHE.reorderAddresses(cOpts);\n        }\n        while (this.nextOptToTry < cOpts.length) {\n          const copt = cOpts[this.nextOptToTry];\n          this.lastRetryCounter = i;\n          this.lastRetryConnectDescription = d;\n          this.nextOptToTry++;\n          return copt;\n        }\n        this.nextOptToTry = 0;\n        // if we reached here then we are retrying other descriptor\n        if (delay > 0 && i < this.retryCount) {\n          await sleep(delay);\n        } // end of (delay > 0)\n      } // end of for(lastRetryCounter..retryCount)\n      this.lastRetryCounter = 0; // reset after one description is completed\n    }\n    // if we get here, all options were tried and none are valid\n    this.nextOptToTry = 1000;\n    this.lastRetryCounter = 1000;\n    throw new Error(\"All options tried\");\n  }\n  // sleep time expects milliseconds\n}\nfunction sleep(time) {\n  return new Promise(resolve => setTimeout(resolve, time));\n}\n\n/**\n * create different nodes (schemaobject) as per the given input.\n * @param {string} str - input description string\n * @returns {object} - returns a connection strategy object.\n */\nasync function createNode(str) {\n  let nvpair;\n  if (typeof str === 'string') nvpair = createNVPair(str);else nvpair = str; //Already a NVPair\n\n  const arg = nvpair.name.toUpperCase();\n  let navobj = null;\n  switch (arg) {\n    case \"ADDRESS\":\n      navobj = new NavAddress();\n      break;\n    case \"ADDRESS_LIST\":\n      navobj = new NavAddressList();\n      break;\n    case \"DESCRIPTION\":\n      navobj = new NavDescription();\n      break;\n    case \"DESCRIPTION_LIST\":\n      navobj = new NavDescriptionList();\n      break;\n    default:\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_PARAMETERS, `unknown top element ${arg}`);\n  }\n  navobj.initFromNVPair(nvpair);\n  const cs = new ConnStrategy();\n  await navobj.navigate(cs);\n  return cs;\n}\nclass DownHostsCache {\n  constructor() {\n    // Timeout for each item in the cache\n    this.DOWN_HOSTS_TIMEOUT = 600;\n    // Minimum amount of time between each refresh\n    this.MIN_TIME_BETWEEN_REFRESH = 60;\n    // DownHostsCache Map\n    this.downHostsCacheMap = new Map();\n    // Last Refresh Time\n    this.lastRefreshTime = 0;\n  }\n\n  /**\n   * Add an address to the cache\n   *\n   * @param connOption\n   *            address to be cached\n   * @return Map with address as key and time of insertion as value\n   */\n  markDownHost(addr) {\n    return this.downHostsCacheMap.set(addr, Date.now());\n  }\n\n  // Remove elements older than DownHostsTimeout\n  refreshCache() {\n    if (Date.now() - this.MIN_TIME_BETWEEN_REFRESH * 1000 > this.lastRefreshTime) {\n      this.downHostsCacheMap.forEach((value, key) => {\n        const entryTime = value;\n        if (entryTime != null && Date.now() - this.DOWN_HOSTS_TIMEOUT * 1000 > entryTime) {\n          this.downHostsCacheMap.delete(key);\n        }\n      });\n      this.lastRefreshTime = Date.now();\n    }\n  }\n\n  /**\n   * Reorder addresses such that cached elements\n   * occur at the end of the array.\n   */\n  reorderAddresses(cOpts) {\n    this.refreshCache();\n    let topIdx = 0,\n      btmIdx = cOpts.length - 1;\n    while (topIdx < btmIdx) {\n      // increment topIdx if the address is not cached\n      while (topIdx <= btmIdx && !this.isDownHostsCached(cOpts[topIdx])) topIdx++;\n\n      // decrement btmIdx if address is cached\n      while (btmIdx >= topIdx && this.isDownHostsCached(cOpts[btmIdx])) btmIdx--;\n\n      // swap cached with uncached\n      if (topIdx < btmIdx) [cOpts[topIdx], cOpts[btmIdx]] = [cOpts[btmIdx], cOpts[topIdx]];\n    }\n    return cOpts;\n  }\n  /**\n   * Return if a desc is cached.\n   * A desc is cached if all the connection options(addresses)\n   * in that description are cached.\n   */\n  isDownDescCached(desc) {\n    const cOpts = desc.getConnectOptions();\n    for (let i = 0; i < cOpts.length; i++) {\n      if (!this.isDownHostsCached(cOpts[i])) return false;\n    }\n    return true;\n  }\n  /**\n   * Reorder description list such that description with all connection options in downcache\n   * is pushed to the end of the description list\n   */\n  reorderDescriptionList(descs) {\n    this.refreshCache();\n    let topIdx = 0,\n      btmIdx = descs.length - 1;\n    while (topIdx < btmIdx) {\n      // increment topIdx if the desc is not cached\n      while (topIdx <= btmIdx && !this.isDownDescCached(descs[topIdx])) topIdx++;\n\n      // decrement btmIdx if desc is cached\n      while (btmIdx >= topIdx && this.isDownDescCached(descs[btmIdx])) btmIdx--;\n\n      // swap cached with uncached\n      if (topIdx < btmIdx) {\n        [descs[topIdx], descs[btmIdx]] = [descs[btmIdx], descs[topIdx]];\n      }\n    }\n    return descs;\n  }\n  // Return if a host is cached\n  isDownHostsCached(copt) {\n    return this.downHostsCacheMap.has(copt.host);\n  }\n}\n// Single instance\nconst SOLE_INST_DHCACHE = new DownHostsCache();\nmodule.exports = {\n  createNode,\n  SOLE_INST_DHCACHE\n};","map":{"version":3,"names":["NavAddress","NavAddressList","NavDescription","NavDescriptionList","require","createNVPair","errors","ConnectDescription","constructor","cOpts","Array","addConnectOption","opt","push","getConnectOptions","ConnStrategy","reset","retryCount","currentDescription","descriptionList","sBuf","nextOptToTry","lastRetryCounter","lastRetryConnectDescription","reorderDescriptionList","hasMoreOptions","cOptsSize","i","length","newConnectionDescription","getcurrentDescription","closeDescription","execute","config","SOLE_INST_DHCACHE","d","desc","delay","delayInMillis","undefined","retryDelay","reorderAddresses","copt","sleep","Error","time","Promise","resolve","setTimeout","createNode","str","nvpair","arg","name","toUpperCase","navobj","throwErr","ERR_INVALID_CONNECT_STRING_PARAMETERS","initFromNVPair","cs","navigate","DownHostsCache","DOWN_HOSTS_TIMEOUT","MIN_TIME_BETWEEN_REFRESH","downHostsCacheMap","Map","lastRefreshTime","markDownHost","addr","set","Date","now","refreshCache","forEach","value","key","entryTime","delete","topIdx","btmIdx","isDownHostsCached","isDownDescCached","descs","has","host","module","exports"],"sources":["C:/Users/user1/Desktop/finalproject_penpick/node_modules/oracledb/lib/thin/sqlnet/connStrategy.js"],"sourcesContent":["// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst { NavAddress, NavAddressList, NavDescription, NavDescriptionList } = require(\"./navNodes.js\");\nconst { createNVPair } = require(\"./nvStrToNvPair.js\");\nconst errors = require(\"../../errors.js\");\n\n/**\n * Class that holds all possible attributes under Description\n */\nclass ConnectDescription {\n  constructor() {\n    this.cOpts = new Array();\n  }\n\n  addConnectOption(opt) {\n    this.cOpts.push(opt);\n  }\n\n  getConnectOptions() {\n    return this.cOpts;\n  }\n\n}\n\n/**\n * Class that holds a list of possible connection options.\n */\nclass ConnStrategy {\n  constructor() {\n    this.reset();\n    this.retryCount = 0;\n    this.currentDescription = null;\n    this.descriptionList = new Array();\n    this.sBuf = new Array();\n  }\n\n  reset() {\n    this.nextOptToTry = 0;\n    this.lastRetryCounter = 0;\n    this.lastRetryConnectDescription = 0;\n    this.reorderDescriptionList = 0;\n  }\n\n  hasMoreOptions() {\n    let cOptsSize = 0;\n\n    for (let i = 0; i < this.descriptionList.length; ++i) {\n      cOptsSize += this.descriptionList[i].getConnectOptions().length;\n    }\n    return (this.nextOptToTry < cOptsSize);\n  }\n\n  newConnectionDescription() {\n    this.currentDescription = new ConnectDescription();\n    return this.currentDescription;\n  }\n\n  getcurrentDescription() {\n    return this.currentDescription;\n  }\n\n  closeDescription() {\n    this.descriptionList.push(this.currentDescription);\n    this.currentDescription = null;\n  }\n  /**\n  * Execute the Connection Options from the array.  When a refuse packet is received from\n  * server this method is called again and the next connect option is tried.\n  */\n  async execute(config) {\n    /* Check for retryCount in the config if no retryCount exists in the description string */\n    if (config != null) {\n      if (this.retryCount == 0 && config.retryCount > 0) {\n        this.retryCount = config.retryCount;\n      }\n    }\n    if (!this.reorderDescriptionList) {\n      this.descriptionList = SOLE_INST_DHCACHE.reorderDescriptionList(this.descriptionList);\n      this.reorderDescriptionList = true;\n    }\n    /* We try the address list at least once and upto (1 + retryCount) times */\n    for (let d = this.lastRetryConnectDescription; d < this.descriptionList.length; d++) {\n      const desc = this.descriptionList[d];\n      let cOpts = new Array();\n      cOpts = desc.getConnectOptions();\n      let delay = desc.delayInMillis;\n      /* check for retryDelay in config if it doesn't exist in description string */\n      if (config != null) {\n        if ((delay == 0 || delay == undefined) && config.retryDelay > 0) {\n          delay = config.retryDelay * 1000;\n        }\n      }\n      for (let i = this.lastRetryCounter; i <= this.retryCount; ++i) {\n        //Conn options must be reordered only when all options are tried\n        // i.e for retry and before the first try.\n        if (this.nextOptToTry == 0) {\n          cOpts = SOLE_INST_DHCACHE.reorderAddresses(cOpts);\n        }\n        while (this.nextOptToTry < cOpts.length) {\n          const copt = cOpts[this.nextOptToTry];\n          this.lastRetryCounter = i;\n          this.lastRetryConnectDescription = d;\n          this.nextOptToTry++;\n          return copt;\n        }\n        this.nextOptToTry = 0;\n        // if we reached here then we are retrying other descriptor\n        if (delay > 0 && i < this.retryCount) {\n          await sleep(delay);\n        }// end of (delay > 0)\n\n      }// end of for(lastRetryCounter..retryCount)\n      this.lastRetryCounter = 0; // reset after one description is completed\n    }\n    // if we get here, all options were tried and none are valid\n    this.nextOptToTry = 1000;\n    this.lastRetryCounter = 1000;\n    throw new Error(\"All options tried\");\n  }\n  // sleep time expects milliseconds\n\n\n}\nfunction sleep(time) {\n  return new Promise((resolve) => setTimeout(resolve, time));\n}\n\n\n/**\n * create different nodes (schemaobject) as per the given input.\n * @param {string} str - input description string\n * @returns {object} - returns a connection strategy object.\n */\nasync function createNode(str) {\n  let nvpair;\n  if (typeof str === 'string')\n    nvpair = createNVPair(str);\n  else\n    nvpair = str; //Already a NVPair\n\n  const arg = nvpair.name.toUpperCase();\n  let navobj = null;\n  switch (arg) {\n    case \"ADDRESS\":\n      navobj = new NavAddress();\n      break;\n    case \"ADDRESS_LIST\":\n      navobj = new NavAddressList();\n      break;\n    case \"DESCRIPTION\":\n      navobj = new NavDescription();\n      break;\n    case \"DESCRIPTION_LIST\":\n      navobj = new NavDescriptionList();\n      break;\n    default:\n      errors.throwErr(errors.ERR_INVALID_CONNECT_STRING_PARAMETERS,\n        `unknown top element ${arg}`);\n  }\n  navobj.initFromNVPair(nvpair);\n  const cs = new ConnStrategy();\n  await navobj.navigate(cs);\n  return cs;\n}\n\n\nclass DownHostsCache {\n\n  constructor() {\n    // Timeout for each item in the cache\n    this.DOWN_HOSTS_TIMEOUT = 600;\n    // Minimum amount of time between each refresh\n    this.MIN_TIME_BETWEEN_REFRESH = 60;\n    // DownHostsCache Map\n    this.downHostsCacheMap = new Map();\n    // Last Refresh Time\n    this.lastRefreshTime = 0;\n  }\n\n  /**\n   * Add an address to the cache\n   *\n   * @param connOption\n   *            address to be cached\n   * @return Map with address as key and time of insertion as value\n   */\n  markDownHost(addr) {\n    return this.downHostsCacheMap.set(addr, Date.now());\n  }\n\n  // Remove elements older than DownHostsTimeout\n  refreshCache() {\n    if (Date.now() - this.MIN_TIME_BETWEEN_REFRESH * 1000 > this.lastRefreshTime) {\n      this.downHostsCacheMap.forEach((value, key) => {\n        const entryTime = value;\n        if (entryTime != null && ((Date.now() - this.DOWN_HOSTS_TIMEOUT * 1000) > entryTime)) {\n          this.downHostsCacheMap.delete(key);\n        }\n      });\n      this.lastRefreshTime = Date.now();\n    }\n  }\n\n  /**\n   * Reorder addresses such that cached elements\n   * occur at the end of the array.\n   */\n  reorderAddresses(cOpts) {\n    this.refreshCache();\n\n    let topIdx = 0, btmIdx = cOpts.length - 1;\n\n    while (topIdx < btmIdx) {\n\n      // increment topIdx if the address is not cached\n      while (topIdx <= btmIdx\n          && !this.isDownHostsCached(cOpts[topIdx]))\n        topIdx++;\n\n      // decrement btmIdx if address is cached\n      while (btmIdx >= topIdx\n          && this.isDownHostsCached(cOpts[btmIdx]))\n        btmIdx--;\n\n      // swap cached with uncached\n      if (topIdx < btmIdx)\n        [cOpts[topIdx], cOpts[btmIdx]] = [cOpts[btmIdx], cOpts[topIdx]];\n\n    }\n    return cOpts;\n  }\n  /**\n   * Return if a desc is cached.\n   * A desc is cached if all the connection options(addresses)\n   * in that description are cached.\n   */\n  isDownDescCached(desc) {\n    const cOpts = desc.getConnectOptions();\n    for (let i = 0; i < cOpts.length; i++) {\n      if (!this.isDownHostsCached(cOpts[i]))\n        return false;\n    }\n    return true;\n  }\n  /**\n   * Reorder description list such that description with all connection options in downcache\n   * is pushed to the end of the description list\n   */\n  reorderDescriptionList(descs) {\n    this.refreshCache();\n\n    let topIdx = 0, btmIdx = descs.length - 1;\n\n    while (topIdx < btmIdx) {\n\n      // increment topIdx if the desc is not cached\n      while (topIdx <= btmIdx\n          && !this.isDownDescCached(descs[topIdx]))\n        topIdx++;\n\n      // decrement btmIdx if desc is cached\n      while (btmIdx >= topIdx\n          && this.isDownDescCached(descs[btmIdx]))\n        btmIdx--;\n\n      // swap cached with uncached\n      if (topIdx < btmIdx) {\n        [descs[topIdx], descs[btmIdx]] = [descs[btmIdx], descs[topIdx]];\n      }\n    }\n    return descs;\n  }\n  // Return if a host is cached\n  isDownHostsCached(copt) {\n    return this.downHostsCacheMap.has(copt.host);\n  }\n}\n// Single instance\nconst SOLE_INST_DHCACHE = new DownHostsCache();\nmodule.exports = { createNode, SOLE_INST_DHCACHE };\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}